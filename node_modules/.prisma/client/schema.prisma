generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// Roles can be multiple as per frontend (e.g., ["doctor", "clinic_admin"])
// So we store them as a JSON array of strings or use a many-to-many. 
// Given the frontend usage, JSON array is simpler for now, but a many-to-many is better for enterprise.
// Let's stick to the Role enum but users can have multiple in a bridge table.

enum Role {
  super_admin
  clinic_admin
  doctor
  admission
  patient
}

model Clinic {
  id          Int      @id @default(autoincrement())
  name        String
  subdomain   String   @unique
  location    String
  contact     String
  email       String
  logo        String?
  status      String   @default("active") // active, inactive
  modules     Json? // { pharmacy: true, radiology: true, laboratory: true, billing: true }
  createdDate DateTime @default(now())
  updatedAt   DateTime @updatedAt

  staff          ClinicStaff[]
  patients       Patient[]
  appointments   Appointment[]
  invoices       Invoice[]
  medicalRecords MedicalRecord[]
  formTemplates  FormTemplate[]
  departments    Department[]
  auditLogs      AuditLog[]
  notifications  Notification[]
}

model Department {
  id        Int      @id @default(autoincrement())
  clinicId  Int
  name      String
  type      String   @default("CLINICAL") // CLINICAL, SERVICE
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clinic Clinic @relation(fields: [clinicId], references: [id])

  @@unique([clinicId, name])
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String
  name      String
  status    String   @default("active")
  joined    DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  failedLoginAttempts Int       @default(0)
  lockoutUntil        DateTime?

  clinics   ClinicStaff[]
  auditLogs AuditLog[]
}

model ClinicStaff {
  id         Int      @id @default(autoincrement())
  userId     Int
  clinicId   Int
  role       Role     @default(admission)
  department String?
  specialty  String?
  createdAt  DateTime @default(now())

  user   User   @relation(fields: [userId], references: [id])
  clinic Clinic @relation(fields: [clinicId], references: [id])

  @@unique([userId, clinicId, role])
}

model Patient {
  id                    Int       @id @default(autoincrement())
  clinicId              Int
  mrn                   String? // Medical Record Number
  name                  String
  age                   Int?
  email                 String?
  phone                 String
  gender                String?
  address               String?   @db.Text
  medicalHistory        String?   @db.Text
  allergies             String?   @db.Text
  emergencyContactName  String?
  emergencyContactPhone String?
  status                String    @default("Active") // Active, Pending Payment, Old
  createdYear           Int?
  lastVisit             DateTime?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  clinic         Clinic          @relation(fields: [clinicId], references: [id])
  appointments   Appointment[]
  medicalRecords MedicalRecord[]
  invoices       Invoice[]

  @@unique([clinicId, mrn])
}

model Appointment {
  id        Int      @id @default(autoincrement())
  clinicId  Int
  patientId Int
  doctorId  Int
  date      DateTime
  time      String // e.g. "10:30 AM"
  status    String   @default("Pending") // Pending, Approved, Checked In, Cancelled, Completed
  source    String   @default("Walk-in") // Online, Call, Walk-in
  notes     String?  @db.Text
  fees      Decimal? @db.Decimal(10, 2)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clinic  Clinic  @relation(fields: [clinicId], references: [id])
  patient Patient @relation(fields: [patientId], references: [id])
}

model MedicalRecord {
  id         Int      @id @default(autoincrement())
  clinicId   Int
  patientId  Int
  doctorId   Int
  templateId Int?
  visitDate  DateTime @default(now())
  type       String // Assessment Name
  data       Json // All finding fields + pharmacyOrder, labOrder, radiologyOrder
  isClosed   Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  clinic   Clinic        @relation(fields: [clinicId], references: [id])
  patient  Patient       @relation(fields: [patientId], references: [id])
  template FormTemplate? @relation(fields: [templateId], references: [id])
}

model FormTemplate {
  id        Int      @id @default(autoincrement())
  clinicId  Int? // Nullable for global templates
  name      String
  specialty String
  status    String   @default("published") // published, draft
  version   Int      @default(1)
  fields    Json // Array of field definitions
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clinic  Clinic?         @relation(fields: [clinicId], references: [id])
  records MedicalRecord[]
}

model Invoice {
  id        String   @id // INV-9021 format
  clinicId  Int
  patientId Int
  doctorId  Int?
  service   String
  amount    Decimal  @db.Decimal(10, 2)
  status    String   @default("Pending") // Paid, Pending, Cancelled
  date      DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clinic  Clinic  @relation(fields: [clinicId], references: [id])
  patient Patient @relation(fields: [patientId], references: [id])
}

model Notification {
  id         Int      @id @default(autoincrement())
  clinicId   Int
  department String // admission, pharmacy, laboratory, radiology
  message    Json
  status     String   @default("unread")
  createdAt  DateTime @default(now())

  clinic Clinic @relation(fields: [clinicId], references: [id])
}

model AuditLog {
  id          Int      @id @default(autoincrement())
  action      String
  performedBy String // Name or UserID
  userId      Int?
  clinicId    Int?
  timestamp   DateTime @default(now())
  ipAddress   String?
  device      String?
  details     Json?

  user   User?   @relation(fields: [userId], references: [id])
  clinic Clinic? @relation(fields: [clinicId], references: [id])
}
