
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model appointment
 * 
 */
export type appointment = $Result.DefaultSelection<Prisma.$appointmentPayload>
/**
 * Model auditlog
 * 
 */
export type auditlog = $Result.DefaultSelection<Prisma.$auditlogPayload>
/**
 * Model clinic
 * 
 */
export type clinic = $Result.DefaultSelection<Prisma.$clinicPayload>
/**
 * Model clinicstaff
 * 
 */
export type clinicstaff = $Result.DefaultSelection<Prisma.$clinicstaffPayload>
/**
 * Model department
 * 
 */
export type department = $Result.DefaultSelection<Prisma.$departmentPayload>
/**
 * Model formtemplate
 * 
 */
export type formtemplate = $Result.DefaultSelection<Prisma.$formtemplatePayload>
/**
 * Model invoice
 * 
 */
export type invoice = $Result.DefaultSelection<Prisma.$invoicePayload>
/**
 * Model medicalrecord
 * 
 */
export type medicalrecord = $Result.DefaultSelection<Prisma.$medicalrecordPayload>
/**
 * Model formresponse
 * 
 */
export type formresponse = $Result.DefaultSelection<Prisma.$formresponsePayload>
/**
 * Model notification
 * 
 */
export type notification = $Result.DefaultSelection<Prisma.$notificationPayload>
/**
 * Model patient
 * 
 */
export type patient = $Result.DefaultSelection<Prisma.$patientPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const clinicstaff_role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  DOCTOR: 'DOCTOR',
  RECEPTIONIST: 'RECEPTIONIST',
  PATIENT: 'PATIENT'
};

export type clinicstaff_role = (typeof clinicstaff_role)[keyof typeof clinicstaff_role]


export const user_role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  DOCTOR: 'DOCTOR',
  RECEPTIONIST: 'RECEPTIONIST',
  PATIENT: 'PATIENT'
};

export type user_role = (typeof user_role)[keyof typeof user_role]

}

export type clinicstaff_role = $Enums.clinicstaff_role

export const clinicstaff_role: typeof $Enums.clinicstaff_role

export type user_role = $Enums.user_role

export const user_role: typeof $Enums.user_role

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Appointments
 * const appointments = await prisma.appointment.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Appointments
   * const appointments = await prisma.appointment.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.appointment`: Exposes CRUD operations for the **appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.appointmentDelegate<ExtArgs>;

  /**
   * `prisma.auditlog`: Exposes CRUD operations for the **auditlog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auditlogs
    * const auditlogs = await prisma.auditlog.findMany()
    * ```
    */
  get auditlog(): Prisma.auditlogDelegate<ExtArgs>;

  /**
   * `prisma.clinic`: Exposes CRUD operations for the **clinic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clinics
    * const clinics = await prisma.clinic.findMany()
    * ```
    */
  get clinic(): Prisma.clinicDelegate<ExtArgs>;

  /**
   * `prisma.clinicstaff`: Exposes CRUD operations for the **clinicstaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clinicstaffs
    * const clinicstaffs = await prisma.clinicstaff.findMany()
    * ```
    */
  get clinicstaff(): Prisma.clinicstaffDelegate<ExtArgs>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.departmentDelegate<ExtArgs>;

  /**
   * `prisma.formtemplate`: Exposes CRUD operations for the **formtemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Formtemplates
    * const formtemplates = await prisma.formtemplate.findMany()
    * ```
    */
  get formtemplate(): Prisma.formtemplateDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.invoiceDelegate<ExtArgs>;

  /**
   * `prisma.medicalrecord`: Exposes CRUD operations for the **medicalrecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medicalrecords
    * const medicalrecords = await prisma.medicalrecord.findMany()
    * ```
    */
  get medicalrecord(): Prisma.medicalrecordDelegate<ExtArgs>;

  /**
   * `prisma.formresponse`: Exposes CRUD operations for the **formresponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Formresponses
    * const formresponses = await prisma.formresponse.findMany()
    * ```
    */
  get formresponse(): Prisma.formresponseDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.notificationDelegate<ExtArgs>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.patientDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    appointment: 'appointment',
    auditlog: 'auditlog',
    clinic: 'clinic',
    clinicstaff: 'clinicstaff',
    department: 'department',
    formtemplate: 'formtemplate',
    invoice: 'invoice',
    medicalrecord: 'medicalrecord',
    formresponse: 'formresponse',
    notification: 'notification',
    patient: 'patient',
    user: 'user'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "appointment" | "auditlog" | "clinic" | "clinicstaff" | "department" | "formtemplate" | "invoice" | "medicalrecord" | "formresponse" | "notification" | "patient" | "user"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      appointment: {
        payload: Prisma.$appointmentPayload<ExtArgs>
        fields: Prisma.appointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.appointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.appointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentPayload>
          }
          findFirst: {
            args: Prisma.appointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.appointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentPayload>
          }
          findMany: {
            args: Prisma.appointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentPayload>[]
          }
          create: {
            args: Prisma.appointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentPayload>
          }
          createMany: {
            args: Prisma.appointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.appointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentPayload>
          }
          update: {
            args: Prisma.appointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentPayload>
          }
          deleteMany: {
            args: Prisma.appointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.appointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.appointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.appointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.appointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      auditlog: {
        payload: Prisma.$auditlogPayload<ExtArgs>
        fields: Prisma.auditlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auditlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auditlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          findFirst: {
            args: Prisma.auditlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auditlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          findMany: {
            args: Prisma.auditlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>[]
          }
          create: {
            args: Prisma.auditlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          createMany: {
            args: Prisma.auditlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.auditlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          update: {
            args: Prisma.auditlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          deleteMany: {
            args: Prisma.auditlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auditlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.auditlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          aggregate: {
            args: Prisma.AuditlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditlog>
          }
          groupBy: {
            args: Prisma.auditlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.auditlogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditlogCountAggregateOutputType> | number
          }
        }
      }
      clinic: {
        payload: Prisma.$clinicPayload<ExtArgs>
        fields: Prisma.clinicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clinicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clinicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinicPayload>
          }
          findFirst: {
            args: Prisma.clinicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clinicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinicPayload>
          }
          findMany: {
            args: Prisma.clinicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinicPayload>[]
          }
          create: {
            args: Prisma.clinicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinicPayload>
          }
          createMany: {
            args: Prisma.clinicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.clinicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinicPayload>
          }
          update: {
            args: Prisma.clinicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinicPayload>
          }
          deleteMany: {
            args: Prisma.clinicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clinicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.clinicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinicPayload>
          }
          aggregate: {
            args: Prisma.ClinicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinic>
          }
          groupBy: {
            args: Prisma.clinicGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicGroupByOutputType>[]
          }
          count: {
            args: Prisma.clinicCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicCountAggregateOutputType> | number
          }
        }
      }
      clinicstaff: {
        payload: Prisma.$clinicstaffPayload<ExtArgs>
        fields: Prisma.clinicstaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clinicstaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinicstaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clinicstaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinicstaffPayload>
          }
          findFirst: {
            args: Prisma.clinicstaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinicstaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clinicstaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinicstaffPayload>
          }
          findMany: {
            args: Prisma.clinicstaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinicstaffPayload>[]
          }
          create: {
            args: Prisma.clinicstaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinicstaffPayload>
          }
          createMany: {
            args: Prisma.clinicstaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.clinicstaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinicstaffPayload>
          }
          update: {
            args: Prisma.clinicstaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinicstaffPayload>
          }
          deleteMany: {
            args: Prisma.clinicstaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clinicstaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.clinicstaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clinicstaffPayload>
          }
          aggregate: {
            args: Prisma.ClinicstaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinicstaff>
          }
          groupBy: {
            args: Prisma.clinicstaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicstaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.clinicstaffCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicstaffCountAggregateOutputType> | number
          }
        }
      }
      department: {
        payload: Prisma.$departmentPayload<ExtArgs>
        fields: Prisma.departmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.departmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.departmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>
          }
          findFirst: {
            args: Prisma.departmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.departmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>
          }
          findMany: {
            args: Prisma.departmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>[]
          }
          create: {
            args: Prisma.departmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>
          }
          createMany: {
            args: Prisma.departmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.departmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>
          }
          update: {
            args: Prisma.departmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>
          }
          deleteMany: {
            args: Prisma.departmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.departmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.departmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.departmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.departmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      formtemplate: {
        payload: Prisma.$formtemplatePayload<ExtArgs>
        fields: Prisma.formtemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.formtemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formtemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.formtemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formtemplatePayload>
          }
          findFirst: {
            args: Prisma.formtemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formtemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.formtemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formtemplatePayload>
          }
          findMany: {
            args: Prisma.formtemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formtemplatePayload>[]
          }
          create: {
            args: Prisma.formtemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formtemplatePayload>
          }
          createMany: {
            args: Prisma.formtemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.formtemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formtemplatePayload>
          }
          update: {
            args: Prisma.formtemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formtemplatePayload>
          }
          deleteMany: {
            args: Prisma.formtemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.formtemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.formtemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formtemplatePayload>
          }
          aggregate: {
            args: Prisma.FormtemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormtemplate>
          }
          groupBy: {
            args: Prisma.formtemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormtemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.formtemplateCountArgs<ExtArgs>
            result: $Utils.Optional<FormtemplateCountAggregateOutputType> | number
          }
        }
      }
      invoice: {
        payload: Prisma.$invoicePayload<ExtArgs>
        fields: Prisma.invoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>
          }
          findFirst: {
            args: Prisma.invoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>
          }
          findMany: {
            args: Prisma.invoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>[]
          }
          create: {
            args: Prisma.invoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>
          }
          createMany: {
            args: Prisma.invoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.invoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>
          }
          update: {
            args: Prisma.invoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>
          }
          deleteMany: {
            args: Prisma.invoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.invoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.invoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.invoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.invoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      medicalrecord: {
        payload: Prisma.$medicalrecordPayload<ExtArgs>
        fields: Prisma.medicalrecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.medicalrecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicalrecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.medicalrecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicalrecordPayload>
          }
          findFirst: {
            args: Prisma.medicalrecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicalrecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.medicalrecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicalrecordPayload>
          }
          findMany: {
            args: Prisma.medicalrecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicalrecordPayload>[]
          }
          create: {
            args: Prisma.medicalrecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicalrecordPayload>
          }
          createMany: {
            args: Prisma.medicalrecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.medicalrecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicalrecordPayload>
          }
          update: {
            args: Prisma.medicalrecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicalrecordPayload>
          }
          deleteMany: {
            args: Prisma.medicalrecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.medicalrecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.medicalrecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medicalrecordPayload>
          }
          aggregate: {
            args: Prisma.MedicalrecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalrecord>
          }
          groupBy: {
            args: Prisma.medicalrecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalrecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.medicalrecordCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalrecordCountAggregateOutputType> | number
          }
        }
      }
      formresponse: {
        payload: Prisma.$formresponsePayload<ExtArgs>
        fields: Prisma.formresponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.formresponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formresponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.formresponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formresponsePayload>
          }
          findFirst: {
            args: Prisma.formresponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formresponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.formresponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formresponsePayload>
          }
          findMany: {
            args: Prisma.formresponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formresponsePayload>[]
          }
          create: {
            args: Prisma.formresponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formresponsePayload>
          }
          createMany: {
            args: Prisma.formresponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.formresponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formresponsePayload>
          }
          update: {
            args: Prisma.formresponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formresponsePayload>
          }
          deleteMany: {
            args: Prisma.formresponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.formresponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.formresponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formresponsePayload>
          }
          aggregate: {
            args: Prisma.FormresponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormresponse>
          }
          groupBy: {
            args: Prisma.formresponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormresponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.formresponseCountArgs<ExtArgs>
            result: $Utils.Optional<FormresponseCountAggregateOutputType> | number
          }
        }
      }
      notification: {
        payload: Prisma.$notificationPayload<ExtArgs>
        fields: Prisma.notificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findFirst: {
            args: Prisma.notificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          findMany: {
            args: Prisma.notificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>[]
          }
          create: {
            args: Prisma.notificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          createMany: {
            args: Prisma.notificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.notificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          update: {
            args: Prisma.notificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          deleteMany: {
            args: Prisma.notificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.notificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      patient: {
        payload: Prisma.$patientPayload<ExtArgs>
        fields: Prisma.patientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.patientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.patientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientPayload>
          }
          findFirst: {
            args: Prisma.patientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.patientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientPayload>
          }
          findMany: {
            args: Prisma.patientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientPayload>[]
          }
          create: {
            args: Prisma.patientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientPayload>
          }
          createMany: {
            args: Prisma.patientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.patientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientPayload>
          }
          update: {
            args: Prisma.patientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientPayload>
          }
          deleteMany: {
            args: Prisma.patientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.patientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.patientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.patientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.patientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClinicCountOutputType
   */

  export type ClinicCountOutputType = {
    appointment: number
    auditlog: number
    clinicstaff: number
    department: number
    formtemplate: number
    invoice: number
    medicalrecord: number
    notification: number
    patient: number
    formresponse: number
  }

  export type ClinicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | ClinicCountOutputTypeCountAppointmentArgs
    auditlog?: boolean | ClinicCountOutputTypeCountAuditlogArgs
    clinicstaff?: boolean | ClinicCountOutputTypeCountClinicstaffArgs
    department?: boolean | ClinicCountOutputTypeCountDepartmentArgs
    formtemplate?: boolean | ClinicCountOutputTypeCountFormtemplateArgs
    invoice?: boolean | ClinicCountOutputTypeCountInvoiceArgs
    medicalrecord?: boolean | ClinicCountOutputTypeCountMedicalrecordArgs
    notification?: boolean | ClinicCountOutputTypeCountNotificationArgs
    patient?: boolean | ClinicCountOutputTypeCountPatientArgs
    formresponse?: boolean | ClinicCountOutputTypeCountFormresponseArgs
  }

  // Custom InputTypes
  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicCountOutputType
     */
    select?: ClinicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountAppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountAuditlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditlogWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountClinicstaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clinicstaffWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountDepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: departmentWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountFormtemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formtemplateWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoiceWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountMedicalrecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medicalrecordWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountPatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patientWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountFormresponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formresponseWhereInput
  }


  /**
   * Count Type FormtemplateCountOutputType
   */

  export type FormtemplateCountOutputType = {
    medicalrecord: number
    formresponse: number
  }

  export type FormtemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalrecord?: boolean | FormtemplateCountOutputTypeCountMedicalrecordArgs
    formresponse?: boolean | FormtemplateCountOutputTypeCountFormresponseArgs
  }

  // Custom InputTypes
  /**
   * FormtemplateCountOutputType without action
   */
  export type FormtemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormtemplateCountOutputType
     */
    select?: FormtemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormtemplateCountOutputType without action
   */
  export type FormtemplateCountOutputTypeCountMedicalrecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medicalrecordWhereInput
  }

  /**
   * FormtemplateCountOutputType without action
   */
  export type FormtemplateCountOutputTypeCountFormresponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formresponseWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    appointment: number
    invoice: number
    medicalrecord: number
    formresponse: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | PatientCountOutputTypeCountAppointmentArgs
    invoice?: boolean | PatientCountOutputTypeCountInvoiceArgs
    medicalrecord?: boolean | PatientCountOutputTypeCountMedicalrecordArgs
    formresponse?: boolean | PatientCountOutputTypeCountFormresponseArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountInvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoiceWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountMedicalrecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medicalrecordWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountFormresponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formresponseWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    auditlog: number
    clinicstaff: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditlog?: boolean | UserCountOutputTypeCountAuditlogArgs
    clinicstaff?: boolean | UserCountOutputTypeCountClinicstaffArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditlogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClinicstaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clinicstaffWhereInput
  }


  /**
   * Models
   */

  /**
   * Model appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    id: number | null
    clinicId: number | null
    patientId: number | null
    doctorId: number | null
    fees: Decimal | null
  }

  export type AppointmentSumAggregateOutputType = {
    id: number | null
    clinicId: number | null
    patientId: number | null
    doctorId: number | null
    fees: Decimal | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: number | null
    clinicId: number | null
    patientId: number | null
    doctorId: number | null
    date: Date | null
    time: string | null
    status: string | null
    source: string | null
    referenceId: string | null
    notes: string | null
    fees: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: number | null
    clinicId: number | null
    patientId: number | null
    doctorId: number | null
    date: Date | null
    time: string | null
    status: string | null
    source: string | null
    referenceId: string | null
    notes: string | null
    fees: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    clinicId: number
    patientId: number
    doctorId: number
    date: number
    time: number
    status: number
    source: number
    referenceId: number
    notes: number
    fees: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    fees?: true
  }

  export type AppointmentSumAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    fees?: true
  }

  export type AppointmentMinAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    date?: true
    time?: true
    status?: true
    source?: true
    referenceId?: true
    notes?: true
    fees?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    date?: true
    time?: true
    status?: true
    source?: true
    referenceId?: true
    notes?: true
    fees?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    date?: true
    time?: true
    status?: true
    source?: true
    referenceId?: true
    notes?: true
    fees?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which appointment to aggregate.
     */
    where?: appointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentOrderByWithRelationInput | appointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: appointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type appointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentWhereInput
    orderBy?: appointmentOrderByWithAggregationInput | appointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: appointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: number
    clinicId: number
    patientId: number
    doctorId: number
    date: Date
    time: string
    status: string
    source: string
    referenceId: string | null
    notes: string | null
    fees: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends appointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type appointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    doctorId?: boolean
    date?: boolean
    time?: boolean
    status?: boolean
    source?: boolean
    referenceId?: boolean
    notes?: boolean
    fees?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | clinicDefaultArgs<ExtArgs>
    patient?: boolean | patientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>


  export type appointmentSelectScalar = {
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    doctorId?: boolean
    date?: boolean
    time?: boolean
    status?: boolean
    source?: boolean
    referenceId?: boolean
    notes?: boolean
    fees?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type appointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | clinicDefaultArgs<ExtArgs>
    patient?: boolean | patientDefaultArgs<ExtArgs>
  }

  export type $appointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "appointment"
    objects: {
      clinic: Prisma.$clinicPayload<ExtArgs>
      patient: Prisma.$patientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clinicId: number
      patientId: number
      doctorId: number
      date: Date
      time: string
      status: string
      source: string
      referenceId: string | null
      notes: string | null
      fees: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type appointmentGetPayload<S extends boolean | null | undefined | appointmentDefaultArgs> = $Result.GetResult<Prisma.$appointmentPayload, S>

  type appointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<appointmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface appointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['appointment'], meta: { name: 'appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {appointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends appointmentFindUniqueArgs>(args: SelectSubset<T, appointmentFindUniqueArgs<ExtArgs>>): Prisma__appointmentClient<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {appointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends appointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, appointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__appointmentClient<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends appointmentFindFirstArgs>(args?: SelectSubset<T, appointmentFindFirstArgs<ExtArgs>>): Prisma__appointmentClient<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends appointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, appointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__appointmentClient<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends appointmentFindManyArgs>(args?: SelectSubset<T, appointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Appointment.
     * @param {appointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends appointmentCreateArgs>(args: SelectSubset<T, appointmentCreateArgs<ExtArgs>>): Prisma__appointmentClient<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Appointments.
     * @param {appointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends appointmentCreateManyArgs>(args?: SelectSubset<T, appointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Appointment.
     * @param {appointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends appointmentDeleteArgs>(args: SelectSubset<T, appointmentDeleteArgs<ExtArgs>>): Prisma__appointmentClient<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Appointment.
     * @param {appointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends appointmentUpdateArgs>(args: SelectSubset<T, appointmentUpdateArgs<ExtArgs>>): Prisma__appointmentClient<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Appointments.
     * @param {appointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends appointmentDeleteManyArgs>(args?: SelectSubset<T, appointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends appointmentUpdateManyArgs>(args: SelectSubset<T, appointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Appointment.
     * @param {appointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends appointmentUpsertArgs>(args: SelectSubset<T, appointmentUpsertArgs<ExtArgs>>): Prisma__appointmentClient<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends appointmentCountArgs>(
      args?: Subset<T, appointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends appointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: appointmentGroupByArgs['orderBy'] }
        : { orderBy?: appointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, appointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the appointment model
   */
  readonly fields: appointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__appointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends clinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clinicDefaultArgs<ExtArgs>>): Prisma__clinicClient<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    patient<T extends patientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, patientDefaultArgs<ExtArgs>>): Prisma__patientClient<$Result.GetResult<Prisma.$patientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the appointment model
   */ 
  interface appointmentFieldRefs {
    readonly id: FieldRef<"appointment", 'Int'>
    readonly clinicId: FieldRef<"appointment", 'Int'>
    readonly patientId: FieldRef<"appointment", 'Int'>
    readonly doctorId: FieldRef<"appointment", 'Int'>
    readonly date: FieldRef<"appointment", 'DateTime'>
    readonly time: FieldRef<"appointment", 'String'>
    readonly status: FieldRef<"appointment", 'String'>
    readonly source: FieldRef<"appointment", 'String'>
    readonly referenceId: FieldRef<"appointment", 'String'>
    readonly notes: FieldRef<"appointment", 'String'>
    readonly fees: FieldRef<"appointment", 'Decimal'>
    readonly createdAt: FieldRef<"appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * appointment findUnique
   */
  export type appointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentInclude<ExtArgs> | null
    /**
     * Filter, which appointment to fetch.
     */
    where: appointmentWhereUniqueInput
  }

  /**
   * appointment findUniqueOrThrow
   */
  export type appointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentInclude<ExtArgs> | null
    /**
     * Filter, which appointment to fetch.
     */
    where: appointmentWhereUniqueInput
  }

  /**
   * appointment findFirst
   */
  export type appointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentInclude<ExtArgs> | null
    /**
     * Filter, which appointment to fetch.
     */
    where?: appointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentOrderByWithRelationInput | appointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for appointments.
     */
    cursor?: appointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * appointment findFirstOrThrow
   */
  export type appointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentInclude<ExtArgs> | null
    /**
     * Filter, which appointment to fetch.
     */
    where?: appointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentOrderByWithRelationInput | appointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for appointments.
     */
    cursor?: appointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * appointment findMany
   */
  export type appointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentInclude<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where?: appointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentOrderByWithRelationInput | appointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing appointments.
     */
    cursor?: appointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * appointment create
   */
  export type appointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a appointment.
     */
    data: XOR<appointmentCreateInput, appointmentUncheckedCreateInput>
  }

  /**
   * appointment createMany
   */
  export type appointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many appointments.
     */
    data: appointmentCreateManyInput | appointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * appointment update
   */
  export type appointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a appointment.
     */
    data: XOR<appointmentUpdateInput, appointmentUncheckedUpdateInput>
    /**
     * Choose, which appointment to update.
     */
    where: appointmentWhereUniqueInput
  }

  /**
   * appointment updateMany
   */
  export type appointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update appointments.
     */
    data: XOR<appointmentUpdateManyMutationInput, appointmentUncheckedUpdateManyInput>
    /**
     * Filter which appointments to update
     */
    where?: appointmentWhereInput
  }

  /**
   * appointment upsert
   */
  export type appointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the appointment to update in case it exists.
     */
    where: appointmentWhereUniqueInput
    /**
     * In case the appointment found by the `where` argument doesn't exist, create a new appointment with this data.
     */
    create: XOR<appointmentCreateInput, appointmentUncheckedCreateInput>
    /**
     * In case the appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<appointmentUpdateInput, appointmentUncheckedUpdateInput>
  }

  /**
   * appointment delete
   */
  export type appointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentInclude<ExtArgs> | null
    /**
     * Filter which appointment to delete.
     */
    where: appointmentWhereUniqueInput
  }

  /**
   * appointment deleteMany
   */
  export type appointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which appointments to delete
     */
    where?: appointmentWhereInput
  }

  /**
   * appointment without action
   */
  export type appointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentInclude<ExtArgs> | null
  }


  /**
   * Model auditlog
   */

  export type AggregateAuditlog = {
    _count: AuditlogCountAggregateOutputType | null
    _avg: AuditlogAvgAggregateOutputType | null
    _sum: AuditlogSumAggregateOutputType | null
    _min: AuditlogMinAggregateOutputType | null
    _max: AuditlogMaxAggregateOutputType | null
  }

  export type AuditlogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    clinicId: number | null
  }

  export type AuditlogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    clinicId: number | null
  }

  export type AuditlogMinAggregateOutputType = {
    id: number | null
    action: string | null
    performedBy: string | null
    userId: number | null
    clinicId: number | null
    timestamp: Date | null
    ipAddress: string | null
    device: string | null
    details: string | null
  }

  export type AuditlogMaxAggregateOutputType = {
    id: number | null
    action: string | null
    performedBy: string | null
    userId: number | null
    clinicId: number | null
    timestamp: Date | null
    ipAddress: string | null
    device: string | null
    details: string | null
  }

  export type AuditlogCountAggregateOutputType = {
    id: number
    action: number
    performedBy: number
    userId: number
    clinicId: number
    timestamp: number
    ipAddress: number
    device: number
    details: number
    _all: number
  }


  export type AuditlogAvgAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
  }

  export type AuditlogSumAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
  }

  export type AuditlogMinAggregateInputType = {
    id?: true
    action?: true
    performedBy?: true
    userId?: true
    clinicId?: true
    timestamp?: true
    ipAddress?: true
    device?: true
    details?: true
  }

  export type AuditlogMaxAggregateInputType = {
    id?: true
    action?: true
    performedBy?: true
    userId?: true
    clinicId?: true
    timestamp?: true
    ipAddress?: true
    device?: true
    details?: true
  }

  export type AuditlogCountAggregateInputType = {
    id?: true
    action?: true
    performedBy?: true
    userId?: true
    clinicId?: true
    timestamp?: true
    ipAddress?: true
    device?: true
    details?: true
    _all?: true
  }

  export type AuditlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditlog to aggregate.
     */
    where?: auditlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditlogs to fetch.
     */
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auditlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auditlogs
    **/
    _count?: true | AuditlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditlogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditlogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditlogMaxAggregateInputType
  }

  export type GetAuditlogAggregateType<T extends AuditlogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditlog[P]>
      : GetScalarType<T[P], AggregateAuditlog[P]>
  }




  export type auditlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditlogWhereInput
    orderBy?: auditlogOrderByWithAggregationInput | auditlogOrderByWithAggregationInput[]
    by: AuditlogScalarFieldEnum[] | AuditlogScalarFieldEnum
    having?: auditlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditlogCountAggregateInputType | true
    _avg?: AuditlogAvgAggregateInputType
    _sum?: AuditlogSumAggregateInputType
    _min?: AuditlogMinAggregateInputType
    _max?: AuditlogMaxAggregateInputType
  }

  export type AuditlogGroupByOutputType = {
    id: number
    action: string
    performedBy: string
    userId: number | null
    clinicId: number | null
    timestamp: Date
    ipAddress: string | null
    device: string | null
    details: string | null
    _count: AuditlogCountAggregateOutputType | null
    _avg: AuditlogAvgAggregateOutputType | null
    _sum: AuditlogSumAggregateOutputType | null
    _min: AuditlogMinAggregateOutputType | null
    _max: AuditlogMaxAggregateOutputType | null
  }

  type GetAuditlogGroupByPayload<T extends auditlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditlogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditlogGroupByOutputType[P]>
        }
      >
    >


  export type auditlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    performedBy?: boolean
    userId?: boolean
    clinicId?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    device?: boolean
    details?: boolean
    clinic?: boolean | auditlog$clinicArgs<ExtArgs>
    user?: boolean | auditlog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditlog"]>


  export type auditlogSelectScalar = {
    id?: boolean
    action?: boolean
    performedBy?: boolean
    userId?: boolean
    clinicId?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    device?: boolean
    details?: boolean
  }

  export type auditlogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | auditlog$clinicArgs<ExtArgs>
    user?: boolean | auditlog$userArgs<ExtArgs>
  }

  export type $auditlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auditlog"
    objects: {
      clinic: Prisma.$clinicPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      action: string
      performedBy: string
      userId: number | null
      clinicId: number | null
      timestamp: Date
      ipAddress: string | null
      device: string | null
      details: string | null
    }, ExtArgs["result"]["auditlog"]>
    composites: {}
  }

  type auditlogGetPayload<S extends boolean | null | undefined | auditlogDefaultArgs> = $Result.GetResult<Prisma.$auditlogPayload, S>

  type auditlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<auditlogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditlogCountAggregateInputType | true
    }

  export interface auditlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auditlog'], meta: { name: 'auditlog' } }
    /**
     * Find zero or one Auditlog that matches the filter.
     * @param {auditlogFindUniqueArgs} args - Arguments to find a Auditlog
     * @example
     * // Get one Auditlog
     * const auditlog = await prisma.auditlog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auditlogFindUniqueArgs>(args: SelectSubset<T, auditlogFindUniqueArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Auditlog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {auditlogFindUniqueOrThrowArgs} args - Arguments to find a Auditlog
     * @example
     * // Get one Auditlog
     * const auditlog = await prisma.auditlog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auditlogFindUniqueOrThrowArgs>(args: SelectSubset<T, auditlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Auditlog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogFindFirstArgs} args - Arguments to find a Auditlog
     * @example
     * // Get one Auditlog
     * const auditlog = await prisma.auditlog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auditlogFindFirstArgs>(args?: SelectSubset<T, auditlogFindFirstArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Auditlog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogFindFirstOrThrowArgs} args - Arguments to find a Auditlog
     * @example
     * // Get one Auditlog
     * const auditlog = await prisma.auditlog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auditlogFindFirstOrThrowArgs>(args?: SelectSubset<T, auditlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Auditlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auditlogs
     * const auditlogs = await prisma.auditlog.findMany()
     * 
     * // Get first 10 Auditlogs
     * const auditlogs = await prisma.auditlog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditlogWithIdOnly = await prisma.auditlog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends auditlogFindManyArgs>(args?: SelectSubset<T, auditlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Auditlog.
     * @param {auditlogCreateArgs} args - Arguments to create a Auditlog.
     * @example
     * // Create one Auditlog
     * const Auditlog = await prisma.auditlog.create({
     *   data: {
     *     // ... data to create a Auditlog
     *   }
     * })
     * 
     */
    create<T extends auditlogCreateArgs>(args: SelectSubset<T, auditlogCreateArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Auditlogs.
     * @param {auditlogCreateManyArgs} args - Arguments to create many Auditlogs.
     * @example
     * // Create many Auditlogs
     * const auditlog = await prisma.auditlog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auditlogCreateManyArgs>(args?: SelectSubset<T, auditlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auditlog.
     * @param {auditlogDeleteArgs} args - Arguments to delete one Auditlog.
     * @example
     * // Delete one Auditlog
     * const Auditlog = await prisma.auditlog.delete({
     *   where: {
     *     // ... filter to delete one Auditlog
     *   }
     * })
     * 
     */
    delete<T extends auditlogDeleteArgs>(args: SelectSubset<T, auditlogDeleteArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Auditlog.
     * @param {auditlogUpdateArgs} args - Arguments to update one Auditlog.
     * @example
     * // Update one Auditlog
     * const auditlog = await prisma.auditlog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auditlogUpdateArgs>(args: SelectSubset<T, auditlogUpdateArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Auditlogs.
     * @param {auditlogDeleteManyArgs} args - Arguments to filter Auditlogs to delete.
     * @example
     * // Delete a few Auditlogs
     * const { count } = await prisma.auditlog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auditlogDeleteManyArgs>(args?: SelectSubset<T, auditlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auditlogs
     * const auditlog = await prisma.auditlog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auditlogUpdateManyArgs>(args: SelectSubset<T, auditlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auditlog.
     * @param {auditlogUpsertArgs} args - Arguments to update or create a Auditlog.
     * @example
     * // Update or create a Auditlog
     * const auditlog = await prisma.auditlog.upsert({
     *   create: {
     *     // ... data to create a Auditlog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auditlog we want to update
     *   }
     * })
     */
    upsert<T extends auditlogUpsertArgs>(args: SelectSubset<T, auditlogUpsertArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Auditlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogCountArgs} args - Arguments to filter Auditlogs to count.
     * @example
     * // Count the number of Auditlogs
     * const count = await prisma.auditlog.count({
     *   where: {
     *     // ... the filter for the Auditlogs we want to count
     *   }
     * })
    **/
    count<T extends auditlogCountArgs>(
      args?: Subset<T, auditlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auditlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditlogAggregateArgs>(args: Subset<T, AuditlogAggregateArgs>): Prisma.PrismaPromise<GetAuditlogAggregateType<T>>

    /**
     * Group by Auditlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auditlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auditlogGroupByArgs['orderBy'] }
        : { orderBy?: auditlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auditlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auditlog model
   */
  readonly fields: auditlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auditlog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auditlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends auditlog$clinicArgs<ExtArgs> = {}>(args?: Subset<T, auditlog$clinicArgs<ExtArgs>>): Prisma__clinicClient<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends auditlog$userArgs<ExtArgs> = {}>(args?: Subset<T, auditlog$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auditlog model
   */ 
  interface auditlogFieldRefs {
    readonly id: FieldRef<"auditlog", 'Int'>
    readonly action: FieldRef<"auditlog", 'String'>
    readonly performedBy: FieldRef<"auditlog", 'String'>
    readonly userId: FieldRef<"auditlog", 'Int'>
    readonly clinicId: FieldRef<"auditlog", 'Int'>
    readonly timestamp: FieldRef<"auditlog", 'DateTime'>
    readonly ipAddress: FieldRef<"auditlog", 'String'>
    readonly device: FieldRef<"auditlog", 'String'>
    readonly details: FieldRef<"auditlog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * auditlog findUnique
   */
  export type auditlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    /**
     * Filter, which auditlog to fetch.
     */
    where: auditlogWhereUniqueInput
  }

  /**
   * auditlog findUniqueOrThrow
   */
  export type auditlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    /**
     * Filter, which auditlog to fetch.
     */
    where: auditlogWhereUniqueInput
  }

  /**
   * auditlog findFirst
   */
  export type auditlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    /**
     * Filter, which auditlog to fetch.
     */
    where?: auditlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditlogs to fetch.
     */
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditlogs.
     */
    cursor?: auditlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditlogs.
     */
    distinct?: AuditlogScalarFieldEnum | AuditlogScalarFieldEnum[]
  }

  /**
   * auditlog findFirstOrThrow
   */
  export type auditlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    /**
     * Filter, which auditlog to fetch.
     */
    where?: auditlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditlogs to fetch.
     */
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditlogs.
     */
    cursor?: auditlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditlogs.
     */
    distinct?: AuditlogScalarFieldEnum | AuditlogScalarFieldEnum[]
  }

  /**
   * auditlog findMany
   */
  export type auditlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    /**
     * Filter, which auditlogs to fetch.
     */
    where?: auditlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditlogs to fetch.
     */
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auditlogs.
     */
    cursor?: auditlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditlogs.
     */
    skip?: number
    distinct?: AuditlogScalarFieldEnum | AuditlogScalarFieldEnum[]
  }

  /**
   * auditlog create
   */
  export type auditlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    /**
     * The data needed to create a auditlog.
     */
    data: XOR<auditlogCreateInput, auditlogUncheckedCreateInput>
  }

  /**
   * auditlog createMany
   */
  export type auditlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auditlogs.
     */
    data: auditlogCreateManyInput | auditlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auditlog update
   */
  export type auditlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    /**
     * The data needed to update a auditlog.
     */
    data: XOR<auditlogUpdateInput, auditlogUncheckedUpdateInput>
    /**
     * Choose, which auditlog to update.
     */
    where: auditlogWhereUniqueInput
  }

  /**
   * auditlog updateMany
   */
  export type auditlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auditlogs.
     */
    data: XOR<auditlogUpdateManyMutationInput, auditlogUncheckedUpdateManyInput>
    /**
     * Filter which auditlogs to update
     */
    where?: auditlogWhereInput
  }

  /**
   * auditlog upsert
   */
  export type auditlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    /**
     * The filter to search for the auditlog to update in case it exists.
     */
    where: auditlogWhereUniqueInput
    /**
     * In case the auditlog found by the `where` argument doesn't exist, create a new auditlog with this data.
     */
    create: XOR<auditlogCreateInput, auditlogUncheckedCreateInput>
    /**
     * In case the auditlog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auditlogUpdateInput, auditlogUncheckedUpdateInput>
  }

  /**
   * auditlog delete
   */
  export type auditlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    /**
     * Filter which auditlog to delete.
     */
    where: auditlogWhereUniqueInput
  }

  /**
   * auditlog deleteMany
   */
  export type auditlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditlogs to delete
     */
    where?: auditlogWhereInput
  }

  /**
   * auditlog.clinic
   */
  export type auditlog$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic
     */
    select?: clinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicInclude<ExtArgs> | null
    where?: clinicWhereInput
  }

  /**
   * auditlog.user
   */
  export type auditlog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * auditlog without action
   */
  export type auditlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
  }


  /**
   * Model clinic
   */

  export type AggregateClinic = {
    _count: ClinicCountAggregateOutputType | null
    _avg: ClinicAvgAggregateOutputType | null
    _sum: ClinicSumAggregateOutputType | null
    _min: ClinicMinAggregateOutputType | null
    _max: ClinicMaxAggregateOutputType | null
  }

  export type ClinicAvgAggregateOutputType = {
    id: number | null
  }

  export type ClinicSumAggregateOutputType = {
    id: number | null
  }

  export type ClinicMinAggregateOutputType = {
    id: number | null
    name: string | null
    subdomain: string | null
    location: string | null
    contact: string | null
    email: string | null
    logo: string | null
    status: string | null
    modules: string | null
    bookingConfig: string | null
    createdDate: Date | null
    updatedAt: Date | null
  }

  export type ClinicMaxAggregateOutputType = {
    id: number | null
    name: string | null
    subdomain: string | null
    location: string | null
    contact: string | null
    email: string | null
    logo: string | null
    status: string | null
    modules: string | null
    bookingConfig: string | null
    createdDate: Date | null
    updatedAt: Date | null
  }

  export type ClinicCountAggregateOutputType = {
    id: number
    name: number
    subdomain: number
    location: number
    contact: number
    email: number
    logo: number
    status: number
    modules: number
    bookingConfig: number
    createdDate: number
    updatedAt: number
    _all: number
  }


  export type ClinicAvgAggregateInputType = {
    id?: true
  }

  export type ClinicSumAggregateInputType = {
    id?: true
  }

  export type ClinicMinAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    location?: true
    contact?: true
    email?: true
    logo?: true
    status?: true
    modules?: true
    bookingConfig?: true
    createdDate?: true
    updatedAt?: true
  }

  export type ClinicMaxAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    location?: true
    contact?: true
    email?: true
    logo?: true
    status?: true
    modules?: true
    bookingConfig?: true
    createdDate?: true
    updatedAt?: true
  }

  export type ClinicCountAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    location?: true
    contact?: true
    email?: true
    logo?: true
    status?: true
    modules?: true
    bookingConfig?: true
    createdDate?: true
    updatedAt?: true
    _all?: true
  }

  export type ClinicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clinic to aggregate.
     */
    where?: clinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinics to fetch.
     */
    orderBy?: clinicOrderByWithRelationInput | clinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clinics
    **/
    _count?: true | ClinicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClinicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClinicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicMaxAggregateInputType
  }

  export type GetClinicAggregateType<T extends ClinicAggregateArgs> = {
        [P in keyof T & keyof AggregateClinic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinic[P]>
      : GetScalarType<T[P], AggregateClinic[P]>
  }




  export type clinicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clinicWhereInput
    orderBy?: clinicOrderByWithAggregationInput | clinicOrderByWithAggregationInput[]
    by: ClinicScalarFieldEnum[] | ClinicScalarFieldEnum
    having?: clinicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicCountAggregateInputType | true
    _avg?: ClinicAvgAggregateInputType
    _sum?: ClinicSumAggregateInputType
    _min?: ClinicMinAggregateInputType
    _max?: ClinicMaxAggregateInputType
  }

  export type ClinicGroupByOutputType = {
    id: number
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo: string | null
    status: string
    modules: string | null
    bookingConfig: string | null
    createdDate: Date
    updatedAt: Date
    _count: ClinicCountAggregateOutputType | null
    _avg: ClinicAvgAggregateOutputType | null
    _sum: ClinicSumAggregateOutputType | null
    _min: ClinicMinAggregateOutputType | null
    _max: ClinicMaxAggregateOutputType | null
  }

  type GetClinicGroupByPayload<T extends clinicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicGroupByOutputType[P]>
        }
      >
    >


  export type clinicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    location?: boolean
    contact?: boolean
    email?: boolean
    logo?: boolean
    status?: boolean
    modules?: boolean
    bookingConfig?: boolean
    createdDate?: boolean
    updatedAt?: boolean
    appointment?: boolean | clinic$appointmentArgs<ExtArgs>
    auditlog?: boolean | clinic$auditlogArgs<ExtArgs>
    clinicstaff?: boolean | clinic$clinicstaffArgs<ExtArgs>
    department?: boolean | clinic$departmentArgs<ExtArgs>
    formtemplate?: boolean | clinic$formtemplateArgs<ExtArgs>
    invoice?: boolean | clinic$invoiceArgs<ExtArgs>
    medicalrecord?: boolean | clinic$medicalrecordArgs<ExtArgs>
    notification?: boolean | clinic$notificationArgs<ExtArgs>
    patient?: boolean | clinic$patientArgs<ExtArgs>
    formresponse?: boolean | clinic$formresponseArgs<ExtArgs>
    _count?: boolean | ClinicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinic"]>


  export type clinicSelectScalar = {
    id?: boolean
    name?: boolean
    subdomain?: boolean
    location?: boolean
    contact?: boolean
    email?: boolean
    logo?: boolean
    status?: boolean
    modules?: boolean
    bookingConfig?: boolean
    createdDate?: boolean
    updatedAt?: boolean
  }

  export type clinicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | clinic$appointmentArgs<ExtArgs>
    auditlog?: boolean | clinic$auditlogArgs<ExtArgs>
    clinicstaff?: boolean | clinic$clinicstaffArgs<ExtArgs>
    department?: boolean | clinic$departmentArgs<ExtArgs>
    formtemplate?: boolean | clinic$formtemplateArgs<ExtArgs>
    invoice?: boolean | clinic$invoiceArgs<ExtArgs>
    medicalrecord?: boolean | clinic$medicalrecordArgs<ExtArgs>
    notification?: boolean | clinic$notificationArgs<ExtArgs>
    patient?: boolean | clinic$patientArgs<ExtArgs>
    formresponse?: boolean | clinic$formresponseArgs<ExtArgs>
    _count?: boolean | ClinicCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $clinicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clinic"
    objects: {
      appointment: Prisma.$appointmentPayload<ExtArgs>[]
      auditlog: Prisma.$auditlogPayload<ExtArgs>[]
      clinicstaff: Prisma.$clinicstaffPayload<ExtArgs>[]
      department: Prisma.$departmentPayload<ExtArgs>[]
      formtemplate: Prisma.$formtemplatePayload<ExtArgs>[]
      invoice: Prisma.$invoicePayload<ExtArgs>[]
      medicalrecord: Prisma.$medicalrecordPayload<ExtArgs>[]
      notification: Prisma.$notificationPayload<ExtArgs>[]
      patient: Prisma.$patientPayload<ExtArgs>[]
      formresponse: Prisma.$formresponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      subdomain: string
      location: string
      contact: string
      email: string
      logo: string | null
      status: string
      modules: string | null
      bookingConfig: string | null
      createdDate: Date
      updatedAt: Date
    }, ExtArgs["result"]["clinic"]>
    composites: {}
  }

  type clinicGetPayload<S extends boolean | null | undefined | clinicDefaultArgs> = $Result.GetResult<Prisma.$clinicPayload, S>

  type clinicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<clinicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClinicCountAggregateInputType | true
    }

  export interface clinicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clinic'], meta: { name: 'clinic' } }
    /**
     * Find zero or one Clinic that matches the filter.
     * @param {clinicFindUniqueArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clinicFindUniqueArgs>(args: SelectSubset<T, clinicFindUniqueArgs<ExtArgs>>): Prisma__clinicClient<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Clinic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {clinicFindUniqueOrThrowArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clinicFindUniqueOrThrowArgs>(args: SelectSubset<T, clinicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clinicClient<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Clinic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinicFindFirstArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clinicFindFirstArgs>(args?: SelectSubset<T, clinicFindFirstArgs<ExtArgs>>): Prisma__clinicClient<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Clinic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinicFindFirstOrThrowArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clinicFindFirstOrThrowArgs>(args?: SelectSubset<T, clinicFindFirstOrThrowArgs<ExtArgs>>): Prisma__clinicClient<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clinics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clinics
     * const clinics = await prisma.clinic.findMany()
     * 
     * // Get first 10 Clinics
     * const clinics = await prisma.clinic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicWithIdOnly = await prisma.clinic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends clinicFindManyArgs>(args?: SelectSubset<T, clinicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Clinic.
     * @param {clinicCreateArgs} args - Arguments to create a Clinic.
     * @example
     * // Create one Clinic
     * const Clinic = await prisma.clinic.create({
     *   data: {
     *     // ... data to create a Clinic
     *   }
     * })
     * 
     */
    create<T extends clinicCreateArgs>(args: SelectSubset<T, clinicCreateArgs<ExtArgs>>): Prisma__clinicClient<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clinics.
     * @param {clinicCreateManyArgs} args - Arguments to create many Clinics.
     * @example
     * // Create many Clinics
     * const clinic = await prisma.clinic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clinicCreateManyArgs>(args?: SelectSubset<T, clinicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Clinic.
     * @param {clinicDeleteArgs} args - Arguments to delete one Clinic.
     * @example
     * // Delete one Clinic
     * const Clinic = await prisma.clinic.delete({
     *   where: {
     *     // ... filter to delete one Clinic
     *   }
     * })
     * 
     */
    delete<T extends clinicDeleteArgs>(args: SelectSubset<T, clinicDeleteArgs<ExtArgs>>): Prisma__clinicClient<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Clinic.
     * @param {clinicUpdateArgs} args - Arguments to update one Clinic.
     * @example
     * // Update one Clinic
     * const clinic = await prisma.clinic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clinicUpdateArgs>(args: SelectSubset<T, clinicUpdateArgs<ExtArgs>>): Prisma__clinicClient<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clinics.
     * @param {clinicDeleteManyArgs} args - Arguments to filter Clinics to delete.
     * @example
     * // Delete a few Clinics
     * const { count } = await prisma.clinic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clinicDeleteManyArgs>(args?: SelectSubset<T, clinicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clinics
     * const clinic = await prisma.clinic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clinicUpdateManyArgs>(args: SelectSubset<T, clinicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clinic.
     * @param {clinicUpsertArgs} args - Arguments to update or create a Clinic.
     * @example
     * // Update or create a Clinic
     * const clinic = await prisma.clinic.upsert({
     *   create: {
     *     // ... data to create a Clinic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clinic we want to update
     *   }
     * })
     */
    upsert<T extends clinicUpsertArgs>(args: SelectSubset<T, clinicUpsertArgs<ExtArgs>>): Prisma__clinicClient<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinicCountArgs} args - Arguments to filter Clinics to count.
     * @example
     * // Count the number of Clinics
     * const count = await prisma.clinic.count({
     *   where: {
     *     // ... the filter for the Clinics we want to count
     *   }
     * })
    **/
    count<T extends clinicCountArgs>(
      args?: Subset<T, clinicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicAggregateArgs>(args: Subset<T, ClinicAggregateArgs>): Prisma.PrismaPromise<GetClinicAggregateType<T>>

    /**
     * Group by Clinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clinicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clinicGroupByArgs['orderBy'] }
        : { orderBy?: clinicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clinicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clinic model
   */
  readonly fields: clinicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clinic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clinicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointment<T extends clinic$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, clinic$appointmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, "findMany"> | Null>
    auditlog<T extends clinic$auditlogArgs<ExtArgs> = {}>(args?: Subset<T, clinic$auditlogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findMany"> | Null>
    clinicstaff<T extends clinic$clinicstaffArgs<ExtArgs> = {}>(args?: Subset<T, clinic$clinicstaffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clinicstaffPayload<ExtArgs>, T, "findMany"> | Null>
    department<T extends clinic$departmentArgs<ExtArgs> = {}>(args?: Subset<T, clinic$departmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findMany"> | Null>
    formtemplate<T extends clinic$formtemplateArgs<ExtArgs> = {}>(args?: Subset<T, clinic$formtemplateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formtemplatePayload<ExtArgs>, T, "findMany"> | Null>
    invoice<T extends clinic$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, clinic$invoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findMany"> | Null>
    medicalrecord<T extends clinic$medicalrecordArgs<ExtArgs> = {}>(args?: Subset<T, clinic$medicalrecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicalrecordPayload<ExtArgs>, T, "findMany"> | Null>
    notification<T extends clinic$notificationArgs<ExtArgs> = {}>(args?: Subset<T, clinic$notificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany"> | Null>
    patient<T extends clinic$patientArgs<ExtArgs> = {}>(args?: Subset<T, clinic$patientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patientPayload<ExtArgs>, T, "findMany"> | Null>
    formresponse<T extends clinic$formresponseArgs<ExtArgs> = {}>(args?: Subset<T, clinic$formresponseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formresponsePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clinic model
   */ 
  interface clinicFieldRefs {
    readonly id: FieldRef<"clinic", 'Int'>
    readonly name: FieldRef<"clinic", 'String'>
    readonly subdomain: FieldRef<"clinic", 'String'>
    readonly location: FieldRef<"clinic", 'String'>
    readonly contact: FieldRef<"clinic", 'String'>
    readonly email: FieldRef<"clinic", 'String'>
    readonly logo: FieldRef<"clinic", 'String'>
    readonly status: FieldRef<"clinic", 'String'>
    readonly modules: FieldRef<"clinic", 'String'>
    readonly bookingConfig: FieldRef<"clinic", 'String'>
    readonly createdDate: FieldRef<"clinic", 'DateTime'>
    readonly updatedAt: FieldRef<"clinic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * clinic findUnique
   */
  export type clinicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic
     */
    select?: clinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicInclude<ExtArgs> | null
    /**
     * Filter, which clinic to fetch.
     */
    where: clinicWhereUniqueInput
  }

  /**
   * clinic findUniqueOrThrow
   */
  export type clinicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic
     */
    select?: clinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicInclude<ExtArgs> | null
    /**
     * Filter, which clinic to fetch.
     */
    where: clinicWhereUniqueInput
  }

  /**
   * clinic findFirst
   */
  export type clinicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic
     */
    select?: clinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicInclude<ExtArgs> | null
    /**
     * Filter, which clinic to fetch.
     */
    where?: clinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinics to fetch.
     */
    orderBy?: clinicOrderByWithRelationInput | clinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clinics.
     */
    cursor?: clinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clinics.
     */
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * clinic findFirstOrThrow
   */
  export type clinicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic
     */
    select?: clinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicInclude<ExtArgs> | null
    /**
     * Filter, which clinic to fetch.
     */
    where?: clinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinics to fetch.
     */
    orderBy?: clinicOrderByWithRelationInput | clinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clinics.
     */
    cursor?: clinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clinics.
     */
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * clinic findMany
   */
  export type clinicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic
     */
    select?: clinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicInclude<ExtArgs> | null
    /**
     * Filter, which clinics to fetch.
     */
    where?: clinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinics to fetch.
     */
    orderBy?: clinicOrderByWithRelationInput | clinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clinics.
     */
    cursor?: clinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinics.
     */
    skip?: number
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * clinic create
   */
  export type clinicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic
     */
    select?: clinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicInclude<ExtArgs> | null
    /**
     * The data needed to create a clinic.
     */
    data: XOR<clinicCreateInput, clinicUncheckedCreateInput>
  }

  /**
   * clinic createMany
   */
  export type clinicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clinics.
     */
    data: clinicCreateManyInput | clinicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clinic update
   */
  export type clinicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic
     */
    select?: clinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicInclude<ExtArgs> | null
    /**
     * The data needed to update a clinic.
     */
    data: XOR<clinicUpdateInput, clinicUncheckedUpdateInput>
    /**
     * Choose, which clinic to update.
     */
    where: clinicWhereUniqueInput
  }

  /**
   * clinic updateMany
   */
  export type clinicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clinics.
     */
    data: XOR<clinicUpdateManyMutationInput, clinicUncheckedUpdateManyInput>
    /**
     * Filter which clinics to update
     */
    where?: clinicWhereInput
  }

  /**
   * clinic upsert
   */
  export type clinicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic
     */
    select?: clinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicInclude<ExtArgs> | null
    /**
     * The filter to search for the clinic to update in case it exists.
     */
    where: clinicWhereUniqueInput
    /**
     * In case the clinic found by the `where` argument doesn't exist, create a new clinic with this data.
     */
    create: XOR<clinicCreateInput, clinicUncheckedCreateInput>
    /**
     * In case the clinic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clinicUpdateInput, clinicUncheckedUpdateInput>
  }

  /**
   * clinic delete
   */
  export type clinicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic
     */
    select?: clinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicInclude<ExtArgs> | null
    /**
     * Filter which clinic to delete.
     */
    where: clinicWhereUniqueInput
  }

  /**
   * clinic deleteMany
   */
  export type clinicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clinics to delete
     */
    where?: clinicWhereInput
  }

  /**
   * clinic.appointment
   */
  export type clinic$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentInclude<ExtArgs> | null
    where?: appointmentWhereInput
    orderBy?: appointmentOrderByWithRelationInput | appointmentOrderByWithRelationInput[]
    cursor?: appointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * clinic.auditlog
   */
  export type clinic$auditlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    where?: auditlogWhereInput
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    cursor?: auditlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditlogScalarFieldEnum | AuditlogScalarFieldEnum[]
  }

  /**
   * clinic.clinicstaff
   */
  export type clinic$clinicstaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinicstaff
     */
    select?: clinicstaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicstaffInclude<ExtArgs> | null
    where?: clinicstaffWhereInput
    orderBy?: clinicstaffOrderByWithRelationInput | clinicstaffOrderByWithRelationInput[]
    cursor?: clinicstaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicstaffScalarFieldEnum | ClinicstaffScalarFieldEnum[]
  }

  /**
   * clinic.department
   */
  export type clinic$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    where?: departmentWhereInput
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    cursor?: departmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * clinic.formtemplate
   */
  export type clinic$formtemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formtemplate
     */
    select?: formtemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formtemplateInclude<ExtArgs> | null
    where?: formtemplateWhereInput
    orderBy?: formtemplateOrderByWithRelationInput | formtemplateOrderByWithRelationInput[]
    cursor?: formtemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormtemplateScalarFieldEnum | FormtemplateScalarFieldEnum[]
  }

  /**
   * clinic.invoice
   */
  export type clinic$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    where?: invoiceWhereInput
    orderBy?: invoiceOrderByWithRelationInput | invoiceOrderByWithRelationInput[]
    cursor?: invoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * clinic.medicalrecord
   */
  export type clinic$medicalrecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicalrecord
     */
    select?: medicalrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicalrecordInclude<ExtArgs> | null
    where?: medicalrecordWhereInput
    orderBy?: medicalrecordOrderByWithRelationInput | medicalrecordOrderByWithRelationInput[]
    cursor?: medicalrecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalrecordScalarFieldEnum | MedicalrecordScalarFieldEnum[]
  }

  /**
   * clinic.notification
   */
  export type clinic$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    cursor?: notificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * clinic.patient
   */
  export type clinic$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient
     */
    select?: patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientInclude<ExtArgs> | null
    where?: patientWhereInput
    orderBy?: patientOrderByWithRelationInput | patientOrderByWithRelationInput[]
    cursor?: patientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * clinic.formresponse
   */
  export type clinic$formresponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formresponse
     */
    select?: formresponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formresponseInclude<ExtArgs> | null
    where?: formresponseWhereInput
    orderBy?: formresponseOrderByWithRelationInput | formresponseOrderByWithRelationInput[]
    cursor?: formresponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormresponseScalarFieldEnum | FormresponseScalarFieldEnum[]
  }

  /**
   * clinic without action
   */
  export type clinicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic
     */
    select?: clinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicInclude<ExtArgs> | null
  }


  /**
   * Model clinicstaff
   */

  export type AggregateClinicstaff = {
    _count: ClinicstaffCountAggregateOutputType | null
    _avg: ClinicstaffAvgAggregateOutputType | null
    _sum: ClinicstaffSumAggregateOutputType | null
    _min: ClinicstaffMinAggregateOutputType | null
    _max: ClinicstaffMaxAggregateOutputType | null
  }

  export type ClinicstaffAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    clinicId: number | null
  }

  export type ClinicstaffSumAggregateOutputType = {
    id: number | null
    userId: number | null
    clinicId: number | null
  }

  export type ClinicstaffMinAggregateOutputType = {
    id: number | null
    userId: number | null
    clinicId: number | null
    role: $Enums.clinicstaff_role | null
    createdAt: Date | null
    department: string | null
    specialty: string | null
  }

  export type ClinicstaffMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    clinicId: number | null
    role: $Enums.clinicstaff_role | null
    createdAt: Date | null
    department: string | null
    specialty: string | null
  }

  export type ClinicstaffCountAggregateOutputType = {
    id: number
    userId: number
    clinicId: number
    role: number
    createdAt: number
    department: number
    specialty: number
    _all: number
  }


  export type ClinicstaffAvgAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
  }

  export type ClinicstaffSumAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
  }

  export type ClinicstaffMinAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
    role?: true
    createdAt?: true
    department?: true
    specialty?: true
  }

  export type ClinicstaffMaxAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
    role?: true
    createdAt?: true
    department?: true
    specialty?: true
  }

  export type ClinicstaffCountAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
    role?: true
    createdAt?: true
    department?: true
    specialty?: true
    _all?: true
  }

  export type ClinicstaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clinicstaff to aggregate.
     */
    where?: clinicstaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinicstaffs to fetch.
     */
    orderBy?: clinicstaffOrderByWithRelationInput | clinicstaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clinicstaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinicstaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinicstaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clinicstaffs
    **/
    _count?: true | ClinicstaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClinicstaffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClinicstaffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicstaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicstaffMaxAggregateInputType
  }

  export type GetClinicstaffAggregateType<T extends ClinicstaffAggregateArgs> = {
        [P in keyof T & keyof AggregateClinicstaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinicstaff[P]>
      : GetScalarType<T[P], AggregateClinicstaff[P]>
  }




  export type clinicstaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clinicstaffWhereInput
    orderBy?: clinicstaffOrderByWithAggregationInput | clinicstaffOrderByWithAggregationInput[]
    by: ClinicstaffScalarFieldEnum[] | ClinicstaffScalarFieldEnum
    having?: clinicstaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicstaffCountAggregateInputType | true
    _avg?: ClinicstaffAvgAggregateInputType
    _sum?: ClinicstaffSumAggregateInputType
    _min?: ClinicstaffMinAggregateInputType
    _max?: ClinicstaffMaxAggregateInputType
  }

  export type ClinicstaffGroupByOutputType = {
    id: number
    userId: number
    clinicId: number
    role: $Enums.clinicstaff_role
    createdAt: Date
    department: string | null
    specialty: string | null
    _count: ClinicstaffCountAggregateOutputType | null
    _avg: ClinicstaffAvgAggregateOutputType | null
    _sum: ClinicstaffSumAggregateOutputType | null
    _min: ClinicstaffMinAggregateOutputType | null
    _max: ClinicstaffMaxAggregateOutputType | null
  }

  type GetClinicstaffGroupByPayload<T extends clinicstaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicstaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicstaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicstaffGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicstaffGroupByOutputType[P]>
        }
      >
    >


  export type clinicstaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    clinicId?: boolean
    role?: boolean
    createdAt?: boolean
    department?: boolean
    specialty?: boolean
    clinic?: boolean | clinicDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicstaff"]>


  export type clinicstaffSelectScalar = {
    id?: boolean
    userId?: boolean
    clinicId?: boolean
    role?: boolean
    createdAt?: boolean
    department?: boolean
    specialty?: boolean
  }

  export type clinicstaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | clinicDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $clinicstaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clinicstaff"
    objects: {
      clinic: Prisma.$clinicPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      clinicId: number
      role: $Enums.clinicstaff_role
      createdAt: Date
      department: string | null
      specialty: string | null
    }, ExtArgs["result"]["clinicstaff"]>
    composites: {}
  }

  type clinicstaffGetPayload<S extends boolean | null | undefined | clinicstaffDefaultArgs> = $Result.GetResult<Prisma.$clinicstaffPayload, S>

  type clinicstaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<clinicstaffFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClinicstaffCountAggregateInputType | true
    }

  export interface clinicstaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clinicstaff'], meta: { name: 'clinicstaff' } }
    /**
     * Find zero or one Clinicstaff that matches the filter.
     * @param {clinicstaffFindUniqueArgs} args - Arguments to find a Clinicstaff
     * @example
     * // Get one Clinicstaff
     * const clinicstaff = await prisma.clinicstaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clinicstaffFindUniqueArgs>(args: SelectSubset<T, clinicstaffFindUniqueArgs<ExtArgs>>): Prisma__clinicstaffClient<$Result.GetResult<Prisma.$clinicstaffPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Clinicstaff that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {clinicstaffFindUniqueOrThrowArgs} args - Arguments to find a Clinicstaff
     * @example
     * // Get one Clinicstaff
     * const clinicstaff = await prisma.clinicstaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clinicstaffFindUniqueOrThrowArgs>(args: SelectSubset<T, clinicstaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clinicstaffClient<$Result.GetResult<Prisma.$clinicstaffPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Clinicstaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinicstaffFindFirstArgs} args - Arguments to find a Clinicstaff
     * @example
     * // Get one Clinicstaff
     * const clinicstaff = await prisma.clinicstaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clinicstaffFindFirstArgs>(args?: SelectSubset<T, clinicstaffFindFirstArgs<ExtArgs>>): Prisma__clinicstaffClient<$Result.GetResult<Prisma.$clinicstaffPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Clinicstaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinicstaffFindFirstOrThrowArgs} args - Arguments to find a Clinicstaff
     * @example
     * // Get one Clinicstaff
     * const clinicstaff = await prisma.clinicstaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clinicstaffFindFirstOrThrowArgs>(args?: SelectSubset<T, clinicstaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__clinicstaffClient<$Result.GetResult<Prisma.$clinicstaffPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clinicstaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinicstaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clinicstaffs
     * const clinicstaffs = await prisma.clinicstaff.findMany()
     * 
     * // Get first 10 Clinicstaffs
     * const clinicstaffs = await prisma.clinicstaff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicstaffWithIdOnly = await prisma.clinicstaff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends clinicstaffFindManyArgs>(args?: SelectSubset<T, clinicstaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clinicstaffPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Clinicstaff.
     * @param {clinicstaffCreateArgs} args - Arguments to create a Clinicstaff.
     * @example
     * // Create one Clinicstaff
     * const Clinicstaff = await prisma.clinicstaff.create({
     *   data: {
     *     // ... data to create a Clinicstaff
     *   }
     * })
     * 
     */
    create<T extends clinicstaffCreateArgs>(args: SelectSubset<T, clinicstaffCreateArgs<ExtArgs>>): Prisma__clinicstaffClient<$Result.GetResult<Prisma.$clinicstaffPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clinicstaffs.
     * @param {clinicstaffCreateManyArgs} args - Arguments to create many Clinicstaffs.
     * @example
     * // Create many Clinicstaffs
     * const clinicstaff = await prisma.clinicstaff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clinicstaffCreateManyArgs>(args?: SelectSubset<T, clinicstaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Clinicstaff.
     * @param {clinicstaffDeleteArgs} args - Arguments to delete one Clinicstaff.
     * @example
     * // Delete one Clinicstaff
     * const Clinicstaff = await prisma.clinicstaff.delete({
     *   where: {
     *     // ... filter to delete one Clinicstaff
     *   }
     * })
     * 
     */
    delete<T extends clinicstaffDeleteArgs>(args: SelectSubset<T, clinicstaffDeleteArgs<ExtArgs>>): Prisma__clinicstaffClient<$Result.GetResult<Prisma.$clinicstaffPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Clinicstaff.
     * @param {clinicstaffUpdateArgs} args - Arguments to update one Clinicstaff.
     * @example
     * // Update one Clinicstaff
     * const clinicstaff = await prisma.clinicstaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clinicstaffUpdateArgs>(args: SelectSubset<T, clinicstaffUpdateArgs<ExtArgs>>): Prisma__clinicstaffClient<$Result.GetResult<Prisma.$clinicstaffPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clinicstaffs.
     * @param {clinicstaffDeleteManyArgs} args - Arguments to filter Clinicstaffs to delete.
     * @example
     * // Delete a few Clinicstaffs
     * const { count } = await prisma.clinicstaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clinicstaffDeleteManyArgs>(args?: SelectSubset<T, clinicstaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinicstaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinicstaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clinicstaffs
     * const clinicstaff = await prisma.clinicstaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clinicstaffUpdateManyArgs>(args: SelectSubset<T, clinicstaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clinicstaff.
     * @param {clinicstaffUpsertArgs} args - Arguments to update or create a Clinicstaff.
     * @example
     * // Update or create a Clinicstaff
     * const clinicstaff = await prisma.clinicstaff.upsert({
     *   create: {
     *     // ... data to create a Clinicstaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clinicstaff we want to update
     *   }
     * })
     */
    upsert<T extends clinicstaffUpsertArgs>(args: SelectSubset<T, clinicstaffUpsertArgs<ExtArgs>>): Prisma__clinicstaffClient<$Result.GetResult<Prisma.$clinicstaffPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clinicstaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinicstaffCountArgs} args - Arguments to filter Clinicstaffs to count.
     * @example
     * // Count the number of Clinicstaffs
     * const count = await prisma.clinicstaff.count({
     *   where: {
     *     // ... the filter for the Clinicstaffs we want to count
     *   }
     * })
    **/
    count<T extends clinicstaffCountArgs>(
      args?: Subset<T, clinicstaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicstaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clinicstaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicstaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicstaffAggregateArgs>(args: Subset<T, ClinicstaffAggregateArgs>): Prisma.PrismaPromise<GetClinicstaffAggregateType<T>>

    /**
     * Group by Clinicstaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clinicstaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clinicstaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clinicstaffGroupByArgs['orderBy'] }
        : { orderBy?: clinicstaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clinicstaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicstaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clinicstaff model
   */
  readonly fields: clinicstaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clinicstaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clinicstaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends clinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clinicDefaultArgs<ExtArgs>>): Prisma__clinicClient<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clinicstaff model
   */ 
  interface clinicstaffFieldRefs {
    readonly id: FieldRef<"clinicstaff", 'Int'>
    readonly userId: FieldRef<"clinicstaff", 'Int'>
    readonly clinicId: FieldRef<"clinicstaff", 'Int'>
    readonly role: FieldRef<"clinicstaff", 'clinicstaff_role'>
    readonly createdAt: FieldRef<"clinicstaff", 'DateTime'>
    readonly department: FieldRef<"clinicstaff", 'String'>
    readonly specialty: FieldRef<"clinicstaff", 'String'>
  }
    

  // Custom InputTypes
  /**
   * clinicstaff findUnique
   */
  export type clinicstaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinicstaff
     */
    select?: clinicstaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicstaffInclude<ExtArgs> | null
    /**
     * Filter, which clinicstaff to fetch.
     */
    where: clinicstaffWhereUniqueInput
  }

  /**
   * clinicstaff findUniqueOrThrow
   */
  export type clinicstaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinicstaff
     */
    select?: clinicstaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicstaffInclude<ExtArgs> | null
    /**
     * Filter, which clinicstaff to fetch.
     */
    where: clinicstaffWhereUniqueInput
  }

  /**
   * clinicstaff findFirst
   */
  export type clinicstaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinicstaff
     */
    select?: clinicstaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicstaffInclude<ExtArgs> | null
    /**
     * Filter, which clinicstaff to fetch.
     */
    where?: clinicstaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinicstaffs to fetch.
     */
    orderBy?: clinicstaffOrderByWithRelationInput | clinicstaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clinicstaffs.
     */
    cursor?: clinicstaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinicstaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinicstaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clinicstaffs.
     */
    distinct?: ClinicstaffScalarFieldEnum | ClinicstaffScalarFieldEnum[]
  }

  /**
   * clinicstaff findFirstOrThrow
   */
  export type clinicstaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinicstaff
     */
    select?: clinicstaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicstaffInclude<ExtArgs> | null
    /**
     * Filter, which clinicstaff to fetch.
     */
    where?: clinicstaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinicstaffs to fetch.
     */
    orderBy?: clinicstaffOrderByWithRelationInput | clinicstaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clinicstaffs.
     */
    cursor?: clinicstaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinicstaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinicstaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clinicstaffs.
     */
    distinct?: ClinicstaffScalarFieldEnum | ClinicstaffScalarFieldEnum[]
  }

  /**
   * clinicstaff findMany
   */
  export type clinicstaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinicstaff
     */
    select?: clinicstaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicstaffInclude<ExtArgs> | null
    /**
     * Filter, which clinicstaffs to fetch.
     */
    where?: clinicstaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clinicstaffs to fetch.
     */
    orderBy?: clinicstaffOrderByWithRelationInput | clinicstaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clinicstaffs.
     */
    cursor?: clinicstaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clinicstaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clinicstaffs.
     */
    skip?: number
    distinct?: ClinicstaffScalarFieldEnum | ClinicstaffScalarFieldEnum[]
  }

  /**
   * clinicstaff create
   */
  export type clinicstaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinicstaff
     */
    select?: clinicstaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicstaffInclude<ExtArgs> | null
    /**
     * The data needed to create a clinicstaff.
     */
    data: XOR<clinicstaffCreateInput, clinicstaffUncheckedCreateInput>
  }

  /**
   * clinicstaff createMany
   */
  export type clinicstaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clinicstaffs.
     */
    data: clinicstaffCreateManyInput | clinicstaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clinicstaff update
   */
  export type clinicstaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinicstaff
     */
    select?: clinicstaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicstaffInclude<ExtArgs> | null
    /**
     * The data needed to update a clinicstaff.
     */
    data: XOR<clinicstaffUpdateInput, clinicstaffUncheckedUpdateInput>
    /**
     * Choose, which clinicstaff to update.
     */
    where: clinicstaffWhereUniqueInput
  }

  /**
   * clinicstaff updateMany
   */
  export type clinicstaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clinicstaffs.
     */
    data: XOR<clinicstaffUpdateManyMutationInput, clinicstaffUncheckedUpdateManyInput>
    /**
     * Filter which clinicstaffs to update
     */
    where?: clinicstaffWhereInput
  }

  /**
   * clinicstaff upsert
   */
  export type clinicstaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinicstaff
     */
    select?: clinicstaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicstaffInclude<ExtArgs> | null
    /**
     * The filter to search for the clinicstaff to update in case it exists.
     */
    where: clinicstaffWhereUniqueInput
    /**
     * In case the clinicstaff found by the `where` argument doesn't exist, create a new clinicstaff with this data.
     */
    create: XOR<clinicstaffCreateInput, clinicstaffUncheckedCreateInput>
    /**
     * In case the clinicstaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clinicstaffUpdateInput, clinicstaffUncheckedUpdateInput>
  }

  /**
   * clinicstaff delete
   */
  export type clinicstaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinicstaff
     */
    select?: clinicstaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicstaffInclude<ExtArgs> | null
    /**
     * Filter which clinicstaff to delete.
     */
    where: clinicstaffWhereUniqueInput
  }

  /**
   * clinicstaff deleteMany
   */
  export type clinicstaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clinicstaffs to delete
     */
    where?: clinicstaffWhereInput
  }

  /**
   * clinicstaff without action
   */
  export type clinicstaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinicstaff
     */
    select?: clinicstaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicstaffInclude<ExtArgs> | null
  }


  /**
   * Model department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentAvgAggregateOutputType = {
    id: number | null
    clinicId: number | null
  }

  export type DepartmentSumAggregateOutputType = {
    id: number | null
    clinicId: number | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: number | null
    clinicId: number | null
    name: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: number | null
    clinicId: number | null
    name: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    clinicId: number
    name: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentAvgAggregateInputType = {
    id?: true
    clinicId?: true
  }

  export type DepartmentSumAggregateInputType = {
    id?: true
    clinicId?: true
  }

  export type DepartmentMinAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which department to aggregate.
     */
    where?: departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type departmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: departmentWhereInput
    orderBy?: departmentOrderByWithAggregationInput | departmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: departmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _avg?: DepartmentAvgAggregateInputType
    _sum?: DepartmentSumAggregateInputType
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: number
    clinicId: number
    name: string
    type: string
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends departmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type departmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | clinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>


  export type departmentSelectScalar = {
    id?: boolean
    clinicId?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type departmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | clinicDefaultArgs<ExtArgs>
  }

  export type $departmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "department"
    objects: {
      clinic: Prisma.$clinicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clinicId: number
      name: string
      type: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type departmentGetPayload<S extends boolean | null | undefined | departmentDefaultArgs> = $Result.GetResult<Prisma.$departmentPayload, S>

  type departmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<departmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface departmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['department'], meta: { name: 'department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {departmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends departmentFindUniqueArgs>(args: SelectSubset<T, departmentFindUniqueArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {departmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends departmentFindUniqueOrThrowArgs>(args: SelectSubset<T, departmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends departmentFindFirstArgs>(args?: SelectSubset<T, departmentFindFirstArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends departmentFindFirstOrThrowArgs>(args?: SelectSubset<T, departmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends departmentFindManyArgs>(args?: SelectSubset<T, departmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Department.
     * @param {departmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends departmentCreateArgs>(args: SelectSubset<T, departmentCreateArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Departments.
     * @param {departmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends departmentCreateManyArgs>(args?: SelectSubset<T, departmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Department.
     * @param {departmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends departmentDeleteArgs>(args: SelectSubset<T, departmentDeleteArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Department.
     * @param {departmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends departmentUpdateArgs>(args: SelectSubset<T, departmentUpdateArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Departments.
     * @param {departmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends departmentDeleteManyArgs>(args?: SelectSubset<T, departmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends departmentUpdateManyArgs>(args: SelectSubset<T, departmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {departmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends departmentUpsertArgs>(args: SelectSubset<T, departmentUpsertArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends departmentCountArgs>(
      args?: Subset<T, departmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends departmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: departmentGroupByArgs['orderBy'] }
        : { orderBy?: departmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, departmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the department model
   */
  readonly fields: departmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__departmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends clinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clinicDefaultArgs<ExtArgs>>): Prisma__clinicClient<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the department model
   */ 
  interface departmentFieldRefs {
    readonly id: FieldRef<"department", 'Int'>
    readonly clinicId: FieldRef<"department", 'Int'>
    readonly name: FieldRef<"department", 'String'>
    readonly type: FieldRef<"department", 'String'>
    readonly createdAt: FieldRef<"department", 'DateTime'>
    readonly updatedAt: FieldRef<"department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * department findUnique
   */
  export type departmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which department to fetch.
     */
    where: departmentWhereUniqueInput
  }

  /**
   * department findUniqueOrThrow
   */
  export type departmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which department to fetch.
     */
    where: departmentWhereUniqueInput
  }

  /**
   * department findFirst
   */
  export type departmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which department to fetch.
     */
    where?: departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departments.
     */
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * department findFirstOrThrow
   */
  export type departmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which department to fetch.
     */
    where?: departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departments.
     */
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * department findMany
   */
  export type departmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where?: departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing departments.
     */
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * department create
   */
  export type departmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * The data needed to create a department.
     */
    data: XOR<departmentCreateInput, departmentUncheckedCreateInput>
  }

  /**
   * department createMany
   */
  export type departmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many departments.
     */
    data: departmentCreateManyInput | departmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * department update
   */
  export type departmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * The data needed to update a department.
     */
    data: XOR<departmentUpdateInput, departmentUncheckedUpdateInput>
    /**
     * Choose, which department to update.
     */
    where: departmentWhereUniqueInput
  }

  /**
   * department updateMany
   */
  export type departmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update departments.
     */
    data: XOR<departmentUpdateManyMutationInput, departmentUncheckedUpdateManyInput>
    /**
     * Filter which departments to update
     */
    where?: departmentWhereInput
  }

  /**
   * department upsert
   */
  export type departmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * The filter to search for the department to update in case it exists.
     */
    where: departmentWhereUniqueInput
    /**
     * In case the department found by the `where` argument doesn't exist, create a new department with this data.
     */
    create: XOR<departmentCreateInput, departmentUncheckedCreateInput>
    /**
     * In case the department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<departmentUpdateInput, departmentUncheckedUpdateInput>
  }

  /**
   * department delete
   */
  export type departmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter which department to delete.
     */
    where: departmentWhereUniqueInput
  }

  /**
   * department deleteMany
   */
  export type departmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which departments to delete
     */
    where?: departmentWhereInput
  }

  /**
   * department without action
   */
  export type departmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
  }


  /**
   * Model formtemplate
   */

  export type AggregateFormtemplate = {
    _count: FormtemplateCountAggregateOutputType | null
    _avg: FormtemplateAvgAggregateOutputType | null
    _sum: FormtemplateSumAggregateOutputType | null
    _min: FormtemplateMinAggregateOutputType | null
    _max: FormtemplateMaxAggregateOutputType | null
  }

  export type FormtemplateAvgAggregateOutputType = {
    id: number | null
    clinicId: number | null
    version: number | null
  }

  export type FormtemplateSumAggregateOutputType = {
    id: number | null
    clinicId: number | null
    version: number | null
  }

  export type FormtemplateMinAggregateOutputType = {
    id: number | null
    clinicId: number | null
    name: string | null
    specialty: string | null
    status: string | null
    version: number | null
    fields: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormtemplateMaxAggregateOutputType = {
    id: number | null
    clinicId: number | null
    name: string | null
    specialty: string | null
    status: string | null
    version: number | null
    fields: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FormtemplateCountAggregateOutputType = {
    id: number
    clinicId: number
    name: number
    specialty: number
    status: number
    version: number
    fields: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FormtemplateAvgAggregateInputType = {
    id?: true
    clinicId?: true
    version?: true
  }

  export type FormtemplateSumAggregateInputType = {
    id?: true
    clinicId?: true
    version?: true
  }

  export type FormtemplateMinAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    specialty?: true
    status?: true
    version?: true
    fields?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormtemplateMaxAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    specialty?: true
    status?: true
    version?: true
    fields?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FormtemplateCountAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    specialty?: true
    status?: true
    version?: true
    fields?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormtemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formtemplate to aggregate.
     */
    where?: formtemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formtemplates to fetch.
     */
    orderBy?: formtemplateOrderByWithRelationInput | formtemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: formtemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formtemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formtemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned formtemplates
    **/
    _count?: true | FormtemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormtemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormtemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormtemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormtemplateMaxAggregateInputType
  }

  export type GetFormtemplateAggregateType<T extends FormtemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateFormtemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormtemplate[P]>
      : GetScalarType<T[P], AggregateFormtemplate[P]>
  }




  export type formtemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formtemplateWhereInput
    orderBy?: formtemplateOrderByWithAggregationInput | formtemplateOrderByWithAggregationInput[]
    by: FormtemplateScalarFieldEnum[] | FormtemplateScalarFieldEnum
    having?: formtemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormtemplateCountAggregateInputType | true
    _avg?: FormtemplateAvgAggregateInputType
    _sum?: FormtemplateSumAggregateInputType
    _min?: FormtemplateMinAggregateInputType
    _max?: FormtemplateMaxAggregateInputType
  }

  export type FormtemplateGroupByOutputType = {
    id: number
    clinicId: number | null
    name: string
    specialty: string
    status: string
    version: number
    fields: string
    createdAt: Date
    updatedAt: Date
    _count: FormtemplateCountAggregateOutputType | null
    _avg: FormtemplateAvgAggregateOutputType | null
    _sum: FormtemplateSumAggregateOutputType | null
    _min: FormtemplateMinAggregateOutputType | null
    _max: FormtemplateMaxAggregateOutputType | null
  }

  type GetFormtemplateGroupByPayload<T extends formtemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormtemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormtemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormtemplateGroupByOutputType[P]>
            : GetScalarType<T[P], FormtemplateGroupByOutputType[P]>
        }
      >
    >


  export type formtemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    name?: boolean
    specialty?: boolean
    status?: boolean
    version?: boolean
    fields?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | formtemplate$clinicArgs<ExtArgs>
    medicalrecord?: boolean | formtemplate$medicalrecordArgs<ExtArgs>
    formresponse?: boolean | formtemplate$formresponseArgs<ExtArgs>
    _count?: boolean | FormtemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formtemplate"]>


  export type formtemplateSelectScalar = {
    id?: boolean
    clinicId?: boolean
    name?: boolean
    specialty?: boolean
    status?: boolean
    version?: boolean
    fields?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type formtemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | formtemplate$clinicArgs<ExtArgs>
    medicalrecord?: boolean | formtemplate$medicalrecordArgs<ExtArgs>
    formresponse?: boolean | formtemplate$formresponseArgs<ExtArgs>
    _count?: boolean | FormtemplateCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $formtemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "formtemplate"
    objects: {
      clinic: Prisma.$clinicPayload<ExtArgs> | null
      medicalrecord: Prisma.$medicalrecordPayload<ExtArgs>[]
      formresponse: Prisma.$formresponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clinicId: number | null
      name: string
      specialty: string
      status: string
      version: number
      fields: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["formtemplate"]>
    composites: {}
  }

  type formtemplateGetPayload<S extends boolean | null | undefined | formtemplateDefaultArgs> = $Result.GetResult<Prisma.$formtemplatePayload, S>

  type formtemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<formtemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormtemplateCountAggregateInputType | true
    }

  export interface formtemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['formtemplate'], meta: { name: 'formtemplate' } }
    /**
     * Find zero or one Formtemplate that matches the filter.
     * @param {formtemplateFindUniqueArgs} args - Arguments to find a Formtemplate
     * @example
     * // Get one Formtemplate
     * const formtemplate = await prisma.formtemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends formtemplateFindUniqueArgs>(args: SelectSubset<T, formtemplateFindUniqueArgs<ExtArgs>>): Prisma__formtemplateClient<$Result.GetResult<Prisma.$formtemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Formtemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {formtemplateFindUniqueOrThrowArgs} args - Arguments to find a Formtemplate
     * @example
     * // Get one Formtemplate
     * const formtemplate = await prisma.formtemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends formtemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, formtemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__formtemplateClient<$Result.GetResult<Prisma.$formtemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Formtemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formtemplateFindFirstArgs} args - Arguments to find a Formtemplate
     * @example
     * // Get one Formtemplate
     * const formtemplate = await prisma.formtemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends formtemplateFindFirstArgs>(args?: SelectSubset<T, formtemplateFindFirstArgs<ExtArgs>>): Prisma__formtemplateClient<$Result.GetResult<Prisma.$formtemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Formtemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formtemplateFindFirstOrThrowArgs} args - Arguments to find a Formtemplate
     * @example
     * // Get one Formtemplate
     * const formtemplate = await prisma.formtemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends formtemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, formtemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__formtemplateClient<$Result.GetResult<Prisma.$formtemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Formtemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formtemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Formtemplates
     * const formtemplates = await prisma.formtemplate.findMany()
     * 
     * // Get first 10 Formtemplates
     * const formtemplates = await prisma.formtemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formtemplateWithIdOnly = await prisma.formtemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends formtemplateFindManyArgs>(args?: SelectSubset<T, formtemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formtemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Formtemplate.
     * @param {formtemplateCreateArgs} args - Arguments to create a Formtemplate.
     * @example
     * // Create one Formtemplate
     * const Formtemplate = await prisma.formtemplate.create({
     *   data: {
     *     // ... data to create a Formtemplate
     *   }
     * })
     * 
     */
    create<T extends formtemplateCreateArgs>(args: SelectSubset<T, formtemplateCreateArgs<ExtArgs>>): Prisma__formtemplateClient<$Result.GetResult<Prisma.$formtemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Formtemplates.
     * @param {formtemplateCreateManyArgs} args - Arguments to create many Formtemplates.
     * @example
     * // Create many Formtemplates
     * const formtemplate = await prisma.formtemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends formtemplateCreateManyArgs>(args?: SelectSubset<T, formtemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Formtemplate.
     * @param {formtemplateDeleteArgs} args - Arguments to delete one Formtemplate.
     * @example
     * // Delete one Formtemplate
     * const Formtemplate = await prisma.formtemplate.delete({
     *   where: {
     *     // ... filter to delete one Formtemplate
     *   }
     * })
     * 
     */
    delete<T extends formtemplateDeleteArgs>(args: SelectSubset<T, formtemplateDeleteArgs<ExtArgs>>): Prisma__formtemplateClient<$Result.GetResult<Prisma.$formtemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Formtemplate.
     * @param {formtemplateUpdateArgs} args - Arguments to update one Formtemplate.
     * @example
     * // Update one Formtemplate
     * const formtemplate = await prisma.formtemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends formtemplateUpdateArgs>(args: SelectSubset<T, formtemplateUpdateArgs<ExtArgs>>): Prisma__formtemplateClient<$Result.GetResult<Prisma.$formtemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Formtemplates.
     * @param {formtemplateDeleteManyArgs} args - Arguments to filter Formtemplates to delete.
     * @example
     * // Delete a few Formtemplates
     * const { count } = await prisma.formtemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends formtemplateDeleteManyArgs>(args?: SelectSubset<T, formtemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Formtemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formtemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Formtemplates
     * const formtemplate = await prisma.formtemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends formtemplateUpdateManyArgs>(args: SelectSubset<T, formtemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Formtemplate.
     * @param {formtemplateUpsertArgs} args - Arguments to update or create a Formtemplate.
     * @example
     * // Update or create a Formtemplate
     * const formtemplate = await prisma.formtemplate.upsert({
     *   create: {
     *     // ... data to create a Formtemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Formtemplate we want to update
     *   }
     * })
     */
    upsert<T extends formtemplateUpsertArgs>(args: SelectSubset<T, formtemplateUpsertArgs<ExtArgs>>): Prisma__formtemplateClient<$Result.GetResult<Prisma.$formtemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Formtemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formtemplateCountArgs} args - Arguments to filter Formtemplates to count.
     * @example
     * // Count the number of Formtemplates
     * const count = await prisma.formtemplate.count({
     *   where: {
     *     // ... the filter for the Formtemplates we want to count
     *   }
     * })
    **/
    count<T extends formtemplateCountArgs>(
      args?: Subset<T, formtemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormtemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Formtemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormtemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormtemplateAggregateArgs>(args: Subset<T, FormtemplateAggregateArgs>): Prisma.PrismaPromise<GetFormtemplateAggregateType<T>>

    /**
     * Group by Formtemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formtemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends formtemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: formtemplateGroupByArgs['orderBy'] }
        : { orderBy?: formtemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, formtemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormtemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the formtemplate model
   */
  readonly fields: formtemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for formtemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__formtemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends formtemplate$clinicArgs<ExtArgs> = {}>(args?: Subset<T, formtemplate$clinicArgs<ExtArgs>>): Prisma__clinicClient<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    medicalrecord<T extends formtemplate$medicalrecordArgs<ExtArgs> = {}>(args?: Subset<T, formtemplate$medicalrecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicalrecordPayload<ExtArgs>, T, "findMany"> | Null>
    formresponse<T extends formtemplate$formresponseArgs<ExtArgs> = {}>(args?: Subset<T, formtemplate$formresponseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formresponsePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the formtemplate model
   */ 
  interface formtemplateFieldRefs {
    readonly id: FieldRef<"formtemplate", 'Int'>
    readonly clinicId: FieldRef<"formtemplate", 'Int'>
    readonly name: FieldRef<"formtemplate", 'String'>
    readonly specialty: FieldRef<"formtemplate", 'String'>
    readonly status: FieldRef<"formtemplate", 'String'>
    readonly version: FieldRef<"formtemplate", 'Int'>
    readonly fields: FieldRef<"formtemplate", 'String'>
    readonly createdAt: FieldRef<"formtemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"formtemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * formtemplate findUnique
   */
  export type formtemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formtemplate
     */
    select?: formtemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formtemplateInclude<ExtArgs> | null
    /**
     * Filter, which formtemplate to fetch.
     */
    where: formtemplateWhereUniqueInput
  }

  /**
   * formtemplate findUniqueOrThrow
   */
  export type formtemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formtemplate
     */
    select?: formtemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formtemplateInclude<ExtArgs> | null
    /**
     * Filter, which formtemplate to fetch.
     */
    where: formtemplateWhereUniqueInput
  }

  /**
   * formtemplate findFirst
   */
  export type formtemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formtemplate
     */
    select?: formtemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formtemplateInclude<ExtArgs> | null
    /**
     * Filter, which formtemplate to fetch.
     */
    where?: formtemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formtemplates to fetch.
     */
    orderBy?: formtemplateOrderByWithRelationInput | formtemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formtemplates.
     */
    cursor?: formtemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formtemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formtemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formtemplates.
     */
    distinct?: FormtemplateScalarFieldEnum | FormtemplateScalarFieldEnum[]
  }

  /**
   * formtemplate findFirstOrThrow
   */
  export type formtemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formtemplate
     */
    select?: formtemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formtemplateInclude<ExtArgs> | null
    /**
     * Filter, which formtemplate to fetch.
     */
    where?: formtemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formtemplates to fetch.
     */
    orderBy?: formtemplateOrderByWithRelationInput | formtemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formtemplates.
     */
    cursor?: formtemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formtemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formtemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formtemplates.
     */
    distinct?: FormtemplateScalarFieldEnum | FormtemplateScalarFieldEnum[]
  }

  /**
   * formtemplate findMany
   */
  export type formtemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formtemplate
     */
    select?: formtemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formtemplateInclude<ExtArgs> | null
    /**
     * Filter, which formtemplates to fetch.
     */
    where?: formtemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formtemplates to fetch.
     */
    orderBy?: formtemplateOrderByWithRelationInput | formtemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing formtemplates.
     */
    cursor?: formtemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formtemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formtemplates.
     */
    skip?: number
    distinct?: FormtemplateScalarFieldEnum | FormtemplateScalarFieldEnum[]
  }

  /**
   * formtemplate create
   */
  export type formtemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formtemplate
     */
    select?: formtemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formtemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a formtemplate.
     */
    data: XOR<formtemplateCreateInput, formtemplateUncheckedCreateInput>
  }

  /**
   * formtemplate createMany
   */
  export type formtemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many formtemplates.
     */
    data: formtemplateCreateManyInput | formtemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * formtemplate update
   */
  export type formtemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formtemplate
     */
    select?: formtemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formtemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a formtemplate.
     */
    data: XOR<formtemplateUpdateInput, formtemplateUncheckedUpdateInput>
    /**
     * Choose, which formtemplate to update.
     */
    where: formtemplateWhereUniqueInput
  }

  /**
   * formtemplate updateMany
   */
  export type formtemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update formtemplates.
     */
    data: XOR<formtemplateUpdateManyMutationInput, formtemplateUncheckedUpdateManyInput>
    /**
     * Filter which formtemplates to update
     */
    where?: formtemplateWhereInput
  }

  /**
   * formtemplate upsert
   */
  export type formtemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formtemplate
     */
    select?: formtemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formtemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the formtemplate to update in case it exists.
     */
    where: formtemplateWhereUniqueInput
    /**
     * In case the formtemplate found by the `where` argument doesn't exist, create a new formtemplate with this data.
     */
    create: XOR<formtemplateCreateInput, formtemplateUncheckedCreateInput>
    /**
     * In case the formtemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<formtemplateUpdateInput, formtemplateUncheckedUpdateInput>
  }

  /**
   * formtemplate delete
   */
  export type formtemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formtemplate
     */
    select?: formtemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formtemplateInclude<ExtArgs> | null
    /**
     * Filter which formtemplate to delete.
     */
    where: formtemplateWhereUniqueInput
  }

  /**
   * formtemplate deleteMany
   */
  export type formtemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formtemplates to delete
     */
    where?: formtemplateWhereInput
  }

  /**
   * formtemplate.clinic
   */
  export type formtemplate$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinic
     */
    select?: clinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicInclude<ExtArgs> | null
    where?: clinicWhereInput
  }

  /**
   * formtemplate.medicalrecord
   */
  export type formtemplate$medicalrecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicalrecord
     */
    select?: medicalrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicalrecordInclude<ExtArgs> | null
    where?: medicalrecordWhereInput
    orderBy?: medicalrecordOrderByWithRelationInput | medicalrecordOrderByWithRelationInput[]
    cursor?: medicalrecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalrecordScalarFieldEnum | MedicalrecordScalarFieldEnum[]
  }

  /**
   * formtemplate.formresponse
   */
  export type formtemplate$formresponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formresponse
     */
    select?: formresponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formresponseInclude<ExtArgs> | null
    where?: formresponseWhereInput
    orderBy?: formresponseOrderByWithRelationInput | formresponseOrderByWithRelationInput[]
    cursor?: formresponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormresponseScalarFieldEnum | FormresponseScalarFieldEnum[]
  }

  /**
   * formtemplate without action
   */
  export type formtemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formtemplate
     */
    select?: formtemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formtemplateInclude<ExtArgs> | null
  }


  /**
   * Model invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    clinicId: number | null
    patientId: number | null
    doctorId: number | null
    amount: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    clinicId: number | null
    patientId: number | null
    doctorId: number | null
    amount: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    clinicId: number | null
    patientId: number | null
    doctorId: number | null
    service: string | null
    amount: Decimal | null
    status: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    clinicId: number | null
    patientId: number | null
    doctorId: number | null
    service: string | null
    amount: Decimal | null
    status: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    clinicId: number
    patientId: number
    doctorId: number
    service: number
    amount: number
    status: number
    date: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    clinicId?: true
    patientId?: true
    doctorId?: true
    amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    clinicId?: true
    patientId?: true
    doctorId?: true
    amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    service?: true
    amount?: true
    status?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    service?: true
    amount?: true
    status?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    service?: true
    amount?: true
    status?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoice to aggregate.
     */
    where?: invoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoiceOrderByWithRelationInput | invoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type invoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoiceWhereInput
    orderBy?: invoiceOrderByWithAggregationInput | invoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: invoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    clinicId: number
    patientId: number
    doctorId: number | null
    service: string
    amount: Decimal
    status: string
    date: Date
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends invoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type invoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    doctorId?: boolean
    service?: boolean
    amount?: boolean
    status?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | clinicDefaultArgs<ExtArgs>
    patient?: boolean | patientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>


  export type invoiceSelectScalar = {
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    doctorId?: boolean
    service?: boolean
    amount?: boolean
    status?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type invoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | clinicDefaultArgs<ExtArgs>
    patient?: boolean | patientDefaultArgs<ExtArgs>
  }

  export type $invoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "invoice"
    objects: {
      clinic: Prisma.$clinicPayload<ExtArgs>
      patient: Prisma.$patientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: number
      patientId: number
      doctorId: number | null
      service: string
      amount: Prisma.Decimal
      status: string
      date: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type invoiceGetPayload<S extends boolean | null | undefined | invoiceDefaultArgs> = $Result.GetResult<Prisma.$invoicePayload, S>

  type invoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<invoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface invoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invoice'], meta: { name: 'invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {invoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends invoiceFindUniqueArgs>(args: SelectSubset<T, invoiceFindUniqueArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {invoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends invoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, invoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends invoiceFindFirstArgs>(args?: SelectSubset<T, invoiceFindFirstArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends invoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, invoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends invoiceFindManyArgs>(args?: SelectSubset<T, invoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {invoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends invoiceCreateArgs>(args: SelectSubset<T, invoiceCreateArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {invoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends invoiceCreateManyArgs>(args?: SelectSubset<T, invoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {invoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends invoiceDeleteArgs>(args: SelectSubset<T, invoiceDeleteArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {invoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends invoiceUpdateArgs>(args: SelectSubset<T, invoiceUpdateArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {invoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends invoiceDeleteManyArgs>(args?: SelectSubset<T, invoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends invoiceUpdateManyArgs>(args: SelectSubset<T, invoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {invoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends invoiceUpsertArgs>(args: SelectSubset<T, invoiceUpsertArgs<ExtArgs>>): Prisma__invoiceClient<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends invoiceCountArgs>(
      args?: Subset<T, invoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invoiceGroupByArgs['orderBy'] }
        : { orderBy?: invoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invoice model
   */
  readonly fields: invoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends clinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clinicDefaultArgs<ExtArgs>>): Prisma__clinicClient<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    patient<T extends patientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, patientDefaultArgs<ExtArgs>>): Prisma__patientClient<$Result.GetResult<Prisma.$patientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the invoice model
   */ 
  interface invoiceFieldRefs {
    readonly id: FieldRef<"invoice", 'String'>
    readonly clinicId: FieldRef<"invoice", 'Int'>
    readonly patientId: FieldRef<"invoice", 'Int'>
    readonly doctorId: FieldRef<"invoice", 'Int'>
    readonly service: FieldRef<"invoice", 'String'>
    readonly amount: FieldRef<"invoice", 'Decimal'>
    readonly status: FieldRef<"invoice", 'String'>
    readonly date: FieldRef<"invoice", 'DateTime'>
    readonly createdAt: FieldRef<"invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * invoice findUnique
   */
  export type invoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * Filter, which invoice to fetch.
     */
    where: invoiceWhereUniqueInput
  }

  /**
   * invoice findUniqueOrThrow
   */
  export type invoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * Filter, which invoice to fetch.
     */
    where: invoiceWhereUniqueInput
  }

  /**
   * invoice findFirst
   */
  export type invoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * Filter, which invoice to fetch.
     */
    where?: invoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoiceOrderByWithRelationInput | invoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoices.
     */
    cursor?: invoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * invoice findFirstOrThrow
   */
  export type invoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * Filter, which invoice to fetch.
     */
    where?: invoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoiceOrderByWithRelationInput | invoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoices.
     */
    cursor?: invoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * invoice findMany
   */
  export type invoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * Filter, which invoices to fetch.
     */
    where?: invoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoiceOrderByWithRelationInput | invoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invoices.
     */
    cursor?: invoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * invoice create
   */
  export type invoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a invoice.
     */
    data: XOR<invoiceCreateInput, invoiceUncheckedCreateInput>
  }

  /**
   * invoice createMany
   */
  export type invoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invoices.
     */
    data: invoiceCreateManyInput | invoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * invoice update
   */
  export type invoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a invoice.
     */
    data: XOR<invoiceUpdateInput, invoiceUncheckedUpdateInput>
    /**
     * Choose, which invoice to update.
     */
    where: invoiceWhereUniqueInput
  }

  /**
   * invoice updateMany
   */
  export type invoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invoices.
     */
    data: XOR<invoiceUpdateManyMutationInput, invoiceUncheckedUpdateManyInput>
    /**
     * Filter which invoices to update
     */
    where?: invoiceWhereInput
  }

  /**
   * invoice upsert
   */
  export type invoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the invoice to update in case it exists.
     */
    where: invoiceWhereUniqueInput
    /**
     * In case the invoice found by the `where` argument doesn't exist, create a new invoice with this data.
     */
    create: XOR<invoiceCreateInput, invoiceUncheckedCreateInput>
    /**
     * In case the invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invoiceUpdateInput, invoiceUncheckedUpdateInput>
  }

  /**
   * invoice delete
   */
  export type invoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    /**
     * Filter which invoice to delete.
     */
    where: invoiceWhereUniqueInput
  }

  /**
   * invoice deleteMany
   */
  export type invoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoices to delete
     */
    where?: invoiceWhereInput
  }

  /**
   * invoice without action
   */
  export type invoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
  }


  /**
   * Model medicalrecord
   */

  export type AggregateMedicalrecord = {
    _count: MedicalrecordCountAggregateOutputType | null
    _avg: MedicalrecordAvgAggregateOutputType | null
    _sum: MedicalrecordSumAggregateOutputType | null
    _min: MedicalrecordMinAggregateOutputType | null
    _max: MedicalrecordMaxAggregateOutputType | null
  }

  export type MedicalrecordAvgAggregateOutputType = {
    id: number | null
    clinicId: number | null
    patientId: number | null
    doctorId: number | null
    templateId: number | null
  }

  export type MedicalrecordSumAggregateOutputType = {
    id: number | null
    clinicId: number | null
    patientId: number | null
    doctorId: number | null
    templateId: number | null
  }

  export type MedicalrecordMinAggregateOutputType = {
    id: number | null
    clinicId: number | null
    patientId: number | null
    doctorId: number | null
    templateId: number | null
    visitDate: Date | null
    type: string | null
    data: string | null
    isClosed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalrecordMaxAggregateOutputType = {
    id: number | null
    clinicId: number | null
    patientId: number | null
    doctorId: number | null
    templateId: number | null
    visitDate: Date | null
    type: string | null
    data: string | null
    isClosed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalrecordCountAggregateOutputType = {
    id: number
    clinicId: number
    patientId: number
    doctorId: number
    templateId: number
    visitDate: number
    type: number
    data: number
    isClosed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicalrecordAvgAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    templateId?: true
  }

  export type MedicalrecordSumAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    templateId?: true
  }

  export type MedicalrecordMinAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    templateId?: true
    visitDate?: true
    type?: true
    data?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalrecordMaxAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    templateId?: true
    visitDate?: true
    type?: true
    data?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalrecordCountAggregateInputType = {
    id?: true
    clinicId?: true
    patientId?: true
    doctorId?: true
    templateId?: true
    visitDate?: true
    type?: true
    data?: true
    isClosed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicalrecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medicalrecord to aggregate.
     */
    where?: medicalrecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicalrecords to fetch.
     */
    orderBy?: medicalrecordOrderByWithRelationInput | medicalrecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: medicalrecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicalrecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicalrecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned medicalrecords
    **/
    _count?: true | MedicalrecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicalrecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicalrecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalrecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalrecordMaxAggregateInputType
  }

  export type GetMedicalrecordAggregateType<T extends MedicalrecordAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalrecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalrecord[P]>
      : GetScalarType<T[P], AggregateMedicalrecord[P]>
  }




  export type medicalrecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medicalrecordWhereInput
    orderBy?: medicalrecordOrderByWithAggregationInput | medicalrecordOrderByWithAggregationInput[]
    by: MedicalrecordScalarFieldEnum[] | MedicalrecordScalarFieldEnum
    having?: medicalrecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalrecordCountAggregateInputType | true
    _avg?: MedicalrecordAvgAggregateInputType
    _sum?: MedicalrecordSumAggregateInputType
    _min?: MedicalrecordMinAggregateInputType
    _max?: MedicalrecordMaxAggregateInputType
  }

  export type MedicalrecordGroupByOutputType = {
    id: number
    clinicId: number
    patientId: number
    doctorId: number
    templateId: number | null
    visitDate: Date
    type: string
    data: string
    isClosed: boolean
    createdAt: Date
    updatedAt: Date
    _count: MedicalrecordCountAggregateOutputType | null
    _avg: MedicalrecordAvgAggregateOutputType | null
    _sum: MedicalrecordSumAggregateOutputType | null
    _min: MedicalrecordMinAggregateOutputType | null
    _max: MedicalrecordMaxAggregateOutputType | null
  }

  type GetMedicalrecordGroupByPayload<T extends medicalrecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalrecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalrecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalrecordGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalrecordGroupByOutputType[P]>
        }
      >
    >


  export type medicalrecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    doctorId?: boolean
    templateId?: boolean
    visitDate?: boolean
    type?: boolean
    data?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | clinicDefaultArgs<ExtArgs>
    patient?: boolean | patientDefaultArgs<ExtArgs>
    formtemplate?: boolean | medicalrecord$formtemplateArgs<ExtArgs>
  }, ExtArgs["result"]["medicalrecord"]>


  export type medicalrecordSelectScalar = {
    id?: boolean
    clinicId?: boolean
    patientId?: boolean
    doctorId?: boolean
    templateId?: boolean
    visitDate?: boolean
    type?: boolean
    data?: boolean
    isClosed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type medicalrecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | clinicDefaultArgs<ExtArgs>
    patient?: boolean | patientDefaultArgs<ExtArgs>
    formtemplate?: boolean | medicalrecord$formtemplateArgs<ExtArgs>
  }

  export type $medicalrecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "medicalrecord"
    objects: {
      clinic: Prisma.$clinicPayload<ExtArgs>
      patient: Prisma.$patientPayload<ExtArgs>
      formtemplate: Prisma.$formtemplatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clinicId: number
      patientId: number
      doctorId: number
      templateId: number | null
      visitDate: Date
      type: string
      data: string
      isClosed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicalrecord"]>
    composites: {}
  }

  type medicalrecordGetPayload<S extends boolean | null | undefined | medicalrecordDefaultArgs> = $Result.GetResult<Prisma.$medicalrecordPayload, S>

  type medicalrecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<medicalrecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MedicalrecordCountAggregateInputType | true
    }

  export interface medicalrecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['medicalrecord'], meta: { name: 'medicalrecord' } }
    /**
     * Find zero or one Medicalrecord that matches the filter.
     * @param {medicalrecordFindUniqueArgs} args - Arguments to find a Medicalrecord
     * @example
     * // Get one Medicalrecord
     * const medicalrecord = await prisma.medicalrecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends medicalrecordFindUniqueArgs>(args: SelectSubset<T, medicalrecordFindUniqueArgs<ExtArgs>>): Prisma__medicalrecordClient<$Result.GetResult<Prisma.$medicalrecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Medicalrecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {medicalrecordFindUniqueOrThrowArgs} args - Arguments to find a Medicalrecord
     * @example
     * // Get one Medicalrecord
     * const medicalrecord = await prisma.medicalrecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends medicalrecordFindUniqueOrThrowArgs>(args: SelectSubset<T, medicalrecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__medicalrecordClient<$Result.GetResult<Prisma.$medicalrecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Medicalrecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicalrecordFindFirstArgs} args - Arguments to find a Medicalrecord
     * @example
     * // Get one Medicalrecord
     * const medicalrecord = await prisma.medicalrecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends medicalrecordFindFirstArgs>(args?: SelectSubset<T, medicalrecordFindFirstArgs<ExtArgs>>): Prisma__medicalrecordClient<$Result.GetResult<Prisma.$medicalrecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Medicalrecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicalrecordFindFirstOrThrowArgs} args - Arguments to find a Medicalrecord
     * @example
     * // Get one Medicalrecord
     * const medicalrecord = await prisma.medicalrecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends medicalrecordFindFirstOrThrowArgs>(args?: SelectSubset<T, medicalrecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__medicalrecordClient<$Result.GetResult<Prisma.$medicalrecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Medicalrecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicalrecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medicalrecords
     * const medicalrecords = await prisma.medicalrecord.findMany()
     * 
     * // Get first 10 Medicalrecords
     * const medicalrecords = await prisma.medicalrecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalrecordWithIdOnly = await prisma.medicalrecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends medicalrecordFindManyArgs>(args?: SelectSubset<T, medicalrecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicalrecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Medicalrecord.
     * @param {medicalrecordCreateArgs} args - Arguments to create a Medicalrecord.
     * @example
     * // Create one Medicalrecord
     * const Medicalrecord = await prisma.medicalrecord.create({
     *   data: {
     *     // ... data to create a Medicalrecord
     *   }
     * })
     * 
     */
    create<T extends medicalrecordCreateArgs>(args: SelectSubset<T, medicalrecordCreateArgs<ExtArgs>>): Prisma__medicalrecordClient<$Result.GetResult<Prisma.$medicalrecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Medicalrecords.
     * @param {medicalrecordCreateManyArgs} args - Arguments to create many Medicalrecords.
     * @example
     * // Create many Medicalrecords
     * const medicalrecord = await prisma.medicalrecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends medicalrecordCreateManyArgs>(args?: SelectSubset<T, medicalrecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Medicalrecord.
     * @param {medicalrecordDeleteArgs} args - Arguments to delete one Medicalrecord.
     * @example
     * // Delete one Medicalrecord
     * const Medicalrecord = await prisma.medicalrecord.delete({
     *   where: {
     *     // ... filter to delete one Medicalrecord
     *   }
     * })
     * 
     */
    delete<T extends medicalrecordDeleteArgs>(args: SelectSubset<T, medicalrecordDeleteArgs<ExtArgs>>): Prisma__medicalrecordClient<$Result.GetResult<Prisma.$medicalrecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Medicalrecord.
     * @param {medicalrecordUpdateArgs} args - Arguments to update one Medicalrecord.
     * @example
     * // Update one Medicalrecord
     * const medicalrecord = await prisma.medicalrecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends medicalrecordUpdateArgs>(args: SelectSubset<T, medicalrecordUpdateArgs<ExtArgs>>): Prisma__medicalrecordClient<$Result.GetResult<Prisma.$medicalrecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Medicalrecords.
     * @param {medicalrecordDeleteManyArgs} args - Arguments to filter Medicalrecords to delete.
     * @example
     * // Delete a few Medicalrecords
     * const { count } = await prisma.medicalrecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends medicalrecordDeleteManyArgs>(args?: SelectSubset<T, medicalrecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicalrecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicalrecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medicalrecords
     * const medicalrecord = await prisma.medicalrecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends medicalrecordUpdateManyArgs>(args: SelectSubset<T, medicalrecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Medicalrecord.
     * @param {medicalrecordUpsertArgs} args - Arguments to update or create a Medicalrecord.
     * @example
     * // Update or create a Medicalrecord
     * const medicalrecord = await prisma.medicalrecord.upsert({
     *   create: {
     *     // ... data to create a Medicalrecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medicalrecord we want to update
     *   }
     * })
     */
    upsert<T extends medicalrecordUpsertArgs>(args: SelectSubset<T, medicalrecordUpsertArgs<ExtArgs>>): Prisma__medicalrecordClient<$Result.GetResult<Prisma.$medicalrecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Medicalrecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicalrecordCountArgs} args - Arguments to filter Medicalrecords to count.
     * @example
     * // Count the number of Medicalrecords
     * const count = await prisma.medicalrecord.count({
     *   where: {
     *     // ... the filter for the Medicalrecords we want to count
     *   }
     * })
    **/
    count<T extends medicalrecordCountArgs>(
      args?: Subset<T, medicalrecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalrecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medicalrecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalrecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalrecordAggregateArgs>(args: Subset<T, MedicalrecordAggregateArgs>): Prisma.PrismaPromise<GetMedicalrecordAggregateType<T>>

    /**
     * Group by Medicalrecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medicalrecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends medicalrecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: medicalrecordGroupByArgs['orderBy'] }
        : { orderBy?: medicalrecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, medicalrecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalrecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the medicalrecord model
   */
  readonly fields: medicalrecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for medicalrecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__medicalrecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends clinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clinicDefaultArgs<ExtArgs>>): Prisma__clinicClient<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    patient<T extends patientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, patientDefaultArgs<ExtArgs>>): Prisma__patientClient<$Result.GetResult<Prisma.$patientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    formtemplate<T extends medicalrecord$formtemplateArgs<ExtArgs> = {}>(args?: Subset<T, medicalrecord$formtemplateArgs<ExtArgs>>): Prisma__formtemplateClient<$Result.GetResult<Prisma.$formtemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the medicalrecord model
   */ 
  interface medicalrecordFieldRefs {
    readonly id: FieldRef<"medicalrecord", 'Int'>
    readonly clinicId: FieldRef<"medicalrecord", 'Int'>
    readonly patientId: FieldRef<"medicalrecord", 'Int'>
    readonly doctorId: FieldRef<"medicalrecord", 'Int'>
    readonly templateId: FieldRef<"medicalrecord", 'Int'>
    readonly visitDate: FieldRef<"medicalrecord", 'DateTime'>
    readonly type: FieldRef<"medicalrecord", 'String'>
    readonly data: FieldRef<"medicalrecord", 'String'>
    readonly isClosed: FieldRef<"medicalrecord", 'Boolean'>
    readonly createdAt: FieldRef<"medicalrecord", 'DateTime'>
    readonly updatedAt: FieldRef<"medicalrecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * medicalrecord findUnique
   */
  export type medicalrecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicalrecord
     */
    select?: medicalrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicalrecordInclude<ExtArgs> | null
    /**
     * Filter, which medicalrecord to fetch.
     */
    where: medicalrecordWhereUniqueInput
  }

  /**
   * medicalrecord findUniqueOrThrow
   */
  export type medicalrecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicalrecord
     */
    select?: medicalrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicalrecordInclude<ExtArgs> | null
    /**
     * Filter, which medicalrecord to fetch.
     */
    where: medicalrecordWhereUniqueInput
  }

  /**
   * medicalrecord findFirst
   */
  export type medicalrecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicalrecord
     */
    select?: medicalrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicalrecordInclude<ExtArgs> | null
    /**
     * Filter, which medicalrecord to fetch.
     */
    where?: medicalrecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicalrecords to fetch.
     */
    orderBy?: medicalrecordOrderByWithRelationInput | medicalrecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medicalrecords.
     */
    cursor?: medicalrecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicalrecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicalrecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medicalrecords.
     */
    distinct?: MedicalrecordScalarFieldEnum | MedicalrecordScalarFieldEnum[]
  }

  /**
   * medicalrecord findFirstOrThrow
   */
  export type medicalrecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicalrecord
     */
    select?: medicalrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicalrecordInclude<ExtArgs> | null
    /**
     * Filter, which medicalrecord to fetch.
     */
    where?: medicalrecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicalrecords to fetch.
     */
    orderBy?: medicalrecordOrderByWithRelationInput | medicalrecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medicalrecords.
     */
    cursor?: medicalrecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicalrecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicalrecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medicalrecords.
     */
    distinct?: MedicalrecordScalarFieldEnum | MedicalrecordScalarFieldEnum[]
  }

  /**
   * medicalrecord findMany
   */
  export type medicalrecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicalrecord
     */
    select?: medicalrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicalrecordInclude<ExtArgs> | null
    /**
     * Filter, which medicalrecords to fetch.
     */
    where?: medicalrecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medicalrecords to fetch.
     */
    orderBy?: medicalrecordOrderByWithRelationInput | medicalrecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing medicalrecords.
     */
    cursor?: medicalrecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medicalrecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medicalrecords.
     */
    skip?: number
    distinct?: MedicalrecordScalarFieldEnum | MedicalrecordScalarFieldEnum[]
  }

  /**
   * medicalrecord create
   */
  export type medicalrecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicalrecord
     */
    select?: medicalrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicalrecordInclude<ExtArgs> | null
    /**
     * The data needed to create a medicalrecord.
     */
    data: XOR<medicalrecordCreateInput, medicalrecordUncheckedCreateInput>
  }

  /**
   * medicalrecord createMany
   */
  export type medicalrecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many medicalrecords.
     */
    data: medicalrecordCreateManyInput | medicalrecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * medicalrecord update
   */
  export type medicalrecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicalrecord
     */
    select?: medicalrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicalrecordInclude<ExtArgs> | null
    /**
     * The data needed to update a medicalrecord.
     */
    data: XOR<medicalrecordUpdateInput, medicalrecordUncheckedUpdateInput>
    /**
     * Choose, which medicalrecord to update.
     */
    where: medicalrecordWhereUniqueInput
  }

  /**
   * medicalrecord updateMany
   */
  export type medicalrecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update medicalrecords.
     */
    data: XOR<medicalrecordUpdateManyMutationInput, medicalrecordUncheckedUpdateManyInput>
    /**
     * Filter which medicalrecords to update
     */
    where?: medicalrecordWhereInput
  }

  /**
   * medicalrecord upsert
   */
  export type medicalrecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicalrecord
     */
    select?: medicalrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicalrecordInclude<ExtArgs> | null
    /**
     * The filter to search for the medicalrecord to update in case it exists.
     */
    where: medicalrecordWhereUniqueInput
    /**
     * In case the medicalrecord found by the `where` argument doesn't exist, create a new medicalrecord with this data.
     */
    create: XOR<medicalrecordCreateInput, medicalrecordUncheckedCreateInput>
    /**
     * In case the medicalrecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<medicalrecordUpdateInput, medicalrecordUncheckedUpdateInput>
  }

  /**
   * medicalrecord delete
   */
  export type medicalrecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicalrecord
     */
    select?: medicalrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicalrecordInclude<ExtArgs> | null
    /**
     * Filter which medicalrecord to delete.
     */
    where: medicalrecordWhereUniqueInput
  }

  /**
   * medicalrecord deleteMany
   */
  export type medicalrecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medicalrecords to delete
     */
    where?: medicalrecordWhereInput
  }

  /**
   * medicalrecord.formtemplate
   */
  export type medicalrecord$formtemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formtemplate
     */
    select?: formtemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formtemplateInclude<ExtArgs> | null
    where?: formtemplateWhereInput
  }

  /**
   * medicalrecord without action
   */
  export type medicalrecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicalrecord
     */
    select?: medicalrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicalrecordInclude<ExtArgs> | null
  }


  /**
   * Model formresponse
   */

  export type AggregateFormresponse = {
    _count: FormresponseCountAggregateOutputType | null
    _avg: FormresponseAvgAggregateOutputType | null
    _sum: FormresponseSumAggregateOutputType | null
    _min: FormresponseMinAggregateOutputType | null
    _max: FormresponseMaxAggregateOutputType | null
  }

  export type FormresponseAvgAggregateOutputType = {
    id: number | null
    clinicId: number | null
    formId: number | null
    patientId: number | null
    doctorId: number | null
  }

  export type FormresponseSumAggregateOutputType = {
    id: number | null
    clinicId: number | null
    formId: number | null
    patientId: number | null
    doctorId: number | null
  }

  export type FormresponseMinAggregateOutputType = {
    id: number | null
    clinicId: number | null
    formId: number | null
    patientId: number | null
    doctorId: number | null
    answers: string | null
    submittedAt: Date | null
    updatedAt: Date | null
  }

  export type FormresponseMaxAggregateOutputType = {
    id: number | null
    clinicId: number | null
    formId: number | null
    patientId: number | null
    doctorId: number | null
    answers: string | null
    submittedAt: Date | null
    updatedAt: Date | null
  }

  export type FormresponseCountAggregateOutputType = {
    id: number
    clinicId: number
    formId: number
    patientId: number
    doctorId: number
    answers: number
    submittedAt: number
    updatedAt: number
    _all: number
  }


  export type FormresponseAvgAggregateInputType = {
    id?: true
    clinicId?: true
    formId?: true
    patientId?: true
    doctorId?: true
  }

  export type FormresponseSumAggregateInputType = {
    id?: true
    clinicId?: true
    formId?: true
    patientId?: true
    doctorId?: true
  }

  export type FormresponseMinAggregateInputType = {
    id?: true
    clinicId?: true
    formId?: true
    patientId?: true
    doctorId?: true
    answers?: true
    submittedAt?: true
    updatedAt?: true
  }

  export type FormresponseMaxAggregateInputType = {
    id?: true
    clinicId?: true
    formId?: true
    patientId?: true
    doctorId?: true
    answers?: true
    submittedAt?: true
    updatedAt?: true
  }

  export type FormresponseCountAggregateInputType = {
    id?: true
    clinicId?: true
    formId?: true
    patientId?: true
    doctorId?: true
    answers?: true
    submittedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FormresponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formresponse to aggregate.
     */
    where?: formresponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formresponses to fetch.
     */
    orderBy?: formresponseOrderByWithRelationInput | formresponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: formresponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formresponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formresponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned formresponses
    **/
    _count?: true | FormresponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormresponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormresponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormresponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormresponseMaxAggregateInputType
  }

  export type GetFormresponseAggregateType<T extends FormresponseAggregateArgs> = {
        [P in keyof T & keyof AggregateFormresponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormresponse[P]>
      : GetScalarType<T[P], AggregateFormresponse[P]>
  }




  export type formresponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formresponseWhereInput
    orderBy?: formresponseOrderByWithAggregationInput | formresponseOrderByWithAggregationInput[]
    by: FormresponseScalarFieldEnum[] | FormresponseScalarFieldEnum
    having?: formresponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormresponseCountAggregateInputType | true
    _avg?: FormresponseAvgAggregateInputType
    _sum?: FormresponseSumAggregateInputType
    _min?: FormresponseMinAggregateInputType
    _max?: FormresponseMaxAggregateInputType
  }

  export type FormresponseGroupByOutputType = {
    id: number
    clinicId: number
    formId: number
    patientId: number
    doctorId: number
    answers: string
    submittedAt: Date
    updatedAt: Date
    _count: FormresponseCountAggregateOutputType | null
    _avg: FormresponseAvgAggregateOutputType | null
    _sum: FormresponseSumAggregateOutputType | null
    _min: FormresponseMinAggregateOutputType | null
    _max: FormresponseMaxAggregateOutputType | null
  }

  type GetFormresponseGroupByPayload<T extends formresponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormresponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormresponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormresponseGroupByOutputType[P]>
            : GetScalarType<T[P], FormresponseGroupByOutputType[P]>
        }
      >
    >


  export type formresponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    formId?: boolean
    patientId?: boolean
    doctorId?: boolean
    answers?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | clinicDefaultArgs<ExtArgs>
    formtemplate?: boolean | formtemplateDefaultArgs<ExtArgs>
    patient?: boolean | patientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formresponse"]>


  export type formresponseSelectScalar = {
    id?: boolean
    clinicId?: boolean
    formId?: boolean
    patientId?: boolean
    doctorId?: boolean
    answers?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
  }

  export type formresponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | clinicDefaultArgs<ExtArgs>
    formtemplate?: boolean | formtemplateDefaultArgs<ExtArgs>
    patient?: boolean | patientDefaultArgs<ExtArgs>
  }

  export type $formresponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "formresponse"
    objects: {
      clinic: Prisma.$clinicPayload<ExtArgs>
      formtemplate: Prisma.$formtemplatePayload<ExtArgs>
      patient: Prisma.$patientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clinicId: number
      formId: number
      patientId: number
      doctorId: number
      answers: string
      submittedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["formresponse"]>
    composites: {}
  }

  type formresponseGetPayload<S extends boolean | null | undefined | formresponseDefaultArgs> = $Result.GetResult<Prisma.$formresponsePayload, S>

  type formresponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<formresponseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FormresponseCountAggregateInputType | true
    }

  export interface formresponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['formresponse'], meta: { name: 'formresponse' } }
    /**
     * Find zero or one Formresponse that matches the filter.
     * @param {formresponseFindUniqueArgs} args - Arguments to find a Formresponse
     * @example
     * // Get one Formresponse
     * const formresponse = await prisma.formresponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends formresponseFindUniqueArgs>(args: SelectSubset<T, formresponseFindUniqueArgs<ExtArgs>>): Prisma__formresponseClient<$Result.GetResult<Prisma.$formresponsePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Formresponse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {formresponseFindUniqueOrThrowArgs} args - Arguments to find a Formresponse
     * @example
     * // Get one Formresponse
     * const formresponse = await prisma.formresponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends formresponseFindUniqueOrThrowArgs>(args: SelectSubset<T, formresponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__formresponseClient<$Result.GetResult<Prisma.$formresponsePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Formresponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formresponseFindFirstArgs} args - Arguments to find a Formresponse
     * @example
     * // Get one Formresponse
     * const formresponse = await prisma.formresponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends formresponseFindFirstArgs>(args?: SelectSubset<T, formresponseFindFirstArgs<ExtArgs>>): Prisma__formresponseClient<$Result.GetResult<Prisma.$formresponsePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Formresponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formresponseFindFirstOrThrowArgs} args - Arguments to find a Formresponse
     * @example
     * // Get one Formresponse
     * const formresponse = await prisma.formresponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends formresponseFindFirstOrThrowArgs>(args?: SelectSubset<T, formresponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__formresponseClient<$Result.GetResult<Prisma.$formresponsePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Formresponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formresponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Formresponses
     * const formresponses = await prisma.formresponse.findMany()
     * 
     * // Get first 10 Formresponses
     * const formresponses = await prisma.formresponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formresponseWithIdOnly = await prisma.formresponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends formresponseFindManyArgs>(args?: SelectSubset<T, formresponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formresponsePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Formresponse.
     * @param {formresponseCreateArgs} args - Arguments to create a Formresponse.
     * @example
     * // Create one Formresponse
     * const Formresponse = await prisma.formresponse.create({
     *   data: {
     *     // ... data to create a Formresponse
     *   }
     * })
     * 
     */
    create<T extends formresponseCreateArgs>(args: SelectSubset<T, formresponseCreateArgs<ExtArgs>>): Prisma__formresponseClient<$Result.GetResult<Prisma.$formresponsePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Formresponses.
     * @param {formresponseCreateManyArgs} args - Arguments to create many Formresponses.
     * @example
     * // Create many Formresponses
     * const formresponse = await prisma.formresponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends formresponseCreateManyArgs>(args?: SelectSubset<T, formresponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Formresponse.
     * @param {formresponseDeleteArgs} args - Arguments to delete one Formresponse.
     * @example
     * // Delete one Formresponse
     * const Formresponse = await prisma.formresponse.delete({
     *   where: {
     *     // ... filter to delete one Formresponse
     *   }
     * })
     * 
     */
    delete<T extends formresponseDeleteArgs>(args: SelectSubset<T, formresponseDeleteArgs<ExtArgs>>): Prisma__formresponseClient<$Result.GetResult<Prisma.$formresponsePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Formresponse.
     * @param {formresponseUpdateArgs} args - Arguments to update one Formresponse.
     * @example
     * // Update one Formresponse
     * const formresponse = await prisma.formresponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends formresponseUpdateArgs>(args: SelectSubset<T, formresponseUpdateArgs<ExtArgs>>): Prisma__formresponseClient<$Result.GetResult<Prisma.$formresponsePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Formresponses.
     * @param {formresponseDeleteManyArgs} args - Arguments to filter Formresponses to delete.
     * @example
     * // Delete a few Formresponses
     * const { count } = await prisma.formresponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends formresponseDeleteManyArgs>(args?: SelectSubset<T, formresponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Formresponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formresponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Formresponses
     * const formresponse = await prisma.formresponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends formresponseUpdateManyArgs>(args: SelectSubset<T, formresponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Formresponse.
     * @param {formresponseUpsertArgs} args - Arguments to update or create a Formresponse.
     * @example
     * // Update or create a Formresponse
     * const formresponse = await prisma.formresponse.upsert({
     *   create: {
     *     // ... data to create a Formresponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Formresponse we want to update
     *   }
     * })
     */
    upsert<T extends formresponseUpsertArgs>(args: SelectSubset<T, formresponseUpsertArgs<ExtArgs>>): Prisma__formresponseClient<$Result.GetResult<Prisma.$formresponsePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Formresponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formresponseCountArgs} args - Arguments to filter Formresponses to count.
     * @example
     * // Count the number of Formresponses
     * const count = await prisma.formresponse.count({
     *   where: {
     *     // ... the filter for the Formresponses we want to count
     *   }
     * })
    **/
    count<T extends formresponseCountArgs>(
      args?: Subset<T, formresponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormresponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Formresponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormresponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormresponseAggregateArgs>(args: Subset<T, FormresponseAggregateArgs>): Prisma.PrismaPromise<GetFormresponseAggregateType<T>>

    /**
     * Group by Formresponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formresponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends formresponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: formresponseGroupByArgs['orderBy'] }
        : { orderBy?: formresponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, formresponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormresponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the formresponse model
   */
  readonly fields: formresponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for formresponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__formresponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends clinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clinicDefaultArgs<ExtArgs>>): Prisma__clinicClient<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    formtemplate<T extends formtemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, formtemplateDefaultArgs<ExtArgs>>): Prisma__formtemplateClient<$Result.GetResult<Prisma.$formtemplatePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    patient<T extends patientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, patientDefaultArgs<ExtArgs>>): Prisma__patientClient<$Result.GetResult<Prisma.$patientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the formresponse model
   */ 
  interface formresponseFieldRefs {
    readonly id: FieldRef<"formresponse", 'Int'>
    readonly clinicId: FieldRef<"formresponse", 'Int'>
    readonly formId: FieldRef<"formresponse", 'Int'>
    readonly patientId: FieldRef<"formresponse", 'Int'>
    readonly doctorId: FieldRef<"formresponse", 'Int'>
    readonly answers: FieldRef<"formresponse", 'String'>
    readonly submittedAt: FieldRef<"formresponse", 'DateTime'>
    readonly updatedAt: FieldRef<"formresponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * formresponse findUnique
   */
  export type formresponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formresponse
     */
    select?: formresponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formresponseInclude<ExtArgs> | null
    /**
     * Filter, which formresponse to fetch.
     */
    where: formresponseWhereUniqueInput
  }

  /**
   * formresponse findUniqueOrThrow
   */
  export type formresponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formresponse
     */
    select?: formresponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formresponseInclude<ExtArgs> | null
    /**
     * Filter, which formresponse to fetch.
     */
    where: formresponseWhereUniqueInput
  }

  /**
   * formresponse findFirst
   */
  export type formresponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formresponse
     */
    select?: formresponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formresponseInclude<ExtArgs> | null
    /**
     * Filter, which formresponse to fetch.
     */
    where?: formresponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formresponses to fetch.
     */
    orderBy?: formresponseOrderByWithRelationInput | formresponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formresponses.
     */
    cursor?: formresponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formresponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formresponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formresponses.
     */
    distinct?: FormresponseScalarFieldEnum | FormresponseScalarFieldEnum[]
  }

  /**
   * formresponse findFirstOrThrow
   */
  export type formresponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formresponse
     */
    select?: formresponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formresponseInclude<ExtArgs> | null
    /**
     * Filter, which formresponse to fetch.
     */
    where?: formresponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formresponses to fetch.
     */
    orderBy?: formresponseOrderByWithRelationInput | formresponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formresponses.
     */
    cursor?: formresponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formresponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formresponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formresponses.
     */
    distinct?: FormresponseScalarFieldEnum | FormresponseScalarFieldEnum[]
  }

  /**
   * formresponse findMany
   */
  export type formresponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formresponse
     */
    select?: formresponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formresponseInclude<ExtArgs> | null
    /**
     * Filter, which formresponses to fetch.
     */
    where?: formresponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formresponses to fetch.
     */
    orderBy?: formresponseOrderByWithRelationInput | formresponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing formresponses.
     */
    cursor?: formresponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formresponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formresponses.
     */
    skip?: number
    distinct?: FormresponseScalarFieldEnum | FormresponseScalarFieldEnum[]
  }

  /**
   * formresponse create
   */
  export type formresponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formresponse
     */
    select?: formresponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formresponseInclude<ExtArgs> | null
    /**
     * The data needed to create a formresponse.
     */
    data: XOR<formresponseCreateInput, formresponseUncheckedCreateInput>
  }

  /**
   * formresponse createMany
   */
  export type formresponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many formresponses.
     */
    data: formresponseCreateManyInput | formresponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * formresponse update
   */
  export type formresponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formresponse
     */
    select?: formresponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formresponseInclude<ExtArgs> | null
    /**
     * The data needed to update a formresponse.
     */
    data: XOR<formresponseUpdateInput, formresponseUncheckedUpdateInput>
    /**
     * Choose, which formresponse to update.
     */
    where: formresponseWhereUniqueInput
  }

  /**
   * formresponse updateMany
   */
  export type formresponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update formresponses.
     */
    data: XOR<formresponseUpdateManyMutationInput, formresponseUncheckedUpdateManyInput>
    /**
     * Filter which formresponses to update
     */
    where?: formresponseWhereInput
  }

  /**
   * formresponse upsert
   */
  export type formresponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formresponse
     */
    select?: formresponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formresponseInclude<ExtArgs> | null
    /**
     * The filter to search for the formresponse to update in case it exists.
     */
    where: formresponseWhereUniqueInput
    /**
     * In case the formresponse found by the `where` argument doesn't exist, create a new formresponse with this data.
     */
    create: XOR<formresponseCreateInput, formresponseUncheckedCreateInput>
    /**
     * In case the formresponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<formresponseUpdateInput, formresponseUncheckedUpdateInput>
  }

  /**
   * formresponse delete
   */
  export type formresponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formresponse
     */
    select?: formresponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formresponseInclude<ExtArgs> | null
    /**
     * Filter which formresponse to delete.
     */
    where: formresponseWhereUniqueInput
  }

  /**
   * formresponse deleteMany
   */
  export type formresponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formresponses to delete
     */
    where?: formresponseWhereInput
  }

  /**
   * formresponse without action
   */
  export type formresponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formresponse
     */
    select?: formresponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formresponseInclude<ExtArgs> | null
  }


  /**
   * Model notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    clinicId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    clinicId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    clinicId: number | null
    department: string | null
    message: string | null
    status: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    clinicId: number | null
    department: string | null
    message: string | null
    status: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    clinicId: number
    department: number
    message: number
    status: number
    createdAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    clinicId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    clinicId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    clinicId?: true
    department?: true
    message?: true
    status?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    clinicId?: true
    department?: true
    message?: true
    status?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    clinicId?: true
    department?: true
    message?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notification to aggregate.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type notificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationWhereInput
    orderBy?: notificationOrderByWithAggregationInput | notificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: notificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    clinicId: number
    department: string
    message: string
    status: string
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends notificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type notificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    department?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
    clinic?: boolean | clinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>


  export type notificationSelectScalar = {
    id?: boolean
    clinicId?: boolean
    department?: boolean
    message?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type notificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | clinicDefaultArgs<ExtArgs>
  }

  export type $notificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notification"
    objects: {
      clinic: Prisma.$clinicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clinicId: number
      department: string
      message: string
      status: string
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type notificationGetPayload<S extends boolean | null | undefined | notificationDefaultArgs> = $Result.GetResult<Prisma.$notificationPayload, S>

  type notificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<notificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface notificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notification'], meta: { name: 'notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {notificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationFindUniqueArgs>(args: SelectSubset<T, notificationFindUniqueArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {notificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationFindFirstArgs>(args?: SelectSubset<T, notificationFindFirstArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationFindManyArgs>(args?: SelectSubset<T, notificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {notificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends notificationCreateArgs>(args: SelectSubset<T, notificationCreateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {notificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationCreateManyArgs>(args?: SelectSubset<T, notificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {notificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends notificationDeleteArgs>(args: SelectSubset<T, notificationDeleteArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {notificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationUpdateArgs>(args: SelectSubset<T, notificationUpdateArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {notificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationDeleteManyArgs>(args?: SelectSubset<T, notificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationUpdateManyArgs>(args: SelectSubset<T, notificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {notificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends notificationUpsertArgs>(args: SelectSubset<T, notificationUpsertArgs<ExtArgs>>): Prisma__notificationClient<$Result.GetResult<Prisma.$notificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationCountArgs>(
      args?: Subset<T, notificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationGroupByArgs['orderBy'] }
        : { orderBy?: notificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notification model
   */
  readonly fields: notificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends clinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clinicDefaultArgs<ExtArgs>>): Prisma__clinicClient<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notification model
   */ 
  interface notificationFieldRefs {
    readonly id: FieldRef<"notification", 'Int'>
    readonly clinicId: FieldRef<"notification", 'Int'>
    readonly department: FieldRef<"notification", 'String'>
    readonly message: FieldRef<"notification", 'String'>
    readonly status: FieldRef<"notification", 'String'>
    readonly createdAt: FieldRef<"notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notification findUnique
   */
  export type notificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findUniqueOrThrow
   */
  export type notificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findFirst
   */
  export type notificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findFirstOrThrow
   */
  export type notificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification findMany
   */
  export type notificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationOrderByWithRelationInput | notificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * notification create
   */
  export type notificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to create a notification.
     */
    data: XOR<notificationCreateInput, notificationUncheckedCreateInput>
  }

  /**
   * notification createMany
   */
  export type notificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationCreateManyInput | notificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notification update
   */
  export type notificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The data needed to update a notification.
     */
    data: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
    /**
     * Choose, which notification to update.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification updateMany
   */
  export type notificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationWhereInput
  }

  /**
   * notification upsert
   */
  export type notificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * The filter to search for the notification to update in case it exists.
     */
    where: notificationWhereUniqueInput
    /**
     * In case the notification found by the `where` argument doesn't exist, create a new notification with this data.
     */
    create: XOR<notificationCreateInput, notificationUncheckedCreateInput>
    /**
     * In case the notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
  }

  /**
   * notification delete
   */
  export type notificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
    /**
     * Filter which notification to delete.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification deleteMany
   */
  export type notificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationWhereInput
  }

  /**
   * notification without action
   */
  export type notificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationInclude<ExtArgs> | null
  }


  /**
   * Model patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientAvgAggregateOutputType = {
    id: number | null
    clinicId: number | null
    age: number | null
    createdYear: number | null
  }

  export type PatientSumAggregateOutputType = {
    id: number | null
    clinicId: number | null
    age: number | null
    createdYear: number | null
  }

  export type PatientMinAggregateOutputType = {
    id: number | null
    clinicId: number | null
    mrn: string | null
    name: string | null
    age: number | null
    email: string | null
    phone: string | null
    gender: string | null
    address: string | null
    medicalHistory: string | null
    allergies: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    status: string | null
    createdYear: number | null
    lastVisit: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: number | null
    clinicId: number | null
    mrn: string | null
    name: string | null
    age: number | null
    email: string | null
    phone: string | null
    gender: string | null
    address: string | null
    medicalHistory: string | null
    allergies: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    status: string | null
    createdYear: number | null
    lastVisit: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    clinicId: number
    mrn: number
    name: number
    age: number
    email: number
    phone: number
    gender: number
    address: number
    medicalHistory: number
    allergies: number
    emergencyContactName: number
    emergencyContactPhone: number
    status: number
    createdYear: number
    lastVisit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientAvgAggregateInputType = {
    id?: true
    clinicId?: true
    age?: true
    createdYear?: true
  }

  export type PatientSumAggregateInputType = {
    id?: true
    clinicId?: true
    age?: true
    createdYear?: true
  }

  export type PatientMinAggregateInputType = {
    id?: true
    clinicId?: true
    mrn?: true
    name?: true
    age?: true
    email?: true
    phone?: true
    gender?: true
    address?: true
    medicalHistory?: true
    allergies?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    status?: true
    createdYear?: true
    lastVisit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    clinicId?: true
    mrn?: true
    name?: true
    age?: true
    email?: true
    phone?: true
    gender?: true
    address?: true
    medicalHistory?: true
    allergies?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    status?: true
    createdYear?: true
    lastVisit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    clinicId?: true
    mrn?: true
    name?: true
    age?: true
    email?: true
    phone?: true
    gender?: true
    address?: true
    medicalHistory?: true
    allergies?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    status?: true
    createdYear?: true
    lastVisit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patient to aggregate.
     */
    where?: patientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientOrderByWithRelationInput | patientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: patientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type patientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patientWhereInput
    orderBy?: patientOrderByWithAggregationInput | patientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: patientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _avg?: PatientAvgAggregateInputType
    _sum?: PatientSumAggregateInputType
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: number
    clinicId: number
    mrn: string | null
    name: string
    age: number | null
    email: string | null
    phone: string
    gender: string | null
    address: string | null
    medicalHistory: string | null
    allergies: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    status: string
    createdYear: number | null
    lastVisit: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends patientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type patientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    mrn?: boolean
    name?: boolean
    age?: boolean
    email?: boolean
    phone?: boolean
    gender?: boolean
    address?: boolean
    medicalHistory?: boolean
    allergies?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    createdYear?: boolean
    lastVisit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    appointment?: boolean | patient$appointmentArgs<ExtArgs>
    invoice?: boolean | patient$invoiceArgs<ExtArgs>
    medicalrecord?: boolean | patient$medicalrecordArgs<ExtArgs>
    formresponse?: boolean | patient$formresponseArgs<ExtArgs>
    clinic?: boolean | clinicDefaultArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>


  export type patientSelectScalar = {
    id?: boolean
    clinicId?: boolean
    mrn?: boolean
    name?: boolean
    age?: boolean
    email?: boolean
    phone?: boolean
    gender?: boolean
    address?: boolean
    medicalHistory?: boolean
    allergies?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    status?: boolean
    createdYear?: boolean
    lastVisit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type patientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | patient$appointmentArgs<ExtArgs>
    invoice?: boolean | patient$invoiceArgs<ExtArgs>
    medicalrecord?: boolean | patient$medicalrecordArgs<ExtArgs>
    formresponse?: boolean | patient$formresponseArgs<ExtArgs>
    clinic?: boolean | clinicDefaultArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $patientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "patient"
    objects: {
      appointment: Prisma.$appointmentPayload<ExtArgs>[]
      invoice: Prisma.$invoicePayload<ExtArgs>[]
      medicalrecord: Prisma.$medicalrecordPayload<ExtArgs>[]
      formresponse: Prisma.$formresponsePayload<ExtArgs>[]
      clinic: Prisma.$clinicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clinicId: number
      mrn: string | null
      name: string
      age: number | null
      email: string | null
      phone: string
      gender: string | null
      address: string | null
      medicalHistory: string | null
      allergies: string | null
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      status: string
      createdYear: number | null
      lastVisit: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type patientGetPayload<S extends boolean | null | undefined | patientDefaultArgs> = $Result.GetResult<Prisma.$patientPayload, S>

  type patientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<patientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface patientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['patient'], meta: { name: 'patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {patientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends patientFindUniqueArgs>(args: SelectSubset<T, patientFindUniqueArgs<ExtArgs>>): Prisma__patientClient<$Result.GetResult<Prisma.$patientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {patientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends patientFindUniqueOrThrowArgs>(args: SelectSubset<T, patientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__patientClient<$Result.GetResult<Prisma.$patientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends patientFindFirstArgs>(args?: SelectSubset<T, patientFindFirstArgs<ExtArgs>>): Prisma__patientClient<$Result.GetResult<Prisma.$patientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends patientFindFirstOrThrowArgs>(args?: SelectSubset<T, patientFindFirstOrThrowArgs<ExtArgs>>): Prisma__patientClient<$Result.GetResult<Prisma.$patientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends patientFindManyArgs>(args?: SelectSubset<T, patientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Patient.
     * @param {patientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends patientCreateArgs>(args: SelectSubset<T, patientCreateArgs<ExtArgs>>): Prisma__patientClient<$Result.GetResult<Prisma.$patientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Patients.
     * @param {patientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends patientCreateManyArgs>(args?: SelectSubset<T, patientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Patient.
     * @param {patientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends patientDeleteArgs>(args: SelectSubset<T, patientDeleteArgs<ExtArgs>>): Prisma__patientClient<$Result.GetResult<Prisma.$patientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Patient.
     * @param {patientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends patientUpdateArgs>(args: SelectSubset<T, patientUpdateArgs<ExtArgs>>): Prisma__patientClient<$Result.GetResult<Prisma.$patientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Patients.
     * @param {patientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends patientDeleteManyArgs>(args?: SelectSubset<T, patientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends patientUpdateManyArgs>(args: SelectSubset<T, patientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient.
     * @param {patientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends patientUpsertArgs>(args: SelectSubset<T, patientUpsertArgs<ExtArgs>>): Prisma__patientClient<$Result.GetResult<Prisma.$patientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends patientCountArgs>(
      args?: Subset<T, patientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends patientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: patientGroupByArgs['orderBy'] }
        : { orderBy?: patientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, patientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the patient model
   */
  readonly fields: patientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__patientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointment<T extends patient$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, patient$appointmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentPayload<ExtArgs>, T, "findMany"> | Null>
    invoice<T extends patient$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, patient$invoiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicePayload<ExtArgs>, T, "findMany"> | Null>
    medicalrecord<T extends patient$medicalrecordArgs<ExtArgs> = {}>(args?: Subset<T, patient$medicalrecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medicalrecordPayload<ExtArgs>, T, "findMany"> | Null>
    formresponse<T extends patient$formresponseArgs<ExtArgs> = {}>(args?: Subset<T, patient$formresponseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formresponsePayload<ExtArgs>, T, "findMany"> | Null>
    clinic<T extends clinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clinicDefaultArgs<ExtArgs>>): Prisma__clinicClient<$Result.GetResult<Prisma.$clinicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the patient model
   */ 
  interface patientFieldRefs {
    readonly id: FieldRef<"patient", 'Int'>
    readonly clinicId: FieldRef<"patient", 'Int'>
    readonly mrn: FieldRef<"patient", 'String'>
    readonly name: FieldRef<"patient", 'String'>
    readonly age: FieldRef<"patient", 'Int'>
    readonly email: FieldRef<"patient", 'String'>
    readonly phone: FieldRef<"patient", 'String'>
    readonly gender: FieldRef<"patient", 'String'>
    readonly address: FieldRef<"patient", 'String'>
    readonly medicalHistory: FieldRef<"patient", 'String'>
    readonly allergies: FieldRef<"patient", 'String'>
    readonly emergencyContactName: FieldRef<"patient", 'String'>
    readonly emergencyContactPhone: FieldRef<"patient", 'String'>
    readonly status: FieldRef<"patient", 'String'>
    readonly createdYear: FieldRef<"patient", 'Int'>
    readonly lastVisit: FieldRef<"patient", 'DateTime'>
    readonly createdAt: FieldRef<"patient", 'DateTime'>
    readonly updatedAt: FieldRef<"patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * patient findUnique
   */
  export type patientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient
     */
    select?: patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientInclude<ExtArgs> | null
    /**
     * Filter, which patient to fetch.
     */
    where: patientWhereUniqueInput
  }

  /**
   * patient findUniqueOrThrow
   */
  export type patientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient
     */
    select?: patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientInclude<ExtArgs> | null
    /**
     * Filter, which patient to fetch.
     */
    where: patientWhereUniqueInput
  }

  /**
   * patient findFirst
   */
  export type patientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient
     */
    select?: patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientInclude<ExtArgs> | null
    /**
     * Filter, which patient to fetch.
     */
    where?: patientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientOrderByWithRelationInput | patientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patients.
     */
    cursor?: patientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * patient findFirstOrThrow
   */
  export type patientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient
     */
    select?: patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientInclude<ExtArgs> | null
    /**
     * Filter, which patient to fetch.
     */
    where?: patientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientOrderByWithRelationInput | patientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patients.
     */
    cursor?: patientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * patient findMany
   */
  export type patientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient
     */
    select?: patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientInclude<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where?: patientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientOrderByWithRelationInput | patientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing patients.
     */
    cursor?: patientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * patient create
   */
  export type patientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient
     */
    select?: patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientInclude<ExtArgs> | null
    /**
     * The data needed to create a patient.
     */
    data: XOR<patientCreateInput, patientUncheckedCreateInput>
  }

  /**
   * patient createMany
   */
  export type patientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many patients.
     */
    data: patientCreateManyInput | patientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * patient update
   */
  export type patientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient
     */
    select?: patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientInclude<ExtArgs> | null
    /**
     * The data needed to update a patient.
     */
    data: XOR<patientUpdateInput, patientUncheckedUpdateInput>
    /**
     * Choose, which patient to update.
     */
    where: patientWhereUniqueInput
  }

  /**
   * patient updateMany
   */
  export type patientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update patients.
     */
    data: XOR<patientUpdateManyMutationInput, patientUncheckedUpdateManyInput>
    /**
     * Filter which patients to update
     */
    where?: patientWhereInput
  }

  /**
   * patient upsert
   */
  export type patientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient
     */
    select?: patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientInclude<ExtArgs> | null
    /**
     * The filter to search for the patient to update in case it exists.
     */
    where: patientWhereUniqueInput
    /**
     * In case the patient found by the `where` argument doesn't exist, create a new patient with this data.
     */
    create: XOR<patientCreateInput, patientUncheckedCreateInput>
    /**
     * In case the patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<patientUpdateInput, patientUncheckedUpdateInput>
  }

  /**
   * patient delete
   */
  export type patientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient
     */
    select?: patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientInclude<ExtArgs> | null
    /**
     * Filter which patient to delete.
     */
    where: patientWhereUniqueInput
  }

  /**
   * patient deleteMany
   */
  export type patientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patients to delete
     */
    where?: patientWhereInput
  }

  /**
   * patient.appointment
   */
  export type patient$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointment
     */
    select?: appointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentInclude<ExtArgs> | null
    where?: appointmentWhereInput
    orderBy?: appointmentOrderByWithRelationInput | appointmentOrderByWithRelationInput[]
    cursor?: appointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * patient.invoice
   */
  export type patient$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoice
     */
    select?: invoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoiceInclude<ExtArgs> | null
    where?: invoiceWhereInput
    orderBy?: invoiceOrderByWithRelationInput | invoiceOrderByWithRelationInput[]
    cursor?: invoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * patient.medicalrecord
   */
  export type patient$medicalrecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medicalrecord
     */
    select?: medicalrecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medicalrecordInclude<ExtArgs> | null
    where?: medicalrecordWhereInput
    orderBy?: medicalrecordOrderByWithRelationInput | medicalrecordOrderByWithRelationInput[]
    cursor?: medicalrecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalrecordScalarFieldEnum | MedicalrecordScalarFieldEnum[]
  }

  /**
   * patient.formresponse
   */
  export type patient$formresponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formresponse
     */
    select?: formresponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formresponseInclude<ExtArgs> | null
    where?: formresponseWhereInput
    orderBy?: formresponseOrderByWithRelationInput | formresponseOrderByWithRelationInput[]
    cursor?: formresponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormresponseScalarFieldEnum | FormresponseScalarFieldEnum[]
  }

  /**
   * patient without action
   */
  export type patientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient
     */
    select?: patientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    failedLoginAttempts: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    failedLoginAttempts: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    phone: string | null
    status: string | null
    joined: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    failedLoginAttempts: number | null
    lockoutUntil: Date | null
    role: $Enums.user_role | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    phone: string | null
    status: string | null
    joined: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    failedLoginAttempts: number | null
    lockoutUntil: Date | null
    role: $Enums.user_role | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    phone: number
    status: number
    joined: number
    createdAt: number
    updatedAt: number
    failedLoginAttempts: number
    lockoutUntil: number
    role: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    failedLoginAttempts?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    failedLoginAttempts?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    status?: true
    joined?: true
    createdAt?: true
    updatedAt?: true
    failedLoginAttempts?: true
    lockoutUntil?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    status?: true
    joined?: true
    createdAt?: true
    updatedAt?: true
    failedLoginAttempts?: true
    lockoutUntil?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    phone?: true
    status?: true
    joined?: true
    createdAt?: true
    updatedAt?: true
    failedLoginAttempts?: true
    lockoutUntil?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string
    phone: string | null
    status: string
    joined: Date
    createdAt: Date
    updatedAt: Date
    failedLoginAttempts: number
    lockoutUntil: Date | null
    role: $Enums.user_role
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    status?: boolean
    joined?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    failedLoginAttempts?: boolean
    lockoutUntil?: boolean
    role?: boolean
    auditlog?: boolean | user$auditlogArgs<ExtArgs>
    clinicstaff?: boolean | user$clinicstaffArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type userSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    phone?: boolean
    status?: boolean
    joined?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    failedLoginAttempts?: boolean
    lockoutUntil?: boolean
    role?: boolean
  }

  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditlog?: boolean | user$auditlogArgs<ExtArgs>
    clinicstaff?: boolean | user$clinicstaffArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      auditlog: Prisma.$auditlogPayload<ExtArgs>[]
      clinicstaff: Prisma.$clinicstaffPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string
      phone: string | null
      status: string
      joined: Date
      createdAt: Date
      updatedAt: Date
      failedLoginAttempts: number
      lockoutUntil: Date | null
      role: $Enums.user_role
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditlog<T extends user$auditlogArgs<ExtArgs> = {}>(args?: Subset<T, user$auditlogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findMany"> | Null>
    clinicstaff<T extends user$clinicstaffArgs<ExtArgs> = {}>(args?: Subset<T, user$clinicstaffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clinicstaffPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */ 
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'Int'>
    readonly email: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
    readonly name: FieldRef<"user", 'String'>
    readonly phone: FieldRef<"user", 'String'>
    readonly status: FieldRef<"user", 'String'>
    readonly joined: FieldRef<"user", 'DateTime'>
    readonly createdAt: FieldRef<"user", 'DateTime'>
    readonly updatedAt: FieldRef<"user", 'DateTime'>
    readonly failedLoginAttempts: FieldRef<"user", 'Int'>
    readonly lockoutUntil: FieldRef<"user", 'DateTime'>
    readonly role: FieldRef<"user", 'user_role'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }

  /**
   * user.auditlog
   */
  export type user$auditlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    where?: auditlogWhereInput
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    cursor?: auditlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditlogScalarFieldEnum | AuditlogScalarFieldEnum[]
  }

  /**
   * user.clinicstaff
   */
  export type user$clinicstaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clinicstaff
     */
    select?: clinicstaffSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clinicstaffInclude<ExtArgs> | null
    where?: clinicstaffWhereInput
    orderBy?: clinicstaffOrderByWithRelationInput | clinicstaffOrderByWithRelationInput[]
    cursor?: clinicstaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicstaffScalarFieldEnum | ClinicstaffScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    patientId: 'patientId',
    doctorId: 'doctorId',
    date: 'date',
    time: 'time',
    status: 'status',
    source: 'source',
    referenceId: 'referenceId',
    notes: 'notes',
    fees: 'fees',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const AuditlogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    performedBy: 'performedBy',
    userId: 'userId',
    clinicId: 'clinicId',
    timestamp: 'timestamp',
    ipAddress: 'ipAddress',
    device: 'device',
    details: 'details'
  };

  export type AuditlogScalarFieldEnum = (typeof AuditlogScalarFieldEnum)[keyof typeof AuditlogScalarFieldEnum]


  export const ClinicScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subdomain: 'subdomain',
    location: 'location',
    contact: 'contact',
    email: 'email',
    logo: 'logo',
    status: 'status',
    modules: 'modules',
    bookingConfig: 'bookingConfig',
    createdDate: 'createdDate',
    updatedAt: 'updatedAt'
  };

  export type ClinicScalarFieldEnum = (typeof ClinicScalarFieldEnum)[keyof typeof ClinicScalarFieldEnum]


  export const ClinicstaffScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    clinicId: 'clinicId',
    role: 'role',
    createdAt: 'createdAt',
    department: 'department',
    specialty: 'specialty'
  };

  export type ClinicstaffScalarFieldEnum = (typeof ClinicstaffScalarFieldEnum)[keyof typeof ClinicstaffScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    name: 'name',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const FormtemplateScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    name: 'name',
    specialty: 'specialty',
    status: 'status',
    version: 'version',
    fields: 'fields',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FormtemplateScalarFieldEnum = (typeof FormtemplateScalarFieldEnum)[keyof typeof FormtemplateScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    patientId: 'patientId',
    doctorId: 'doctorId',
    service: 'service',
    amount: 'amount',
    status: 'status',
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const MedicalrecordScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    patientId: 'patientId',
    doctorId: 'doctorId',
    templateId: 'templateId',
    visitDate: 'visitDate',
    type: 'type',
    data: 'data',
    isClosed: 'isClosed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicalrecordScalarFieldEnum = (typeof MedicalrecordScalarFieldEnum)[keyof typeof MedicalrecordScalarFieldEnum]


  export const FormresponseScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    formId: 'formId',
    patientId: 'patientId',
    doctorId: 'doctorId',
    answers: 'answers',
    submittedAt: 'submittedAt',
    updatedAt: 'updatedAt'
  };

  export type FormresponseScalarFieldEnum = (typeof FormresponseScalarFieldEnum)[keyof typeof FormresponseScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    department: 'department',
    message: 'message',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    mrn: 'mrn',
    name: 'name',
    age: 'age',
    email: 'email',
    phone: 'phone',
    gender: 'gender',
    address: 'address',
    medicalHistory: 'medicalHistory',
    allergies: 'allergies',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    status: 'status',
    createdYear: 'createdYear',
    lastVisit: 'lastVisit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    phone: 'phone',
    status: 'status',
    joined: 'joined',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    failedLoginAttempts: 'failedLoginAttempts',
    lockoutUntil: 'lockoutUntil',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'clinicstaff_role'
   */
  export type Enumclinicstaff_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'clinicstaff_role'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'user_role'
   */
  export type Enumuser_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_role'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type appointmentWhereInput = {
    AND?: appointmentWhereInput | appointmentWhereInput[]
    OR?: appointmentWhereInput[]
    NOT?: appointmentWhereInput | appointmentWhereInput[]
    id?: IntFilter<"appointment"> | number
    clinicId?: IntFilter<"appointment"> | number
    patientId?: IntFilter<"appointment"> | number
    doctorId?: IntFilter<"appointment"> | number
    date?: DateTimeFilter<"appointment"> | Date | string
    time?: StringFilter<"appointment"> | string
    status?: StringFilter<"appointment"> | string
    source?: StringFilter<"appointment"> | string
    referenceId?: StringNullableFilter<"appointment"> | string | null
    notes?: StringNullableFilter<"appointment"> | string | null
    fees?: DecimalNullableFilter<"appointment"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"appointment"> | Date | string
    updatedAt?: DateTimeFilter<"appointment"> | Date | string
    clinic?: XOR<ClinicRelationFilter, clinicWhereInput>
    patient?: XOR<PatientRelationFilter, patientWhereInput>
  }

  export type appointmentOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    status?: SortOrder
    source?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    fees?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: clinicOrderByWithRelationInput
    patient?: patientOrderByWithRelationInput
  }

  export type appointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    referenceId?: string
    AND?: appointmentWhereInput | appointmentWhereInput[]
    OR?: appointmentWhereInput[]
    NOT?: appointmentWhereInput | appointmentWhereInput[]
    clinicId?: IntFilter<"appointment"> | number
    patientId?: IntFilter<"appointment"> | number
    doctorId?: IntFilter<"appointment"> | number
    date?: DateTimeFilter<"appointment"> | Date | string
    time?: StringFilter<"appointment"> | string
    status?: StringFilter<"appointment"> | string
    source?: StringFilter<"appointment"> | string
    notes?: StringNullableFilter<"appointment"> | string | null
    fees?: DecimalNullableFilter<"appointment"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"appointment"> | Date | string
    updatedAt?: DateTimeFilter<"appointment"> | Date | string
    clinic?: XOR<ClinicRelationFilter, clinicWhereInput>
    patient?: XOR<PatientRelationFilter, patientWhereInput>
  }, "id" | "referenceId">

  export type appointmentOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    status?: SortOrder
    source?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    fees?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: appointmentCountOrderByAggregateInput
    _avg?: appointmentAvgOrderByAggregateInput
    _max?: appointmentMaxOrderByAggregateInput
    _min?: appointmentMinOrderByAggregateInput
    _sum?: appointmentSumOrderByAggregateInput
  }

  export type appointmentScalarWhereWithAggregatesInput = {
    AND?: appointmentScalarWhereWithAggregatesInput | appointmentScalarWhereWithAggregatesInput[]
    OR?: appointmentScalarWhereWithAggregatesInput[]
    NOT?: appointmentScalarWhereWithAggregatesInput | appointmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"appointment"> | number
    clinicId?: IntWithAggregatesFilter<"appointment"> | number
    patientId?: IntWithAggregatesFilter<"appointment"> | number
    doctorId?: IntWithAggregatesFilter<"appointment"> | number
    date?: DateTimeWithAggregatesFilter<"appointment"> | Date | string
    time?: StringWithAggregatesFilter<"appointment"> | string
    status?: StringWithAggregatesFilter<"appointment"> | string
    source?: StringWithAggregatesFilter<"appointment"> | string
    referenceId?: StringNullableWithAggregatesFilter<"appointment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"appointment"> | string | null
    fees?: DecimalNullableWithAggregatesFilter<"appointment"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"appointment"> | Date | string
  }

  export type auditlogWhereInput = {
    AND?: auditlogWhereInput | auditlogWhereInput[]
    OR?: auditlogWhereInput[]
    NOT?: auditlogWhereInput | auditlogWhereInput[]
    id?: IntFilter<"auditlog"> | number
    action?: StringFilter<"auditlog"> | string
    performedBy?: StringFilter<"auditlog"> | string
    userId?: IntNullableFilter<"auditlog"> | number | null
    clinicId?: IntNullableFilter<"auditlog"> | number | null
    timestamp?: DateTimeFilter<"auditlog"> | Date | string
    ipAddress?: StringNullableFilter<"auditlog"> | string | null
    device?: StringNullableFilter<"auditlog"> | string | null
    details?: StringNullableFilter<"auditlog"> | string | null
    clinic?: XOR<ClinicNullableRelationFilter, clinicWhereInput> | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }

  export type auditlogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    performedBy?: SortOrder
    userId?: SortOrderInput | SortOrder
    clinicId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    clinic?: clinicOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type auditlogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: auditlogWhereInput | auditlogWhereInput[]
    OR?: auditlogWhereInput[]
    NOT?: auditlogWhereInput | auditlogWhereInput[]
    action?: StringFilter<"auditlog"> | string
    performedBy?: StringFilter<"auditlog"> | string
    userId?: IntNullableFilter<"auditlog"> | number | null
    clinicId?: IntNullableFilter<"auditlog"> | number | null
    timestamp?: DateTimeFilter<"auditlog"> | Date | string
    ipAddress?: StringNullableFilter<"auditlog"> | string | null
    device?: StringNullableFilter<"auditlog"> | string | null
    details?: StringNullableFilter<"auditlog"> | string | null
    clinic?: XOR<ClinicNullableRelationFilter, clinicWhereInput> | null
    user?: XOR<UserNullableRelationFilter, userWhereInput> | null
  }, "id">

  export type auditlogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    performedBy?: SortOrder
    userId?: SortOrderInput | SortOrder
    clinicId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    _count?: auditlogCountOrderByAggregateInput
    _avg?: auditlogAvgOrderByAggregateInput
    _max?: auditlogMaxOrderByAggregateInput
    _min?: auditlogMinOrderByAggregateInput
    _sum?: auditlogSumOrderByAggregateInput
  }

  export type auditlogScalarWhereWithAggregatesInput = {
    AND?: auditlogScalarWhereWithAggregatesInput | auditlogScalarWhereWithAggregatesInput[]
    OR?: auditlogScalarWhereWithAggregatesInput[]
    NOT?: auditlogScalarWhereWithAggregatesInput | auditlogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"auditlog"> | number
    action?: StringWithAggregatesFilter<"auditlog"> | string
    performedBy?: StringWithAggregatesFilter<"auditlog"> | string
    userId?: IntNullableWithAggregatesFilter<"auditlog"> | number | null
    clinicId?: IntNullableWithAggregatesFilter<"auditlog"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"auditlog"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"auditlog"> | string | null
    device?: StringNullableWithAggregatesFilter<"auditlog"> | string | null
    details?: StringNullableWithAggregatesFilter<"auditlog"> | string | null
  }

  export type clinicWhereInput = {
    AND?: clinicWhereInput | clinicWhereInput[]
    OR?: clinicWhereInput[]
    NOT?: clinicWhereInput | clinicWhereInput[]
    id?: IntFilter<"clinic"> | number
    name?: StringFilter<"clinic"> | string
    subdomain?: StringFilter<"clinic"> | string
    location?: StringFilter<"clinic"> | string
    contact?: StringFilter<"clinic"> | string
    email?: StringFilter<"clinic"> | string
    logo?: StringNullableFilter<"clinic"> | string | null
    status?: StringFilter<"clinic"> | string
    modules?: StringNullableFilter<"clinic"> | string | null
    bookingConfig?: StringNullableFilter<"clinic"> | string | null
    createdDate?: DateTimeFilter<"clinic"> | Date | string
    updatedAt?: DateTimeFilter<"clinic"> | Date | string
    appointment?: AppointmentListRelationFilter
    auditlog?: AuditlogListRelationFilter
    clinicstaff?: ClinicstaffListRelationFilter
    department?: DepartmentListRelationFilter
    formtemplate?: FormtemplateListRelationFilter
    invoice?: InvoiceListRelationFilter
    medicalrecord?: MedicalrecordListRelationFilter
    notification?: NotificationListRelationFilter
    patient?: PatientListRelationFilter
    formresponse?: FormresponseListRelationFilter
  }

  export type clinicOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    location?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    logo?: SortOrderInput | SortOrder
    status?: SortOrder
    modules?: SortOrderInput | SortOrder
    bookingConfig?: SortOrderInput | SortOrder
    createdDate?: SortOrder
    updatedAt?: SortOrder
    appointment?: appointmentOrderByRelationAggregateInput
    auditlog?: auditlogOrderByRelationAggregateInput
    clinicstaff?: clinicstaffOrderByRelationAggregateInput
    department?: departmentOrderByRelationAggregateInput
    formtemplate?: formtemplateOrderByRelationAggregateInput
    invoice?: invoiceOrderByRelationAggregateInput
    medicalrecord?: medicalrecordOrderByRelationAggregateInput
    notification?: notificationOrderByRelationAggregateInput
    patient?: patientOrderByRelationAggregateInput
    formresponse?: formresponseOrderByRelationAggregateInput
  }

  export type clinicWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    subdomain?: string
    AND?: clinicWhereInput | clinicWhereInput[]
    OR?: clinicWhereInput[]
    NOT?: clinicWhereInput | clinicWhereInput[]
    name?: StringFilter<"clinic"> | string
    location?: StringFilter<"clinic"> | string
    contact?: StringFilter<"clinic"> | string
    email?: StringFilter<"clinic"> | string
    logo?: StringNullableFilter<"clinic"> | string | null
    status?: StringFilter<"clinic"> | string
    modules?: StringNullableFilter<"clinic"> | string | null
    bookingConfig?: StringNullableFilter<"clinic"> | string | null
    createdDate?: DateTimeFilter<"clinic"> | Date | string
    updatedAt?: DateTimeFilter<"clinic"> | Date | string
    appointment?: AppointmentListRelationFilter
    auditlog?: AuditlogListRelationFilter
    clinicstaff?: ClinicstaffListRelationFilter
    department?: DepartmentListRelationFilter
    formtemplate?: FormtemplateListRelationFilter
    invoice?: InvoiceListRelationFilter
    medicalrecord?: MedicalrecordListRelationFilter
    notification?: NotificationListRelationFilter
    patient?: PatientListRelationFilter
    formresponse?: FormresponseListRelationFilter
  }, "id" | "subdomain">

  export type clinicOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    location?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    logo?: SortOrderInput | SortOrder
    status?: SortOrder
    modules?: SortOrderInput | SortOrder
    bookingConfig?: SortOrderInput | SortOrder
    createdDate?: SortOrder
    updatedAt?: SortOrder
    _count?: clinicCountOrderByAggregateInput
    _avg?: clinicAvgOrderByAggregateInput
    _max?: clinicMaxOrderByAggregateInput
    _min?: clinicMinOrderByAggregateInput
    _sum?: clinicSumOrderByAggregateInput
  }

  export type clinicScalarWhereWithAggregatesInput = {
    AND?: clinicScalarWhereWithAggregatesInput | clinicScalarWhereWithAggregatesInput[]
    OR?: clinicScalarWhereWithAggregatesInput[]
    NOT?: clinicScalarWhereWithAggregatesInput | clinicScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"clinic"> | number
    name?: StringWithAggregatesFilter<"clinic"> | string
    subdomain?: StringWithAggregatesFilter<"clinic"> | string
    location?: StringWithAggregatesFilter<"clinic"> | string
    contact?: StringWithAggregatesFilter<"clinic"> | string
    email?: StringWithAggregatesFilter<"clinic"> | string
    logo?: StringNullableWithAggregatesFilter<"clinic"> | string | null
    status?: StringWithAggregatesFilter<"clinic"> | string
    modules?: StringNullableWithAggregatesFilter<"clinic"> | string | null
    bookingConfig?: StringNullableWithAggregatesFilter<"clinic"> | string | null
    createdDate?: DateTimeWithAggregatesFilter<"clinic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"clinic"> | Date | string
  }

  export type clinicstaffWhereInput = {
    AND?: clinicstaffWhereInput | clinicstaffWhereInput[]
    OR?: clinicstaffWhereInput[]
    NOT?: clinicstaffWhereInput | clinicstaffWhereInput[]
    id?: IntFilter<"clinicstaff"> | number
    userId?: IntFilter<"clinicstaff"> | number
    clinicId?: IntFilter<"clinicstaff"> | number
    role?: Enumclinicstaff_roleFilter<"clinicstaff"> | $Enums.clinicstaff_role
    createdAt?: DateTimeFilter<"clinicstaff"> | Date | string
    department?: StringNullableFilter<"clinicstaff"> | string | null
    specialty?: StringNullableFilter<"clinicstaff"> | string | null
    clinic?: XOR<ClinicRelationFilter, clinicWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type clinicstaffOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    department?: SortOrderInput | SortOrder
    specialty?: SortOrderInput | SortOrder
    clinic?: clinicOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type clinicstaffWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_clinicId_role?: clinicstaffUserIdClinicIdRoleCompoundUniqueInput
    AND?: clinicstaffWhereInput | clinicstaffWhereInput[]
    OR?: clinicstaffWhereInput[]
    NOT?: clinicstaffWhereInput | clinicstaffWhereInput[]
    userId?: IntFilter<"clinicstaff"> | number
    clinicId?: IntFilter<"clinicstaff"> | number
    role?: Enumclinicstaff_roleFilter<"clinicstaff"> | $Enums.clinicstaff_role
    createdAt?: DateTimeFilter<"clinicstaff"> | Date | string
    department?: StringNullableFilter<"clinicstaff"> | string | null
    specialty?: StringNullableFilter<"clinicstaff"> | string | null
    clinic?: XOR<ClinicRelationFilter, clinicWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id" | "userId_clinicId_role">

  export type clinicstaffOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    department?: SortOrderInput | SortOrder
    specialty?: SortOrderInput | SortOrder
    _count?: clinicstaffCountOrderByAggregateInput
    _avg?: clinicstaffAvgOrderByAggregateInput
    _max?: clinicstaffMaxOrderByAggregateInput
    _min?: clinicstaffMinOrderByAggregateInput
    _sum?: clinicstaffSumOrderByAggregateInput
  }

  export type clinicstaffScalarWhereWithAggregatesInput = {
    AND?: clinicstaffScalarWhereWithAggregatesInput | clinicstaffScalarWhereWithAggregatesInput[]
    OR?: clinicstaffScalarWhereWithAggregatesInput[]
    NOT?: clinicstaffScalarWhereWithAggregatesInput | clinicstaffScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"clinicstaff"> | number
    userId?: IntWithAggregatesFilter<"clinicstaff"> | number
    clinicId?: IntWithAggregatesFilter<"clinicstaff"> | number
    role?: Enumclinicstaff_roleWithAggregatesFilter<"clinicstaff"> | $Enums.clinicstaff_role
    createdAt?: DateTimeWithAggregatesFilter<"clinicstaff"> | Date | string
    department?: StringNullableWithAggregatesFilter<"clinicstaff"> | string | null
    specialty?: StringNullableWithAggregatesFilter<"clinicstaff"> | string | null
  }

  export type departmentWhereInput = {
    AND?: departmentWhereInput | departmentWhereInput[]
    OR?: departmentWhereInput[]
    NOT?: departmentWhereInput | departmentWhereInput[]
    id?: IntFilter<"department"> | number
    clinicId?: IntFilter<"department"> | number
    name?: StringFilter<"department"> | string
    type?: StringFilter<"department"> | string
    createdAt?: DateTimeFilter<"department"> | Date | string
    updatedAt?: DateTimeFilter<"department"> | Date | string
    clinic?: XOR<ClinicRelationFilter, clinicWhereInput>
  }

  export type departmentOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: clinicOrderByWithRelationInput
  }

  export type departmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    clinicId_name?: departmentClinicIdNameCompoundUniqueInput
    AND?: departmentWhereInput | departmentWhereInput[]
    OR?: departmentWhereInput[]
    NOT?: departmentWhereInput | departmentWhereInput[]
    clinicId?: IntFilter<"department"> | number
    name?: StringFilter<"department"> | string
    type?: StringFilter<"department"> | string
    createdAt?: DateTimeFilter<"department"> | Date | string
    updatedAt?: DateTimeFilter<"department"> | Date | string
    clinic?: XOR<ClinicRelationFilter, clinicWhereInput>
  }, "id" | "clinicId_name">

  export type departmentOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: departmentCountOrderByAggregateInput
    _avg?: departmentAvgOrderByAggregateInput
    _max?: departmentMaxOrderByAggregateInput
    _min?: departmentMinOrderByAggregateInput
    _sum?: departmentSumOrderByAggregateInput
  }

  export type departmentScalarWhereWithAggregatesInput = {
    AND?: departmentScalarWhereWithAggregatesInput | departmentScalarWhereWithAggregatesInput[]
    OR?: departmentScalarWhereWithAggregatesInput[]
    NOT?: departmentScalarWhereWithAggregatesInput | departmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"department"> | number
    clinicId?: IntWithAggregatesFilter<"department"> | number
    name?: StringWithAggregatesFilter<"department"> | string
    type?: StringWithAggregatesFilter<"department"> | string
    createdAt?: DateTimeWithAggregatesFilter<"department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"department"> | Date | string
  }

  export type formtemplateWhereInput = {
    AND?: formtemplateWhereInput | formtemplateWhereInput[]
    OR?: formtemplateWhereInput[]
    NOT?: formtemplateWhereInput | formtemplateWhereInput[]
    id?: IntFilter<"formtemplate"> | number
    clinicId?: IntNullableFilter<"formtemplate"> | number | null
    name?: StringFilter<"formtemplate"> | string
    specialty?: StringFilter<"formtemplate"> | string
    status?: StringFilter<"formtemplate"> | string
    version?: IntFilter<"formtemplate"> | number
    fields?: StringFilter<"formtemplate"> | string
    createdAt?: DateTimeFilter<"formtemplate"> | Date | string
    updatedAt?: DateTimeFilter<"formtemplate"> | Date | string
    clinic?: XOR<ClinicNullableRelationFilter, clinicWhereInput> | null
    medicalrecord?: MedicalrecordListRelationFilter
    formresponse?: FormresponseListRelationFilter
  }

  export type formtemplateOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    name?: SortOrder
    specialty?: SortOrder
    status?: SortOrder
    version?: SortOrder
    fields?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: clinicOrderByWithRelationInput
    medicalrecord?: medicalrecordOrderByRelationAggregateInput
    formresponse?: formresponseOrderByRelationAggregateInput
  }

  export type formtemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: formtemplateWhereInput | formtemplateWhereInput[]
    OR?: formtemplateWhereInput[]
    NOT?: formtemplateWhereInput | formtemplateWhereInput[]
    clinicId?: IntNullableFilter<"formtemplate"> | number | null
    name?: StringFilter<"formtemplate"> | string
    specialty?: StringFilter<"formtemplate"> | string
    status?: StringFilter<"formtemplate"> | string
    version?: IntFilter<"formtemplate"> | number
    fields?: StringFilter<"formtemplate"> | string
    createdAt?: DateTimeFilter<"formtemplate"> | Date | string
    updatedAt?: DateTimeFilter<"formtemplate"> | Date | string
    clinic?: XOR<ClinicNullableRelationFilter, clinicWhereInput> | null
    medicalrecord?: MedicalrecordListRelationFilter
    formresponse?: FormresponseListRelationFilter
  }, "id">

  export type formtemplateOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    name?: SortOrder
    specialty?: SortOrder
    status?: SortOrder
    version?: SortOrder
    fields?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: formtemplateCountOrderByAggregateInput
    _avg?: formtemplateAvgOrderByAggregateInput
    _max?: formtemplateMaxOrderByAggregateInput
    _min?: formtemplateMinOrderByAggregateInput
    _sum?: formtemplateSumOrderByAggregateInput
  }

  export type formtemplateScalarWhereWithAggregatesInput = {
    AND?: formtemplateScalarWhereWithAggregatesInput | formtemplateScalarWhereWithAggregatesInput[]
    OR?: formtemplateScalarWhereWithAggregatesInput[]
    NOT?: formtemplateScalarWhereWithAggregatesInput | formtemplateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"formtemplate"> | number
    clinicId?: IntNullableWithAggregatesFilter<"formtemplate"> | number | null
    name?: StringWithAggregatesFilter<"formtemplate"> | string
    specialty?: StringWithAggregatesFilter<"formtemplate"> | string
    status?: StringWithAggregatesFilter<"formtemplate"> | string
    version?: IntWithAggregatesFilter<"formtemplate"> | number
    fields?: StringWithAggregatesFilter<"formtemplate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"formtemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"formtemplate"> | Date | string
  }

  export type invoiceWhereInput = {
    AND?: invoiceWhereInput | invoiceWhereInput[]
    OR?: invoiceWhereInput[]
    NOT?: invoiceWhereInput | invoiceWhereInput[]
    id?: StringFilter<"invoice"> | string
    clinicId?: IntFilter<"invoice"> | number
    patientId?: IntFilter<"invoice"> | number
    doctorId?: IntNullableFilter<"invoice"> | number | null
    service?: StringFilter<"invoice"> | string
    amount?: DecimalFilter<"invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"invoice"> | string
    date?: DateTimeFilter<"invoice"> | Date | string
    createdAt?: DateTimeFilter<"invoice"> | Date | string
    updatedAt?: DateTimeFilter<"invoice"> | Date | string
    clinic?: XOR<ClinicRelationFilter, clinicWhereInput>
    patient?: XOR<PatientRelationFilter, patientWhereInput>
  }

  export type invoiceOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    service?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: clinicOrderByWithRelationInput
    patient?: patientOrderByWithRelationInput
  }

  export type invoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: invoiceWhereInput | invoiceWhereInput[]
    OR?: invoiceWhereInput[]
    NOT?: invoiceWhereInput | invoiceWhereInput[]
    clinicId?: IntFilter<"invoice"> | number
    patientId?: IntFilter<"invoice"> | number
    doctorId?: IntNullableFilter<"invoice"> | number | null
    service?: StringFilter<"invoice"> | string
    amount?: DecimalFilter<"invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"invoice"> | string
    date?: DateTimeFilter<"invoice"> | Date | string
    createdAt?: DateTimeFilter<"invoice"> | Date | string
    updatedAt?: DateTimeFilter<"invoice"> | Date | string
    clinic?: XOR<ClinicRelationFilter, clinicWhereInput>
    patient?: XOR<PatientRelationFilter, patientWhereInput>
  }, "id">

  export type invoiceOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrderInput | SortOrder
    service?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: invoiceCountOrderByAggregateInput
    _avg?: invoiceAvgOrderByAggregateInput
    _max?: invoiceMaxOrderByAggregateInput
    _min?: invoiceMinOrderByAggregateInput
    _sum?: invoiceSumOrderByAggregateInput
  }

  export type invoiceScalarWhereWithAggregatesInput = {
    AND?: invoiceScalarWhereWithAggregatesInput | invoiceScalarWhereWithAggregatesInput[]
    OR?: invoiceScalarWhereWithAggregatesInput[]
    NOT?: invoiceScalarWhereWithAggregatesInput | invoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"invoice"> | string
    clinicId?: IntWithAggregatesFilter<"invoice"> | number
    patientId?: IntWithAggregatesFilter<"invoice"> | number
    doctorId?: IntNullableWithAggregatesFilter<"invoice"> | number | null
    service?: StringWithAggregatesFilter<"invoice"> | string
    amount?: DecimalWithAggregatesFilter<"invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"invoice"> | string
    date?: DateTimeWithAggregatesFilter<"invoice"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"invoice"> | Date | string
  }

  export type medicalrecordWhereInput = {
    AND?: medicalrecordWhereInput | medicalrecordWhereInput[]
    OR?: medicalrecordWhereInput[]
    NOT?: medicalrecordWhereInput | medicalrecordWhereInput[]
    id?: IntFilter<"medicalrecord"> | number
    clinicId?: IntFilter<"medicalrecord"> | number
    patientId?: IntFilter<"medicalrecord"> | number
    doctorId?: IntFilter<"medicalrecord"> | number
    templateId?: IntNullableFilter<"medicalrecord"> | number | null
    visitDate?: DateTimeFilter<"medicalrecord"> | Date | string
    type?: StringFilter<"medicalrecord"> | string
    data?: StringFilter<"medicalrecord"> | string
    isClosed?: BoolFilter<"medicalrecord"> | boolean
    createdAt?: DateTimeFilter<"medicalrecord"> | Date | string
    updatedAt?: DateTimeFilter<"medicalrecord"> | Date | string
    clinic?: XOR<ClinicRelationFilter, clinicWhereInput>
    patient?: XOR<PatientRelationFilter, patientWhereInput>
    formtemplate?: XOR<FormtemplateNullableRelationFilter, formtemplateWhereInput> | null
  }

  export type medicalrecordOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    templateId?: SortOrderInput | SortOrder
    visitDate?: SortOrder
    type?: SortOrder
    data?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: clinicOrderByWithRelationInput
    patient?: patientOrderByWithRelationInput
    formtemplate?: formtemplateOrderByWithRelationInput
  }

  export type medicalrecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: medicalrecordWhereInput | medicalrecordWhereInput[]
    OR?: medicalrecordWhereInput[]
    NOT?: medicalrecordWhereInput | medicalrecordWhereInput[]
    clinicId?: IntFilter<"medicalrecord"> | number
    patientId?: IntFilter<"medicalrecord"> | number
    doctorId?: IntFilter<"medicalrecord"> | number
    templateId?: IntNullableFilter<"medicalrecord"> | number | null
    visitDate?: DateTimeFilter<"medicalrecord"> | Date | string
    type?: StringFilter<"medicalrecord"> | string
    data?: StringFilter<"medicalrecord"> | string
    isClosed?: BoolFilter<"medicalrecord"> | boolean
    createdAt?: DateTimeFilter<"medicalrecord"> | Date | string
    updatedAt?: DateTimeFilter<"medicalrecord"> | Date | string
    clinic?: XOR<ClinicRelationFilter, clinicWhereInput>
    patient?: XOR<PatientRelationFilter, patientWhereInput>
    formtemplate?: XOR<FormtemplateNullableRelationFilter, formtemplateWhereInput> | null
  }, "id">

  export type medicalrecordOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    templateId?: SortOrderInput | SortOrder
    visitDate?: SortOrder
    type?: SortOrder
    data?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: medicalrecordCountOrderByAggregateInput
    _avg?: medicalrecordAvgOrderByAggregateInput
    _max?: medicalrecordMaxOrderByAggregateInput
    _min?: medicalrecordMinOrderByAggregateInput
    _sum?: medicalrecordSumOrderByAggregateInput
  }

  export type medicalrecordScalarWhereWithAggregatesInput = {
    AND?: medicalrecordScalarWhereWithAggregatesInput | medicalrecordScalarWhereWithAggregatesInput[]
    OR?: medicalrecordScalarWhereWithAggregatesInput[]
    NOT?: medicalrecordScalarWhereWithAggregatesInput | medicalrecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"medicalrecord"> | number
    clinicId?: IntWithAggregatesFilter<"medicalrecord"> | number
    patientId?: IntWithAggregatesFilter<"medicalrecord"> | number
    doctorId?: IntWithAggregatesFilter<"medicalrecord"> | number
    templateId?: IntNullableWithAggregatesFilter<"medicalrecord"> | number | null
    visitDate?: DateTimeWithAggregatesFilter<"medicalrecord"> | Date | string
    type?: StringWithAggregatesFilter<"medicalrecord"> | string
    data?: StringWithAggregatesFilter<"medicalrecord"> | string
    isClosed?: BoolWithAggregatesFilter<"medicalrecord"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"medicalrecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"medicalrecord"> | Date | string
  }

  export type formresponseWhereInput = {
    AND?: formresponseWhereInput | formresponseWhereInput[]
    OR?: formresponseWhereInput[]
    NOT?: formresponseWhereInput | formresponseWhereInput[]
    id?: IntFilter<"formresponse"> | number
    clinicId?: IntFilter<"formresponse"> | number
    formId?: IntFilter<"formresponse"> | number
    patientId?: IntFilter<"formresponse"> | number
    doctorId?: IntFilter<"formresponse"> | number
    answers?: StringFilter<"formresponse"> | string
    submittedAt?: DateTimeFilter<"formresponse"> | Date | string
    updatedAt?: DateTimeFilter<"formresponse"> | Date | string
    clinic?: XOR<ClinicRelationFilter, clinicWhereInput>
    formtemplate?: XOR<FormtemplateRelationFilter, formtemplateWhereInput>
    patient?: XOR<PatientRelationFilter, patientWhereInput>
  }

  export type formresponseOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    formId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    answers?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: clinicOrderByWithRelationInput
    formtemplate?: formtemplateOrderByWithRelationInput
    patient?: patientOrderByWithRelationInput
  }

  export type formresponseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: formresponseWhereInput | formresponseWhereInput[]
    OR?: formresponseWhereInput[]
    NOT?: formresponseWhereInput | formresponseWhereInput[]
    clinicId?: IntFilter<"formresponse"> | number
    formId?: IntFilter<"formresponse"> | number
    patientId?: IntFilter<"formresponse"> | number
    doctorId?: IntFilter<"formresponse"> | number
    answers?: StringFilter<"formresponse"> | string
    submittedAt?: DateTimeFilter<"formresponse"> | Date | string
    updatedAt?: DateTimeFilter<"formresponse"> | Date | string
    clinic?: XOR<ClinicRelationFilter, clinicWhereInput>
    formtemplate?: XOR<FormtemplateRelationFilter, formtemplateWhereInput>
    patient?: XOR<PatientRelationFilter, patientWhereInput>
  }, "id">

  export type formresponseOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    formId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    answers?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: formresponseCountOrderByAggregateInput
    _avg?: formresponseAvgOrderByAggregateInput
    _max?: formresponseMaxOrderByAggregateInput
    _min?: formresponseMinOrderByAggregateInput
    _sum?: formresponseSumOrderByAggregateInput
  }

  export type formresponseScalarWhereWithAggregatesInput = {
    AND?: formresponseScalarWhereWithAggregatesInput | formresponseScalarWhereWithAggregatesInput[]
    OR?: formresponseScalarWhereWithAggregatesInput[]
    NOT?: formresponseScalarWhereWithAggregatesInput | formresponseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"formresponse"> | number
    clinicId?: IntWithAggregatesFilter<"formresponse"> | number
    formId?: IntWithAggregatesFilter<"formresponse"> | number
    patientId?: IntWithAggregatesFilter<"formresponse"> | number
    doctorId?: IntWithAggregatesFilter<"formresponse"> | number
    answers?: StringWithAggregatesFilter<"formresponse"> | string
    submittedAt?: DateTimeWithAggregatesFilter<"formresponse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"formresponse"> | Date | string
  }

  export type notificationWhereInput = {
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    id?: IntFilter<"notification"> | number
    clinicId?: IntFilter<"notification"> | number
    department?: StringFilter<"notification"> | string
    message?: StringFilter<"notification"> | string
    status?: StringFilter<"notification"> | string
    createdAt?: DateTimeFilter<"notification"> | Date | string
    clinic?: XOR<ClinicRelationFilter, clinicWhereInput>
  }

  export type notificationOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    department?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    clinic?: clinicOrderByWithRelationInput
  }

  export type notificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: notificationWhereInput | notificationWhereInput[]
    OR?: notificationWhereInput[]
    NOT?: notificationWhereInput | notificationWhereInput[]
    clinicId?: IntFilter<"notification"> | number
    department?: StringFilter<"notification"> | string
    message?: StringFilter<"notification"> | string
    status?: StringFilter<"notification"> | string
    createdAt?: DateTimeFilter<"notification"> | Date | string
    clinic?: XOR<ClinicRelationFilter, clinicWhereInput>
  }, "id">

  export type notificationOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    department?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: notificationCountOrderByAggregateInput
    _avg?: notificationAvgOrderByAggregateInput
    _max?: notificationMaxOrderByAggregateInput
    _min?: notificationMinOrderByAggregateInput
    _sum?: notificationSumOrderByAggregateInput
  }

  export type notificationScalarWhereWithAggregatesInput = {
    AND?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    OR?: notificationScalarWhereWithAggregatesInput[]
    NOT?: notificationScalarWhereWithAggregatesInput | notificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"notification"> | number
    clinicId?: IntWithAggregatesFilter<"notification"> | number
    department?: StringWithAggregatesFilter<"notification"> | string
    message?: StringWithAggregatesFilter<"notification"> | string
    status?: StringWithAggregatesFilter<"notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"notification"> | Date | string
  }

  export type patientWhereInput = {
    AND?: patientWhereInput | patientWhereInput[]
    OR?: patientWhereInput[]
    NOT?: patientWhereInput | patientWhereInput[]
    id?: IntFilter<"patient"> | number
    clinicId?: IntFilter<"patient"> | number
    mrn?: StringNullableFilter<"patient"> | string | null
    name?: StringFilter<"patient"> | string
    age?: IntNullableFilter<"patient"> | number | null
    email?: StringNullableFilter<"patient"> | string | null
    phone?: StringFilter<"patient"> | string
    gender?: StringNullableFilter<"patient"> | string | null
    address?: StringNullableFilter<"patient"> | string | null
    medicalHistory?: StringNullableFilter<"patient"> | string | null
    allergies?: StringNullableFilter<"patient"> | string | null
    emergencyContactName?: StringNullableFilter<"patient"> | string | null
    emergencyContactPhone?: StringNullableFilter<"patient"> | string | null
    status?: StringFilter<"patient"> | string
    createdYear?: IntNullableFilter<"patient"> | number | null
    lastVisit?: DateTimeNullableFilter<"patient"> | Date | string | null
    createdAt?: DateTimeFilter<"patient"> | Date | string
    updatedAt?: DateTimeFilter<"patient"> | Date | string
    appointment?: AppointmentListRelationFilter
    invoice?: InvoiceListRelationFilter
    medicalrecord?: MedicalrecordListRelationFilter
    formresponse?: FormresponseListRelationFilter
    clinic?: XOR<ClinicRelationFilter, clinicWhereInput>
  }

  export type patientOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    mrn?: SortOrderInput | SortOrder
    name?: SortOrder
    age?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    gender?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    medicalHistory?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    createdYear?: SortOrderInput | SortOrder
    lastVisit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    appointment?: appointmentOrderByRelationAggregateInput
    invoice?: invoiceOrderByRelationAggregateInput
    medicalrecord?: medicalrecordOrderByRelationAggregateInput
    formresponse?: formresponseOrderByRelationAggregateInput
    clinic?: clinicOrderByWithRelationInput
  }

  export type patientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    clinicId_mrn?: patientClinicIdMrnCompoundUniqueInput
    AND?: patientWhereInput | patientWhereInput[]
    OR?: patientWhereInput[]
    NOT?: patientWhereInput | patientWhereInput[]
    clinicId?: IntFilter<"patient"> | number
    mrn?: StringNullableFilter<"patient"> | string | null
    name?: StringFilter<"patient"> | string
    age?: IntNullableFilter<"patient"> | number | null
    email?: StringNullableFilter<"patient"> | string | null
    phone?: StringFilter<"patient"> | string
    gender?: StringNullableFilter<"patient"> | string | null
    address?: StringNullableFilter<"patient"> | string | null
    medicalHistory?: StringNullableFilter<"patient"> | string | null
    allergies?: StringNullableFilter<"patient"> | string | null
    emergencyContactName?: StringNullableFilter<"patient"> | string | null
    emergencyContactPhone?: StringNullableFilter<"patient"> | string | null
    status?: StringFilter<"patient"> | string
    createdYear?: IntNullableFilter<"patient"> | number | null
    lastVisit?: DateTimeNullableFilter<"patient"> | Date | string | null
    createdAt?: DateTimeFilter<"patient"> | Date | string
    updatedAt?: DateTimeFilter<"patient"> | Date | string
    appointment?: AppointmentListRelationFilter
    invoice?: InvoiceListRelationFilter
    medicalrecord?: MedicalrecordListRelationFilter
    formresponse?: FormresponseListRelationFilter
    clinic?: XOR<ClinicRelationFilter, clinicWhereInput>
  }, "id" | "clinicId_mrn">

  export type patientOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    mrn?: SortOrderInput | SortOrder
    name?: SortOrder
    age?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    gender?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    medicalHistory?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    status?: SortOrder
    createdYear?: SortOrderInput | SortOrder
    lastVisit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: patientCountOrderByAggregateInput
    _avg?: patientAvgOrderByAggregateInput
    _max?: patientMaxOrderByAggregateInput
    _min?: patientMinOrderByAggregateInput
    _sum?: patientSumOrderByAggregateInput
  }

  export type patientScalarWhereWithAggregatesInput = {
    AND?: patientScalarWhereWithAggregatesInput | patientScalarWhereWithAggregatesInput[]
    OR?: patientScalarWhereWithAggregatesInput[]
    NOT?: patientScalarWhereWithAggregatesInput | patientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"patient"> | number
    clinicId?: IntWithAggregatesFilter<"patient"> | number
    mrn?: StringNullableWithAggregatesFilter<"patient"> | string | null
    name?: StringWithAggregatesFilter<"patient"> | string
    age?: IntNullableWithAggregatesFilter<"patient"> | number | null
    email?: StringNullableWithAggregatesFilter<"patient"> | string | null
    phone?: StringWithAggregatesFilter<"patient"> | string
    gender?: StringNullableWithAggregatesFilter<"patient"> | string | null
    address?: StringNullableWithAggregatesFilter<"patient"> | string | null
    medicalHistory?: StringNullableWithAggregatesFilter<"patient"> | string | null
    allergies?: StringNullableWithAggregatesFilter<"patient"> | string | null
    emergencyContactName?: StringNullableWithAggregatesFilter<"patient"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"patient"> | string | null
    status?: StringWithAggregatesFilter<"patient"> | string
    createdYear?: IntNullableWithAggregatesFilter<"patient"> | number | null
    lastVisit?: DateTimeNullableWithAggregatesFilter<"patient"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"patient"> | Date | string
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: IntFilter<"user"> | number
    email?: StringFilter<"user"> | string
    password?: StringFilter<"user"> | string
    name?: StringFilter<"user"> | string
    phone?: StringNullableFilter<"user"> | string | null
    status?: StringFilter<"user"> | string
    joined?: DateTimeFilter<"user"> | Date | string
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
    failedLoginAttempts?: IntFilter<"user"> | number
    lockoutUntil?: DateTimeNullableFilter<"user"> | Date | string | null
    role?: Enumuser_roleFilter<"user"> | $Enums.user_role
    auditlog?: AuditlogListRelationFilter
    clinicstaff?: ClinicstaffListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrder
    joined?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockoutUntil?: SortOrderInput | SortOrder
    role?: SortOrder
    auditlog?: auditlogOrderByRelationAggregateInput
    clinicstaff?: clinicstaffOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    password?: StringFilter<"user"> | string
    name?: StringFilter<"user"> | string
    phone?: StringNullableFilter<"user"> | string | null
    status?: StringFilter<"user"> | string
    joined?: DateTimeFilter<"user"> | Date | string
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
    failedLoginAttempts?: IntFilter<"user"> | number
    lockoutUntil?: DateTimeNullableFilter<"user"> | Date | string | null
    role?: Enumuser_roleFilter<"user"> | $Enums.user_role
    auditlog?: AuditlogListRelationFilter
    clinicstaff?: ClinicstaffListRelationFilter
  }, "id" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    status?: SortOrder
    joined?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockoutUntil?: SortOrderInput | SortOrder
    role?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user"> | number
    email?: StringWithAggregatesFilter<"user"> | string
    password?: StringWithAggregatesFilter<"user"> | string
    name?: StringWithAggregatesFilter<"user"> | string
    phone?: StringNullableWithAggregatesFilter<"user"> | string | null
    status?: StringWithAggregatesFilter<"user"> | string
    joined?: DateTimeWithAggregatesFilter<"user"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
    failedLoginAttempts?: IntWithAggregatesFilter<"user"> | number
    lockoutUntil?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    role?: Enumuser_roleWithAggregatesFilter<"user"> | $Enums.user_role
  }

  export type appointmentCreateInput = {
    doctorId: number
    date: Date | string
    time: string
    status?: string
    source?: string
    referenceId?: string | null
    notes?: string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: clinicCreateNestedOneWithoutAppointmentInput
    patient: patientCreateNestedOneWithoutAppointmentInput
  }

  export type appointmentUncheckedCreateInput = {
    id?: number
    clinicId: number
    patientId: number
    doctorId: number
    date: Date | string
    time: string
    status?: string
    source?: string
    referenceId?: string | null
    notes?: string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type appointmentUpdateInput = {
    doctorId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: clinicUpdateOneRequiredWithoutAppointmentNestedInput
    patient?: patientUpdateOneRequiredWithoutAppointmentNestedInput
  }

  export type appointmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type appointmentCreateManyInput = {
    id?: number
    clinicId: number
    patientId: number
    doctorId: number
    date: Date | string
    time: string
    status?: string
    source?: string
    referenceId?: string | null
    notes?: string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type appointmentUpdateManyMutationInput = {
    doctorId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type appointmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditlogCreateInput = {
    action: string
    performedBy: string
    timestamp?: Date | string
    ipAddress?: string | null
    device?: string | null
    details?: string | null
    clinic?: clinicCreateNestedOneWithoutAuditlogInput
    user?: userCreateNestedOneWithoutAuditlogInput
  }

  export type auditlogUncheckedCreateInput = {
    id?: number
    action: string
    performedBy: string
    userId?: number | null
    clinicId?: number | null
    timestamp?: Date | string
    ipAddress?: string | null
    device?: string | null
    details?: string | null
  }

  export type auditlogUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: clinicUpdateOneWithoutAuditlogNestedInput
    user?: userUpdateOneWithoutAuditlogNestedInput
  }

  export type auditlogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    clinicId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditlogCreateManyInput = {
    id?: number
    action: string
    performedBy: string
    userId?: number | null
    clinicId?: number | null
    timestamp?: Date | string
    ipAddress?: string | null
    device?: string | null
    details?: string | null
  }

  export type auditlogUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditlogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    clinicId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clinicCreateInput = {
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentCreateNestedManyWithoutClinicInput
    auditlog?: auditlogCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffCreateNestedManyWithoutClinicInput
    department?: departmentCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateCreateNestedManyWithoutClinicInput
    invoice?: invoiceCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordCreateNestedManyWithoutClinicInput
    notification?: notificationCreateNestedManyWithoutClinicInput
    patient?: patientCreateNestedManyWithoutClinicInput
    formresponse?: formresponseCreateNestedManyWithoutClinicInput
  }

  export type clinicUncheckedCreateInput = {
    id?: number
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentUncheckedCreateNestedManyWithoutClinicInput
    auditlog?: auditlogUncheckedCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffUncheckedCreateNestedManyWithoutClinicInput
    department?: departmentUncheckedCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateUncheckedCreateNestedManyWithoutClinicInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordUncheckedCreateNestedManyWithoutClinicInput
    notification?: notificationUncheckedCreateNestedManyWithoutClinicInput
    patient?: patientUncheckedCreateNestedManyWithoutClinicInput
    formresponse?: formresponseUncheckedCreateNestedManyWithoutClinicInput
  }

  export type clinicUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUpdateManyWithoutClinicNestedInput
    auditlog?: auditlogUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUpdateManyWithoutClinicNestedInput
    department?: departmentUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUpdateManyWithoutClinicNestedInput
    notification?: notificationUpdateManyWithoutClinicNestedInput
    patient?: patientUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUpdateManyWithoutClinicNestedInput
  }

  export type clinicUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUncheckedUpdateManyWithoutClinicNestedInput
    auditlog?: auditlogUncheckedUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUncheckedUpdateManyWithoutClinicNestedInput
    department?: departmentUncheckedUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUncheckedUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUncheckedUpdateManyWithoutClinicNestedInput
    notification?: notificationUncheckedUpdateManyWithoutClinicNestedInput
    patient?: patientUncheckedUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type clinicCreateManyInput = {
    id?: number
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
  }

  export type clinicUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clinicUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clinicstaffCreateInput = {
    role?: $Enums.clinicstaff_role
    createdAt?: Date | string
    department?: string | null
    specialty?: string | null
    clinic: clinicCreateNestedOneWithoutClinicstaffInput
    user: userCreateNestedOneWithoutClinicstaffInput
  }

  export type clinicstaffUncheckedCreateInput = {
    id?: number
    userId: number
    clinicId: number
    role?: $Enums.clinicstaff_role
    createdAt?: Date | string
    department?: string | null
    specialty?: string | null
  }

  export type clinicstaffUpdateInput = {
    role?: Enumclinicstaff_roleFieldUpdateOperationsInput | $Enums.clinicstaff_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: clinicUpdateOneRequiredWithoutClinicstaffNestedInput
    user?: userUpdateOneRequiredWithoutClinicstaffNestedInput
  }

  export type clinicstaffUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    role?: Enumclinicstaff_roleFieldUpdateOperationsInput | $Enums.clinicstaff_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clinicstaffCreateManyInput = {
    id?: number
    userId: number
    clinicId: number
    role?: $Enums.clinicstaff_role
    createdAt?: Date | string
    department?: string | null
    specialty?: string | null
  }

  export type clinicstaffUpdateManyMutationInput = {
    role?: Enumclinicstaff_roleFieldUpdateOperationsInput | $Enums.clinicstaff_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clinicstaffUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    role?: Enumclinicstaff_roleFieldUpdateOperationsInput | $Enums.clinicstaff_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type departmentCreateInput = {
    name: string
    type?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: clinicCreateNestedOneWithoutDepartmentInput
  }

  export type departmentUncheckedCreateInput = {
    id?: number
    clinicId: number
    name: string
    type?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type departmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: clinicUpdateOneRequiredWithoutDepartmentNestedInput
  }

  export type departmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type departmentCreateManyInput = {
    id?: number
    clinicId: number
    name: string
    type?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type departmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type departmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formtemplateCreateInput = {
    name: string
    specialty: string
    status?: string
    version?: number
    fields: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic?: clinicCreateNestedOneWithoutFormtemplateInput
    medicalrecord?: medicalrecordCreateNestedManyWithoutFormtemplateInput
    formresponse?: formresponseCreateNestedManyWithoutFormtemplateInput
  }

  export type formtemplateUncheckedCreateInput = {
    id?: number
    clinicId?: number | null
    name: string
    specialty: string
    status?: string
    version?: number
    fields: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalrecord?: medicalrecordUncheckedCreateNestedManyWithoutFormtemplateInput
    formresponse?: formresponseUncheckedCreateNestedManyWithoutFormtemplateInput
  }

  export type formtemplateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fields?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: clinicUpdateOneWithoutFormtemplateNestedInput
    medicalrecord?: medicalrecordUpdateManyWithoutFormtemplateNestedInput
    formresponse?: formresponseUpdateManyWithoutFormtemplateNestedInput
  }

  export type formtemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fields?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalrecord?: medicalrecordUncheckedUpdateManyWithoutFormtemplateNestedInput
    formresponse?: formresponseUncheckedUpdateManyWithoutFormtemplateNestedInput
  }

  export type formtemplateCreateManyInput = {
    id?: number
    clinicId?: number | null
    name: string
    specialty: string
    status?: string
    version?: number
    fields: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type formtemplateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fields?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formtemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fields?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invoiceCreateInput = {
    id: string
    doctorId?: number | null
    service: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: clinicCreateNestedOneWithoutInvoiceInput
    patient: patientCreateNestedOneWithoutInvoiceInput
  }

  export type invoiceUncheckedCreateInput = {
    id: string
    clinicId: number
    patientId: number
    doctorId?: number | null
    service: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type invoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    service?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: clinicUpdateOneRequiredWithoutInvoiceNestedInput
    patient?: patientUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    service?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invoiceCreateManyInput = {
    id: string
    clinicId: number
    patientId: number
    doctorId?: number | null
    service: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type invoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    service?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    service?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type medicalrecordCreateInput = {
    doctorId: number
    visitDate?: Date | string
    type: string
    data: string
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: clinicCreateNestedOneWithoutMedicalrecordInput
    patient: patientCreateNestedOneWithoutMedicalrecordInput
    formtemplate?: formtemplateCreateNestedOneWithoutMedicalrecordInput
  }

  export type medicalrecordUncheckedCreateInput = {
    id?: number
    clinicId: number
    patientId: number
    doctorId: number
    templateId?: number | null
    visitDate?: Date | string
    type: string
    data: string
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type medicalrecordUpdateInput = {
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: clinicUpdateOneRequiredWithoutMedicalrecordNestedInput
    patient?: patientUpdateOneRequiredWithoutMedicalrecordNestedInput
    formtemplate?: formtemplateUpdateOneWithoutMedicalrecordNestedInput
  }

  export type medicalrecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type medicalrecordCreateManyInput = {
    id?: number
    clinicId: number
    patientId: number
    doctorId: number
    templateId?: number | null
    visitDate?: Date | string
    type: string
    data: string
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type medicalrecordUpdateManyMutationInput = {
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type medicalrecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formresponseCreateInput = {
    doctorId: number
    answers: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    clinic: clinicCreateNestedOneWithoutFormresponseInput
    formtemplate: formtemplateCreateNestedOneWithoutFormresponseInput
    patient: patientCreateNestedOneWithoutFormresponseInput
  }

  export type formresponseUncheckedCreateInput = {
    id?: number
    clinicId: number
    formId: number
    patientId: number
    doctorId: number
    answers: string
    submittedAt?: Date | string
    updatedAt?: Date | string
  }

  export type formresponseUpdateInput = {
    doctorId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: clinicUpdateOneRequiredWithoutFormresponseNestedInput
    formtemplate?: formtemplateUpdateOneRequiredWithoutFormresponseNestedInput
    patient?: patientUpdateOneRequiredWithoutFormresponseNestedInput
  }

  export type formresponseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formresponseCreateManyInput = {
    id?: number
    clinicId: number
    formId: number
    patientId: number
    doctorId: number
    answers: string
    submittedAt?: Date | string
    updatedAt?: Date | string
  }

  export type formresponseUpdateManyMutationInput = {
    doctorId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formresponseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationCreateInput = {
    department: string
    message: string
    status?: string
    createdAt?: Date | string
    clinic: clinicCreateNestedOneWithoutNotificationInput
  }

  export type notificationUncheckedCreateInput = {
    id?: number
    clinicId: number
    department: string
    message: string
    status?: string
    createdAt?: Date | string
  }

  export type notificationUpdateInput = {
    department?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: clinicUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type notificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    department?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationCreateManyInput = {
    id?: number
    clinicId: number
    department: string
    message: string
    status?: string
    createdAt?: Date | string
  }

  export type notificationUpdateManyMutationInput = {
    department?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    department?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type patientCreateInput = {
    mrn?: string | null
    name: string
    age?: number | null
    email?: string | null
    phone: string
    gender?: string | null
    address?: string | null
    medicalHistory?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status?: string
    createdYear?: number | null
    lastVisit?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentCreateNestedManyWithoutPatientInput
    invoice?: invoiceCreateNestedManyWithoutPatientInput
    medicalrecord?: medicalrecordCreateNestedManyWithoutPatientInput
    formresponse?: formresponseCreateNestedManyWithoutPatientInput
    clinic: clinicCreateNestedOneWithoutPatientInput
  }

  export type patientUncheckedCreateInput = {
    id?: number
    clinicId: number
    mrn?: string | null
    name: string
    age?: number | null
    email?: string | null
    phone: string
    gender?: string | null
    address?: string | null
    medicalHistory?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status?: string
    createdYear?: number | null
    lastVisit?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentUncheckedCreateNestedManyWithoutPatientInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutPatientInput
    medicalrecord?: medicalrecordUncheckedCreateNestedManyWithoutPatientInput
    formresponse?: formresponseUncheckedCreateNestedManyWithoutPatientInput
  }

  export type patientUpdateInput = {
    mrn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUpdateManyWithoutPatientNestedInput
    invoice?: invoiceUpdateManyWithoutPatientNestedInput
    medicalrecord?: medicalrecordUpdateManyWithoutPatientNestedInput
    formresponse?: formresponseUpdateManyWithoutPatientNestedInput
    clinic?: clinicUpdateOneRequiredWithoutPatientNestedInput
  }

  export type patientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    mrn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutPatientNestedInput
    medicalrecord?: medicalrecordUncheckedUpdateManyWithoutPatientNestedInput
    formresponse?: formresponseUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type patientCreateManyInput = {
    id?: number
    clinicId: number
    mrn?: string | null
    name: string
    age?: number | null
    email?: string | null
    phone: string
    gender?: string | null
    address?: string | null
    medicalHistory?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status?: string
    createdYear?: number | null
    lastVisit?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type patientUpdateManyMutationInput = {
    mrn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type patientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    mrn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userCreateInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    status?: string
    joined?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    role?: $Enums.user_role
    auditlog?: auditlogCreateNestedManyWithoutUserInput
    clinicstaff?: clinicstaffCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    status?: string
    joined?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    role?: $Enums.user_role
    auditlog?: auditlogUncheckedCreateNestedManyWithoutUserInput
    clinicstaff?: clinicstaffUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    joined?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    auditlog?: auditlogUpdateManyWithoutUserNestedInput
    clinicstaff?: clinicstaffUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    joined?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    auditlog?: auditlogUncheckedUpdateManyWithoutUserNestedInput
    clinicstaff?: clinicstaffUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    status?: string
    joined?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    role?: $Enums.user_role
  }

  export type userUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    joined?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    joined?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ClinicRelationFilter = {
    is?: clinicWhereInput
    isNot?: clinicWhereInput
  }

  export type PatientRelationFilter = {
    is?: patientWhereInput
    isNot?: patientWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type appointmentCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    status?: SortOrder
    source?: SortOrder
    referenceId?: SortOrder
    notes?: SortOrder
    fees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type appointmentAvgOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    fees?: SortOrder
  }

  export type appointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    status?: SortOrder
    source?: SortOrder
    referenceId?: SortOrder
    notes?: SortOrder
    fees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type appointmentMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    date?: SortOrder
    time?: SortOrder
    status?: SortOrder
    source?: SortOrder
    referenceId?: SortOrder
    notes?: SortOrder
    fees?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type appointmentSumOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    fees?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ClinicNullableRelationFilter = {
    is?: clinicWhereInput | null
    isNot?: clinicWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type auditlogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    performedBy?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    device?: SortOrder
    details?: SortOrder
  }

  export type auditlogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
  }

  export type auditlogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    performedBy?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    device?: SortOrder
    details?: SortOrder
  }

  export type auditlogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    performedBy?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    device?: SortOrder
    details?: SortOrder
  }

  export type auditlogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AppointmentListRelationFilter = {
    every?: appointmentWhereInput
    some?: appointmentWhereInput
    none?: appointmentWhereInput
  }

  export type AuditlogListRelationFilter = {
    every?: auditlogWhereInput
    some?: auditlogWhereInput
    none?: auditlogWhereInput
  }

  export type ClinicstaffListRelationFilter = {
    every?: clinicstaffWhereInput
    some?: clinicstaffWhereInput
    none?: clinicstaffWhereInput
  }

  export type DepartmentListRelationFilter = {
    every?: departmentWhereInput
    some?: departmentWhereInput
    none?: departmentWhereInput
  }

  export type FormtemplateListRelationFilter = {
    every?: formtemplateWhereInput
    some?: formtemplateWhereInput
    none?: formtemplateWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: invoiceWhereInput
    some?: invoiceWhereInput
    none?: invoiceWhereInput
  }

  export type MedicalrecordListRelationFilter = {
    every?: medicalrecordWhereInput
    some?: medicalrecordWhereInput
    none?: medicalrecordWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: notificationWhereInput
    some?: notificationWhereInput
    none?: notificationWhereInput
  }

  export type PatientListRelationFilter = {
    every?: patientWhereInput
    some?: patientWhereInput
    none?: patientWhereInput
  }

  export type FormresponseListRelationFilter = {
    every?: formresponseWhereInput
    some?: formresponseWhereInput
    none?: formresponseWhereInput
  }

  export type appointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type auditlogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clinicstaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type departmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type formtemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type invoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type medicalrecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type patientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type formresponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clinicCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    location?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    logo?: SortOrder
    status?: SortOrder
    modules?: SortOrder
    bookingConfig?: SortOrder
    createdDate?: SortOrder
    updatedAt?: SortOrder
  }

  export type clinicAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type clinicMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    location?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    logo?: SortOrder
    status?: SortOrder
    modules?: SortOrder
    bookingConfig?: SortOrder
    createdDate?: SortOrder
    updatedAt?: SortOrder
  }

  export type clinicMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    location?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    logo?: SortOrder
    status?: SortOrder
    modules?: SortOrder
    bookingConfig?: SortOrder
    createdDate?: SortOrder
    updatedAt?: SortOrder
  }

  export type clinicSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumclinicstaff_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.clinicstaff_role | Enumclinicstaff_roleFieldRefInput<$PrismaModel>
    in?: $Enums.clinicstaff_role[]
    notIn?: $Enums.clinicstaff_role[]
    not?: NestedEnumclinicstaff_roleFilter<$PrismaModel> | $Enums.clinicstaff_role
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type clinicstaffUserIdClinicIdRoleCompoundUniqueInput = {
    userId: number
    clinicId: number
    role: $Enums.clinicstaff_role
  }

  export type clinicstaffCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    department?: SortOrder
    specialty?: SortOrder
  }

  export type clinicstaffAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
  }

  export type clinicstaffMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    department?: SortOrder
    specialty?: SortOrder
  }

  export type clinicstaffMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    department?: SortOrder
    specialty?: SortOrder
  }

  export type clinicstaffSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
  }

  export type Enumclinicstaff_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.clinicstaff_role | Enumclinicstaff_roleFieldRefInput<$PrismaModel>
    in?: $Enums.clinicstaff_role[]
    notIn?: $Enums.clinicstaff_role[]
    not?: NestedEnumclinicstaff_roleWithAggregatesFilter<$PrismaModel> | $Enums.clinicstaff_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumclinicstaff_roleFilter<$PrismaModel>
    _max?: NestedEnumclinicstaff_roleFilter<$PrismaModel>
  }

  export type departmentClinicIdNameCompoundUniqueInput = {
    clinicId: number
    name: string
  }

  export type departmentCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type departmentAvgOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
  }

  export type departmentMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type departmentMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type departmentSumOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
  }

  export type formtemplateCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    specialty?: SortOrder
    status?: SortOrder
    version?: SortOrder
    fields?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type formtemplateAvgOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    version?: SortOrder
  }

  export type formtemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    specialty?: SortOrder
    status?: SortOrder
    version?: SortOrder
    fields?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type formtemplateMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    specialty?: SortOrder
    status?: SortOrder
    version?: SortOrder
    fields?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type formtemplateSumOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    version?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type invoiceCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    service?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type invoiceAvgOrderByAggregateInput = {
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    amount?: SortOrder
  }

  export type invoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    service?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type invoiceMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    service?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type invoiceSumOrderByAggregateInput = {
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FormtemplateNullableRelationFilter = {
    is?: formtemplateWhereInput | null
    isNot?: formtemplateWhereInput | null
  }

  export type medicalrecordCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    templateId?: SortOrder
    visitDate?: SortOrder
    type?: SortOrder
    data?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type medicalrecordAvgOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    templateId?: SortOrder
  }

  export type medicalrecordMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    templateId?: SortOrder
    visitDate?: SortOrder
    type?: SortOrder
    data?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type medicalrecordMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    templateId?: SortOrder
    visitDate?: SortOrder
    type?: SortOrder
    data?: SortOrder
    isClosed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type medicalrecordSumOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    templateId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FormtemplateRelationFilter = {
    is?: formtemplateWhereInput
    isNot?: formtemplateWhereInput
  }

  export type formresponseCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    formId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    answers?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type formresponseAvgOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    formId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
  }

  export type formresponseMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    formId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    answers?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type formresponseMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    formId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    answers?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type formresponseSumOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    formId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
  }

  export type notificationCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    department?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type notificationAvgOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
  }

  export type notificationMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    department?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type notificationMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    department?: SortOrder
    message?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type notificationSumOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type patientClinicIdMrnCompoundUniqueInput = {
    clinicId: number
    mrn: string
  }

  export type patientCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    mrn?: SortOrder
    name?: SortOrder
    age?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    medicalHistory?: SortOrder
    allergies?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    status?: SortOrder
    createdYear?: SortOrder
    lastVisit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type patientAvgOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    age?: SortOrder
    createdYear?: SortOrder
  }

  export type patientMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    mrn?: SortOrder
    name?: SortOrder
    age?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    medicalHistory?: SortOrder
    allergies?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    status?: SortOrder
    createdYear?: SortOrder
    lastVisit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type patientMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    mrn?: SortOrder
    name?: SortOrder
    age?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    medicalHistory?: SortOrder
    allergies?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    status?: SortOrder
    createdYear?: SortOrder
    lastVisit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type patientSumOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    age?: SortOrder
    createdYear?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type Enumuser_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[]
    notIn?: $Enums.user_role[]
    not?: NestedEnumuser_roleFilter<$PrismaModel> | $Enums.user_role
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    joined?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockoutUntil?: SortOrder
    role?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
    failedLoginAttempts?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    joined?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockoutUntil?: SortOrder
    role?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    status?: SortOrder
    joined?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    failedLoginAttempts?: SortOrder
    lockoutUntil?: SortOrder
    role?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
    failedLoginAttempts?: SortOrder
  }

  export type Enumuser_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[]
    notIn?: $Enums.user_role[]
    not?: NestedEnumuser_roleWithAggregatesFilter<$PrismaModel> | $Enums.user_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_roleFilter<$PrismaModel>
    _max?: NestedEnumuser_roleFilter<$PrismaModel>
  }

  export type clinicCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<clinicCreateWithoutAppointmentInput, clinicUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: clinicCreateOrConnectWithoutAppointmentInput
    connect?: clinicWhereUniqueInput
  }

  export type patientCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<patientCreateWithoutAppointmentInput, patientUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: patientCreateOrConnectWithoutAppointmentInput
    connect?: patientWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type clinicUpdateOneRequiredWithoutAppointmentNestedInput = {
    create?: XOR<clinicCreateWithoutAppointmentInput, clinicUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: clinicCreateOrConnectWithoutAppointmentInput
    upsert?: clinicUpsertWithoutAppointmentInput
    connect?: clinicWhereUniqueInput
    update?: XOR<XOR<clinicUpdateToOneWithWhereWithoutAppointmentInput, clinicUpdateWithoutAppointmentInput>, clinicUncheckedUpdateWithoutAppointmentInput>
  }

  export type patientUpdateOneRequiredWithoutAppointmentNestedInput = {
    create?: XOR<patientCreateWithoutAppointmentInput, patientUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: patientCreateOrConnectWithoutAppointmentInput
    upsert?: patientUpsertWithoutAppointmentInput
    connect?: patientWhereUniqueInput
    update?: XOR<XOR<patientUpdateToOneWithWhereWithoutAppointmentInput, patientUpdateWithoutAppointmentInput>, patientUncheckedUpdateWithoutAppointmentInput>
  }

  export type clinicCreateNestedOneWithoutAuditlogInput = {
    create?: XOR<clinicCreateWithoutAuditlogInput, clinicUncheckedCreateWithoutAuditlogInput>
    connectOrCreate?: clinicCreateOrConnectWithoutAuditlogInput
    connect?: clinicWhereUniqueInput
  }

  export type userCreateNestedOneWithoutAuditlogInput = {
    create?: XOR<userCreateWithoutAuditlogInput, userUncheckedCreateWithoutAuditlogInput>
    connectOrCreate?: userCreateOrConnectWithoutAuditlogInput
    connect?: userWhereUniqueInput
  }

  export type clinicUpdateOneWithoutAuditlogNestedInput = {
    create?: XOR<clinicCreateWithoutAuditlogInput, clinicUncheckedCreateWithoutAuditlogInput>
    connectOrCreate?: clinicCreateOrConnectWithoutAuditlogInput
    upsert?: clinicUpsertWithoutAuditlogInput
    disconnect?: clinicWhereInput | boolean
    delete?: clinicWhereInput | boolean
    connect?: clinicWhereUniqueInput
    update?: XOR<XOR<clinicUpdateToOneWithWhereWithoutAuditlogInput, clinicUpdateWithoutAuditlogInput>, clinicUncheckedUpdateWithoutAuditlogInput>
  }

  export type userUpdateOneWithoutAuditlogNestedInput = {
    create?: XOR<userCreateWithoutAuditlogInput, userUncheckedCreateWithoutAuditlogInput>
    connectOrCreate?: userCreateOrConnectWithoutAuditlogInput
    upsert?: userUpsertWithoutAuditlogInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutAuditlogInput, userUpdateWithoutAuditlogInput>, userUncheckedUpdateWithoutAuditlogInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type appointmentCreateNestedManyWithoutClinicInput = {
    create?: XOR<appointmentCreateWithoutClinicInput, appointmentUncheckedCreateWithoutClinicInput> | appointmentCreateWithoutClinicInput[] | appointmentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutClinicInput | appointmentCreateOrConnectWithoutClinicInput[]
    createMany?: appointmentCreateManyClinicInputEnvelope
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
  }

  export type auditlogCreateNestedManyWithoutClinicInput = {
    create?: XOR<auditlogCreateWithoutClinicInput, auditlogUncheckedCreateWithoutClinicInput> | auditlogCreateWithoutClinicInput[] | auditlogUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutClinicInput | auditlogCreateOrConnectWithoutClinicInput[]
    createMany?: auditlogCreateManyClinicInputEnvelope
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
  }

  export type clinicstaffCreateNestedManyWithoutClinicInput = {
    create?: XOR<clinicstaffCreateWithoutClinicInput, clinicstaffUncheckedCreateWithoutClinicInput> | clinicstaffCreateWithoutClinicInput[] | clinicstaffUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: clinicstaffCreateOrConnectWithoutClinicInput | clinicstaffCreateOrConnectWithoutClinicInput[]
    createMany?: clinicstaffCreateManyClinicInputEnvelope
    connect?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
  }

  export type departmentCreateNestedManyWithoutClinicInput = {
    create?: XOR<departmentCreateWithoutClinicInput, departmentUncheckedCreateWithoutClinicInput> | departmentCreateWithoutClinicInput[] | departmentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: departmentCreateOrConnectWithoutClinicInput | departmentCreateOrConnectWithoutClinicInput[]
    createMany?: departmentCreateManyClinicInputEnvelope
    connect?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
  }

  export type formtemplateCreateNestedManyWithoutClinicInput = {
    create?: XOR<formtemplateCreateWithoutClinicInput, formtemplateUncheckedCreateWithoutClinicInput> | formtemplateCreateWithoutClinicInput[] | formtemplateUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: formtemplateCreateOrConnectWithoutClinicInput | formtemplateCreateOrConnectWithoutClinicInput[]
    createMany?: formtemplateCreateManyClinicInputEnvelope
    connect?: formtemplateWhereUniqueInput | formtemplateWhereUniqueInput[]
  }

  export type invoiceCreateNestedManyWithoutClinicInput = {
    create?: XOR<invoiceCreateWithoutClinicInput, invoiceUncheckedCreateWithoutClinicInput> | invoiceCreateWithoutClinicInput[] | invoiceUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutClinicInput | invoiceCreateOrConnectWithoutClinicInput[]
    createMany?: invoiceCreateManyClinicInputEnvelope
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
  }

  export type medicalrecordCreateNestedManyWithoutClinicInput = {
    create?: XOR<medicalrecordCreateWithoutClinicInput, medicalrecordUncheckedCreateWithoutClinicInput> | medicalrecordCreateWithoutClinicInput[] | medicalrecordUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: medicalrecordCreateOrConnectWithoutClinicInput | medicalrecordCreateOrConnectWithoutClinicInput[]
    createMany?: medicalrecordCreateManyClinicInputEnvelope
    connect?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
  }

  export type notificationCreateNestedManyWithoutClinicInput = {
    create?: XOR<notificationCreateWithoutClinicInput, notificationUncheckedCreateWithoutClinicInput> | notificationCreateWithoutClinicInput[] | notificationUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutClinicInput | notificationCreateOrConnectWithoutClinicInput[]
    createMany?: notificationCreateManyClinicInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type patientCreateNestedManyWithoutClinicInput = {
    create?: XOR<patientCreateWithoutClinicInput, patientUncheckedCreateWithoutClinicInput> | patientCreateWithoutClinicInput[] | patientUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: patientCreateOrConnectWithoutClinicInput | patientCreateOrConnectWithoutClinicInput[]
    createMany?: patientCreateManyClinicInputEnvelope
    connect?: patientWhereUniqueInput | patientWhereUniqueInput[]
  }

  export type formresponseCreateNestedManyWithoutClinicInput = {
    create?: XOR<formresponseCreateWithoutClinicInput, formresponseUncheckedCreateWithoutClinicInput> | formresponseCreateWithoutClinicInput[] | formresponseUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: formresponseCreateOrConnectWithoutClinicInput | formresponseCreateOrConnectWithoutClinicInput[]
    createMany?: formresponseCreateManyClinicInputEnvelope
    connect?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
  }

  export type appointmentUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<appointmentCreateWithoutClinicInput, appointmentUncheckedCreateWithoutClinicInput> | appointmentCreateWithoutClinicInput[] | appointmentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutClinicInput | appointmentCreateOrConnectWithoutClinicInput[]
    createMany?: appointmentCreateManyClinicInputEnvelope
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
  }

  export type auditlogUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<auditlogCreateWithoutClinicInput, auditlogUncheckedCreateWithoutClinicInput> | auditlogCreateWithoutClinicInput[] | auditlogUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutClinicInput | auditlogCreateOrConnectWithoutClinicInput[]
    createMany?: auditlogCreateManyClinicInputEnvelope
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
  }

  export type clinicstaffUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<clinicstaffCreateWithoutClinicInput, clinicstaffUncheckedCreateWithoutClinicInput> | clinicstaffCreateWithoutClinicInput[] | clinicstaffUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: clinicstaffCreateOrConnectWithoutClinicInput | clinicstaffCreateOrConnectWithoutClinicInput[]
    createMany?: clinicstaffCreateManyClinicInputEnvelope
    connect?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
  }

  export type departmentUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<departmentCreateWithoutClinicInput, departmentUncheckedCreateWithoutClinicInput> | departmentCreateWithoutClinicInput[] | departmentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: departmentCreateOrConnectWithoutClinicInput | departmentCreateOrConnectWithoutClinicInput[]
    createMany?: departmentCreateManyClinicInputEnvelope
    connect?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
  }

  export type formtemplateUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<formtemplateCreateWithoutClinicInput, formtemplateUncheckedCreateWithoutClinicInput> | formtemplateCreateWithoutClinicInput[] | formtemplateUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: formtemplateCreateOrConnectWithoutClinicInput | formtemplateCreateOrConnectWithoutClinicInput[]
    createMany?: formtemplateCreateManyClinicInputEnvelope
    connect?: formtemplateWhereUniqueInput | formtemplateWhereUniqueInput[]
  }

  export type invoiceUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<invoiceCreateWithoutClinicInput, invoiceUncheckedCreateWithoutClinicInput> | invoiceCreateWithoutClinicInput[] | invoiceUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutClinicInput | invoiceCreateOrConnectWithoutClinicInput[]
    createMany?: invoiceCreateManyClinicInputEnvelope
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
  }

  export type medicalrecordUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<medicalrecordCreateWithoutClinicInput, medicalrecordUncheckedCreateWithoutClinicInput> | medicalrecordCreateWithoutClinicInput[] | medicalrecordUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: medicalrecordCreateOrConnectWithoutClinicInput | medicalrecordCreateOrConnectWithoutClinicInput[]
    createMany?: medicalrecordCreateManyClinicInputEnvelope
    connect?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
  }

  export type notificationUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<notificationCreateWithoutClinicInput, notificationUncheckedCreateWithoutClinicInput> | notificationCreateWithoutClinicInput[] | notificationUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutClinicInput | notificationCreateOrConnectWithoutClinicInput[]
    createMany?: notificationCreateManyClinicInputEnvelope
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
  }

  export type patientUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<patientCreateWithoutClinicInput, patientUncheckedCreateWithoutClinicInput> | patientCreateWithoutClinicInput[] | patientUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: patientCreateOrConnectWithoutClinicInput | patientCreateOrConnectWithoutClinicInput[]
    createMany?: patientCreateManyClinicInputEnvelope
    connect?: patientWhereUniqueInput | patientWhereUniqueInput[]
  }

  export type formresponseUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<formresponseCreateWithoutClinicInput, formresponseUncheckedCreateWithoutClinicInput> | formresponseCreateWithoutClinicInput[] | formresponseUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: formresponseCreateOrConnectWithoutClinicInput | formresponseCreateOrConnectWithoutClinicInput[]
    createMany?: formresponseCreateManyClinicInputEnvelope
    connect?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
  }

  export type appointmentUpdateManyWithoutClinicNestedInput = {
    create?: XOR<appointmentCreateWithoutClinicInput, appointmentUncheckedCreateWithoutClinicInput> | appointmentCreateWithoutClinicInput[] | appointmentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutClinicInput | appointmentCreateOrConnectWithoutClinicInput[]
    upsert?: appointmentUpsertWithWhereUniqueWithoutClinicInput | appointmentUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: appointmentCreateManyClinicInputEnvelope
    set?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    disconnect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    delete?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    update?: appointmentUpdateWithWhereUniqueWithoutClinicInput | appointmentUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: appointmentUpdateManyWithWhereWithoutClinicInput | appointmentUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: appointmentScalarWhereInput | appointmentScalarWhereInput[]
  }

  export type auditlogUpdateManyWithoutClinicNestedInput = {
    create?: XOR<auditlogCreateWithoutClinicInput, auditlogUncheckedCreateWithoutClinicInput> | auditlogCreateWithoutClinicInput[] | auditlogUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutClinicInput | auditlogCreateOrConnectWithoutClinicInput[]
    upsert?: auditlogUpsertWithWhereUniqueWithoutClinicInput | auditlogUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: auditlogCreateManyClinicInputEnvelope
    set?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    disconnect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    delete?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    update?: auditlogUpdateWithWhereUniqueWithoutClinicInput | auditlogUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: auditlogUpdateManyWithWhereWithoutClinicInput | auditlogUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: auditlogScalarWhereInput | auditlogScalarWhereInput[]
  }

  export type clinicstaffUpdateManyWithoutClinicNestedInput = {
    create?: XOR<clinicstaffCreateWithoutClinicInput, clinicstaffUncheckedCreateWithoutClinicInput> | clinicstaffCreateWithoutClinicInput[] | clinicstaffUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: clinicstaffCreateOrConnectWithoutClinicInput | clinicstaffCreateOrConnectWithoutClinicInput[]
    upsert?: clinicstaffUpsertWithWhereUniqueWithoutClinicInput | clinicstaffUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: clinicstaffCreateManyClinicInputEnvelope
    set?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
    disconnect?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
    delete?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
    connect?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
    update?: clinicstaffUpdateWithWhereUniqueWithoutClinicInput | clinicstaffUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: clinicstaffUpdateManyWithWhereWithoutClinicInput | clinicstaffUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: clinicstaffScalarWhereInput | clinicstaffScalarWhereInput[]
  }

  export type departmentUpdateManyWithoutClinicNestedInput = {
    create?: XOR<departmentCreateWithoutClinicInput, departmentUncheckedCreateWithoutClinicInput> | departmentCreateWithoutClinicInput[] | departmentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: departmentCreateOrConnectWithoutClinicInput | departmentCreateOrConnectWithoutClinicInput[]
    upsert?: departmentUpsertWithWhereUniqueWithoutClinicInput | departmentUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: departmentCreateManyClinicInputEnvelope
    set?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    disconnect?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    delete?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    connect?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    update?: departmentUpdateWithWhereUniqueWithoutClinicInput | departmentUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: departmentUpdateManyWithWhereWithoutClinicInput | departmentUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: departmentScalarWhereInput | departmentScalarWhereInput[]
  }

  export type formtemplateUpdateManyWithoutClinicNestedInput = {
    create?: XOR<formtemplateCreateWithoutClinicInput, formtemplateUncheckedCreateWithoutClinicInput> | formtemplateCreateWithoutClinicInput[] | formtemplateUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: formtemplateCreateOrConnectWithoutClinicInput | formtemplateCreateOrConnectWithoutClinicInput[]
    upsert?: formtemplateUpsertWithWhereUniqueWithoutClinicInput | formtemplateUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: formtemplateCreateManyClinicInputEnvelope
    set?: formtemplateWhereUniqueInput | formtemplateWhereUniqueInput[]
    disconnect?: formtemplateWhereUniqueInput | formtemplateWhereUniqueInput[]
    delete?: formtemplateWhereUniqueInput | formtemplateWhereUniqueInput[]
    connect?: formtemplateWhereUniqueInput | formtemplateWhereUniqueInput[]
    update?: formtemplateUpdateWithWhereUniqueWithoutClinicInput | formtemplateUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: formtemplateUpdateManyWithWhereWithoutClinicInput | formtemplateUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: formtemplateScalarWhereInput | formtemplateScalarWhereInput[]
  }

  export type invoiceUpdateManyWithoutClinicNestedInput = {
    create?: XOR<invoiceCreateWithoutClinicInput, invoiceUncheckedCreateWithoutClinicInput> | invoiceCreateWithoutClinicInput[] | invoiceUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutClinicInput | invoiceCreateOrConnectWithoutClinicInput[]
    upsert?: invoiceUpsertWithWhereUniqueWithoutClinicInput | invoiceUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: invoiceCreateManyClinicInputEnvelope
    set?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    disconnect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    delete?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    update?: invoiceUpdateWithWhereUniqueWithoutClinicInput | invoiceUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: invoiceUpdateManyWithWhereWithoutClinicInput | invoiceUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: invoiceScalarWhereInput | invoiceScalarWhereInput[]
  }

  export type medicalrecordUpdateManyWithoutClinicNestedInput = {
    create?: XOR<medicalrecordCreateWithoutClinicInput, medicalrecordUncheckedCreateWithoutClinicInput> | medicalrecordCreateWithoutClinicInput[] | medicalrecordUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: medicalrecordCreateOrConnectWithoutClinicInput | medicalrecordCreateOrConnectWithoutClinicInput[]
    upsert?: medicalrecordUpsertWithWhereUniqueWithoutClinicInput | medicalrecordUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: medicalrecordCreateManyClinicInputEnvelope
    set?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    disconnect?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    delete?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    connect?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    update?: medicalrecordUpdateWithWhereUniqueWithoutClinicInput | medicalrecordUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: medicalrecordUpdateManyWithWhereWithoutClinicInput | medicalrecordUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: medicalrecordScalarWhereInput | medicalrecordScalarWhereInput[]
  }

  export type notificationUpdateManyWithoutClinicNestedInput = {
    create?: XOR<notificationCreateWithoutClinicInput, notificationUncheckedCreateWithoutClinicInput> | notificationCreateWithoutClinicInput[] | notificationUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutClinicInput | notificationCreateOrConnectWithoutClinicInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutClinicInput | notificationUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: notificationCreateManyClinicInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutClinicInput | notificationUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutClinicInput | notificationUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type patientUpdateManyWithoutClinicNestedInput = {
    create?: XOR<patientCreateWithoutClinicInput, patientUncheckedCreateWithoutClinicInput> | patientCreateWithoutClinicInput[] | patientUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: patientCreateOrConnectWithoutClinicInput | patientCreateOrConnectWithoutClinicInput[]
    upsert?: patientUpsertWithWhereUniqueWithoutClinicInput | patientUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: patientCreateManyClinicInputEnvelope
    set?: patientWhereUniqueInput | patientWhereUniqueInput[]
    disconnect?: patientWhereUniqueInput | patientWhereUniqueInput[]
    delete?: patientWhereUniqueInput | patientWhereUniqueInput[]
    connect?: patientWhereUniqueInput | patientWhereUniqueInput[]
    update?: patientUpdateWithWhereUniqueWithoutClinicInput | patientUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: patientUpdateManyWithWhereWithoutClinicInput | patientUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: patientScalarWhereInput | patientScalarWhereInput[]
  }

  export type formresponseUpdateManyWithoutClinicNestedInput = {
    create?: XOR<formresponseCreateWithoutClinicInput, formresponseUncheckedCreateWithoutClinicInput> | formresponseCreateWithoutClinicInput[] | formresponseUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: formresponseCreateOrConnectWithoutClinicInput | formresponseCreateOrConnectWithoutClinicInput[]
    upsert?: formresponseUpsertWithWhereUniqueWithoutClinicInput | formresponseUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: formresponseCreateManyClinicInputEnvelope
    set?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    disconnect?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    delete?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    connect?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    update?: formresponseUpdateWithWhereUniqueWithoutClinicInput | formresponseUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: formresponseUpdateManyWithWhereWithoutClinicInput | formresponseUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: formresponseScalarWhereInput | formresponseScalarWhereInput[]
  }

  export type appointmentUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<appointmentCreateWithoutClinicInput, appointmentUncheckedCreateWithoutClinicInput> | appointmentCreateWithoutClinicInput[] | appointmentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutClinicInput | appointmentCreateOrConnectWithoutClinicInput[]
    upsert?: appointmentUpsertWithWhereUniqueWithoutClinicInput | appointmentUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: appointmentCreateManyClinicInputEnvelope
    set?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    disconnect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    delete?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    update?: appointmentUpdateWithWhereUniqueWithoutClinicInput | appointmentUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: appointmentUpdateManyWithWhereWithoutClinicInput | appointmentUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: appointmentScalarWhereInput | appointmentScalarWhereInput[]
  }

  export type auditlogUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<auditlogCreateWithoutClinicInput, auditlogUncheckedCreateWithoutClinicInput> | auditlogCreateWithoutClinicInput[] | auditlogUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutClinicInput | auditlogCreateOrConnectWithoutClinicInput[]
    upsert?: auditlogUpsertWithWhereUniqueWithoutClinicInput | auditlogUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: auditlogCreateManyClinicInputEnvelope
    set?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    disconnect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    delete?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    update?: auditlogUpdateWithWhereUniqueWithoutClinicInput | auditlogUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: auditlogUpdateManyWithWhereWithoutClinicInput | auditlogUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: auditlogScalarWhereInput | auditlogScalarWhereInput[]
  }

  export type clinicstaffUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<clinicstaffCreateWithoutClinicInput, clinicstaffUncheckedCreateWithoutClinicInput> | clinicstaffCreateWithoutClinicInput[] | clinicstaffUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: clinicstaffCreateOrConnectWithoutClinicInput | clinicstaffCreateOrConnectWithoutClinicInput[]
    upsert?: clinicstaffUpsertWithWhereUniqueWithoutClinicInput | clinicstaffUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: clinicstaffCreateManyClinicInputEnvelope
    set?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
    disconnect?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
    delete?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
    connect?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
    update?: clinicstaffUpdateWithWhereUniqueWithoutClinicInput | clinicstaffUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: clinicstaffUpdateManyWithWhereWithoutClinicInput | clinicstaffUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: clinicstaffScalarWhereInput | clinicstaffScalarWhereInput[]
  }

  export type departmentUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<departmentCreateWithoutClinicInput, departmentUncheckedCreateWithoutClinicInput> | departmentCreateWithoutClinicInput[] | departmentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: departmentCreateOrConnectWithoutClinicInput | departmentCreateOrConnectWithoutClinicInput[]
    upsert?: departmentUpsertWithWhereUniqueWithoutClinicInput | departmentUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: departmentCreateManyClinicInputEnvelope
    set?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    disconnect?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    delete?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    connect?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    update?: departmentUpdateWithWhereUniqueWithoutClinicInput | departmentUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: departmentUpdateManyWithWhereWithoutClinicInput | departmentUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: departmentScalarWhereInput | departmentScalarWhereInput[]
  }

  export type formtemplateUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<formtemplateCreateWithoutClinicInput, formtemplateUncheckedCreateWithoutClinicInput> | formtemplateCreateWithoutClinicInput[] | formtemplateUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: formtemplateCreateOrConnectWithoutClinicInput | formtemplateCreateOrConnectWithoutClinicInput[]
    upsert?: formtemplateUpsertWithWhereUniqueWithoutClinicInput | formtemplateUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: formtemplateCreateManyClinicInputEnvelope
    set?: formtemplateWhereUniqueInput | formtemplateWhereUniqueInput[]
    disconnect?: formtemplateWhereUniqueInput | formtemplateWhereUniqueInput[]
    delete?: formtemplateWhereUniqueInput | formtemplateWhereUniqueInput[]
    connect?: formtemplateWhereUniqueInput | formtemplateWhereUniqueInput[]
    update?: formtemplateUpdateWithWhereUniqueWithoutClinicInput | formtemplateUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: formtemplateUpdateManyWithWhereWithoutClinicInput | formtemplateUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: formtemplateScalarWhereInput | formtemplateScalarWhereInput[]
  }

  export type invoiceUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<invoiceCreateWithoutClinicInput, invoiceUncheckedCreateWithoutClinicInput> | invoiceCreateWithoutClinicInput[] | invoiceUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutClinicInput | invoiceCreateOrConnectWithoutClinicInput[]
    upsert?: invoiceUpsertWithWhereUniqueWithoutClinicInput | invoiceUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: invoiceCreateManyClinicInputEnvelope
    set?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    disconnect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    delete?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    update?: invoiceUpdateWithWhereUniqueWithoutClinicInput | invoiceUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: invoiceUpdateManyWithWhereWithoutClinicInput | invoiceUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: invoiceScalarWhereInput | invoiceScalarWhereInput[]
  }

  export type medicalrecordUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<medicalrecordCreateWithoutClinicInput, medicalrecordUncheckedCreateWithoutClinicInput> | medicalrecordCreateWithoutClinicInput[] | medicalrecordUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: medicalrecordCreateOrConnectWithoutClinicInput | medicalrecordCreateOrConnectWithoutClinicInput[]
    upsert?: medicalrecordUpsertWithWhereUniqueWithoutClinicInput | medicalrecordUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: medicalrecordCreateManyClinicInputEnvelope
    set?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    disconnect?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    delete?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    connect?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    update?: medicalrecordUpdateWithWhereUniqueWithoutClinicInput | medicalrecordUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: medicalrecordUpdateManyWithWhereWithoutClinicInput | medicalrecordUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: medicalrecordScalarWhereInput | medicalrecordScalarWhereInput[]
  }

  export type notificationUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<notificationCreateWithoutClinicInput, notificationUncheckedCreateWithoutClinicInput> | notificationCreateWithoutClinicInput[] | notificationUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: notificationCreateOrConnectWithoutClinicInput | notificationCreateOrConnectWithoutClinicInput[]
    upsert?: notificationUpsertWithWhereUniqueWithoutClinicInput | notificationUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: notificationCreateManyClinicInputEnvelope
    set?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    disconnect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    delete?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    connect?: notificationWhereUniqueInput | notificationWhereUniqueInput[]
    update?: notificationUpdateWithWhereUniqueWithoutClinicInput | notificationUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: notificationUpdateManyWithWhereWithoutClinicInput | notificationUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: notificationScalarWhereInput | notificationScalarWhereInput[]
  }

  export type patientUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<patientCreateWithoutClinicInput, patientUncheckedCreateWithoutClinicInput> | patientCreateWithoutClinicInput[] | patientUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: patientCreateOrConnectWithoutClinicInput | patientCreateOrConnectWithoutClinicInput[]
    upsert?: patientUpsertWithWhereUniqueWithoutClinicInput | patientUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: patientCreateManyClinicInputEnvelope
    set?: patientWhereUniqueInput | patientWhereUniqueInput[]
    disconnect?: patientWhereUniqueInput | patientWhereUniqueInput[]
    delete?: patientWhereUniqueInput | patientWhereUniqueInput[]
    connect?: patientWhereUniqueInput | patientWhereUniqueInput[]
    update?: patientUpdateWithWhereUniqueWithoutClinicInput | patientUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: patientUpdateManyWithWhereWithoutClinicInput | patientUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: patientScalarWhereInput | patientScalarWhereInput[]
  }

  export type formresponseUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<formresponseCreateWithoutClinicInput, formresponseUncheckedCreateWithoutClinicInput> | formresponseCreateWithoutClinicInput[] | formresponseUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: formresponseCreateOrConnectWithoutClinicInput | formresponseCreateOrConnectWithoutClinicInput[]
    upsert?: formresponseUpsertWithWhereUniqueWithoutClinicInput | formresponseUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: formresponseCreateManyClinicInputEnvelope
    set?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    disconnect?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    delete?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    connect?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    update?: formresponseUpdateWithWhereUniqueWithoutClinicInput | formresponseUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: formresponseUpdateManyWithWhereWithoutClinicInput | formresponseUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: formresponseScalarWhereInput | formresponseScalarWhereInput[]
  }

  export type clinicCreateNestedOneWithoutClinicstaffInput = {
    create?: XOR<clinicCreateWithoutClinicstaffInput, clinicUncheckedCreateWithoutClinicstaffInput>
    connectOrCreate?: clinicCreateOrConnectWithoutClinicstaffInput
    connect?: clinicWhereUniqueInput
  }

  export type userCreateNestedOneWithoutClinicstaffInput = {
    create?: XOR<userCreateWithoutClinicstaffInput, userUncheckedCreateWithoutClinicstaffInput>
    connectOrCreate?: userCreateOrConnectWithoutClinicstaffInput
    connect?: userWhereUniqueInput
  }

  export type Enumclinicstaff_roleFieldUpdateOperationsInput = {
    set?: $Enums.clinicstaff_role
  }

  export type clinicUpdateOneRequiredWithoutClinicstaffNestedInput = {
    create?: XOR<clinicCreateWithoutClinicstaffInput, clinicUncheckedCreateWithoutClinicstaffInput>
    connectOrCreate?: clinicCreateOrConnectWithoutClinicstaffInput
    upsert?: clinicUpsertWithoutClinicstaffInput
    connect?: clinicWhereUniqueInput
    update?: XOR<XOR<clinicUpdateToOneWithWhereWithoutClinicstaffInput, clinicUpdateWithoutClinicstaffInput>, clinicUncheckedUpdateWithoutClinicstaffInput>
  }

  export type userUpdateOneRequiredWithoutClinicstaffNestedInput = {
    create?: XOR<userCreateWithoutClinicstaffInput, userUncheckedCreateWithoutClinicstaffInput>
    connectOrCreate?: userCreateOrConnectWithoutClinicstaffInput
    upsert?: userUpsertWithoutClinicstaffInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutClinicstaffInput, userUpdateWithoutClinicstaffInput>, userUncheckedUpdateWithoutClinicstaffInput>
  }

  export type clinicCreateNestedOneWithoutDepartmentInput = {
    create?: XOR<clinicCreateWithoutDepartmentInput, clinicUncheckedCreateWithoutDepartmentInput>
    connectOrCreate?: clinicCreateOrConnectWithoutDepartmentInput
    connect?: clinicWhereUniqueInput
  }

  export type clinicUpdateOneRequiredWithoutDepartmentNestedInput = {
    create?: XOR<clinicCreateWithoutDepartmentInput, clinicUncheckedCreateWithoutDepartmentInput>
    connectOrCreate?: clinicCreateOrConnectWithoutDepartmentInput
    upsert?: clinicUpsertWithoutDepartmentInput
    connect?: clinicWhereUniqueInput
    update?: XOR<XOR<clinicUpdateToOneWithWhereWithoutDepartmentInput, clinicUpdateWithoutDepartmentInput>, clinicUncheckedUpdateWithoutDepartmentInput>
  }

  export type clinicCreateNestedOneWithoutFormtemplateInput = {
    create?: XOR<clinicCreateWithoutFormtemplateInput, clinicUncheckedCreateWithoutFormtemplateInput>
    connectOrCreate?: clinicCreateOrConnectWithoutFormtemplateInput
    connect?: clinicWhereUniqueInput
  }

  export type medicalrecordCreateNestedManyWithoutFormtemplateInput = {
    create?: XOR<medicalrecordCreateWithoutFormtemplateInput, medicalrecordUncheckedCreateWithoutFormtemplateInput> | medicalrecordCreateWithoutFormtemplateInput[] | medicalrecordUncheckedCreateWithoutFormtemplateInput[]
    connectOrCreate?: medicalrecordCreateOrConnectWithoutFormtemplateInput | medicalrecordCreateOrConnectWithoutFormtemplateInput[]
    createMany?: medicalrecordCreateManyFormtemplateInputEnvelope
    connect?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
  }

  export type formresponseCreateNestedManyWithoutFormtemplateInput = {
    create?: XOR<formresponseCreateWithoutFormtemplateInput, formresponseUncheckedCreateWithoutFormtemplateInput> | formresponseCreateWithoutFormtemplateInput[] | formresponseUncheckedCreateWithoutFormtemplateInput[]
    connectOrCreate?: formresponseCreateOrConnectWithoutFormtemplateInput | formresponseCreateOrConnectWithoutFormtemplateInput[]
    createMany?: formresponseCreateManyFormtemplateInputEnvelope
    connect?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
  }

  export type medicalrecordUncheckedCreateNestedManyWithoutFormtemplateInput = {
    create?: XOR<medicalrecordCreateWithoutFormtemplateInput, medicalrecordUncheckedCreateWithoutFormtemplateInput> | medicalrecordCreateWithoutFormtemplateInput[] | medicalrecordUncheckedCreateWithoutFormtemplateInput[]
    connectOrCreate?: medicalrecordCreateOrConnectWithoutFormtemplateInput | medicalrecordCreateOrConnectWithoutFormtemplateInput[]
    createMany?: medicalrecordCreateManyFormtemplateInputEnvelope
    connect?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
  }

  export type formresponseUncheckedCreateNestedManyWithoutFormtemplateInput = {
    create?: XOR<formresponseCreateWithoutFormtemplateInput, formresponseUncheckedCreateWithoutFormtemplateInput> | formresponseCreateWithoutFormtemplateInput[] | formresponseUncheckedCreateWithoutFormtemplateInput[]
    connectOrCreate?: formresponseCreateOrConnectWithoutFormtemplateInput | formresponseCreateOrConnectWithoutFormtemplateInput[]
    createMany?: formresponseCreateManyFormtemplateInputEnvelope
    connect?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
  }

  export type clinicUpdateOneWithoutFormtemplateNestedInput = {
    create?: XOR<clinicCreateWithoutFormtemplateInput, clinicUncheckedCreateWithoutFormtemplateInput>
    connectOrCreate?: clinicCreateOrConnectWithoutFormtemplateInput
    upsert?: clinicUpsertWithoutFormtemplateInput
    disconnect?: clinicWhereInput | boolean
    delete?: clinicWhereInput | boolean
    connect?: clinicWhereUniqueInput
    update?: XOR<XOR<clinicUpdateToOneWithWhereWithoutFormtemplateInput, clinicUpdateWithoutFormtemplateInput>, clinicUncheckedUpdateWithoutFormtemplateInput>
  }

  export type medicalrecordUpdateManyWithoutFormtemplateNestedInput = {
    create?: XOR<medicalrecordCreateWithoutFormtemplateInput, medicalrecordUncheckedCreateWithoutFormtemplateInput> | medicalrecordCreateWithoutFormtemplateInput[] | medicalrecordUncheckedCreateWithoutFormtemplateInput[]
    connectOrCreate?: medicalrecordCreateOrConnectWithoutFormtemplateInput | medicalrecordCreateOrConnectWithoutFormtemplateInput[]
    upsert?: medicalrecordUpsertWithWhereUniqueWithoutFormtemplateInput | medicalrecordUpsertWithWhereUniqueWithoutFormtemplateInput[]
    createMany?: medicalrecordCreateManyFormtemplateInputEnvelope
    set?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    disconnect?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    delete?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    connect?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    update?: medicalrecordUpdateWithWhereUniqueWithoutFormtemplateInput | medicalrecordUpdateWithWhereUniqueWithoutFormtemplateInput[]
    updateMany?: medicalrecordUpdateManyWithWhereWithoutFormtemplateInput | medicalrecordUpdateManyWithWhereWithoutFormtemplateInput[]
    deleteMany?: medicalrecordScalarWhereInput | medicalrecordScalarWhereInput[]
  }

  export type formresponseUpdateManyWithoutFormtemplateNestedInput = {
    create?: XOR<formresponseCreateWithoutFormtemplateInput, formresponseUncheckedCreateWithoutFormtemplateInput> | formresponseCreateWithoutFormtemplateInput[] | formresponseUncheckedCreateWithoutFormtemplateInput[]
    connectOrCreate?: formresponseCreateOrConnectWithoutFormtemplateInput | formresponseCreateOrConnectWithoutFormtemplateInput[]
    upsert?: formresponseUpsertWithWhereUniqueWithoutFormtemplateInput | formresponseUpsertWithWhereUniqueWithoutFormtemplateInput[]
    createMany?: formresponseCreateManyFormtemplateInputEnvelope
    set?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    disconnect?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    delete?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    connect?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    update?: formresponseUpdateWithWhereUniqueWithoutFormtemplateInput | formresponseUpdateWithWhereUniqueWithoutFormtemplateInput[]
    updateMany?: formresponseUpdateManyWithWhereWithoutFormtemplateInput | formresponseUpdateManyWithWhereWithoutFormtemplateInput[]
    deleteMany?: formresponseScalarWhereInput | formresponseScalarWhereInput[]
  }

  export type medicalrecordUncheckedUpdateManyWithoutFormtemplateNestedInput = {
    create?: XOR<medicalrecordCreateWithoutFormtemplateInput, medicalrecordUncheckedCreateWithoutFormtemplateInput> | medicalrecordCreateWithoutFormtemplateInput[] | medicalrecordUncheckedCreateWithoutFormtemplateInput[]
    connectOrCreate?: medicalrecordCreateOrConnectWithoutFormtemplateInput | medicalrecordCreateOrConnectWithoutFormtemplateInput[]
    upsert?: medicalrecordUpsertWithWhereUniqueWithoutFormtemplateInput | medicalrecordUpsertWithWhereUniqueWithoutFormtemplateInput[]
    createMany?: medicalrecordCreateManyFormtemplateInputEnvelope
    set?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    disconnect?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    delete?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    connect?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    update?: medicalrecordUpdateWithWhereUniqueWithoutFormtemplateInput | medicalrecordUpdateWithWhereUniqueWithoutFormtemplateInput[]
    updateMany?: medicalrecordUpdateManyWithWhereWithoutFormtemplateInput | medicalrecordUpdateManyWithWhereWithoutFormtemplateInput[]
    deleteMany?: medicalrecordScalarWhereInput | medicalrecordScalarWhereInput[]
  }

  export type formresponseUncheckedUpdateManyWithoutFormtemplateNestedInput = {
    create?: XOR<formresponseCreateWithoutFormtemplateInput, formresponseUncheckedCreateWithoutFormtemplateInput> | formresponseCreateWithoutFormtemplateInput[] | formresponseUncheckedCreateWithoutFormtemplateInput[]
    connectOrCreate?: formresponseCreateOrConnectWithoutFormtemplateInput | formresponseCreateOrConnectWithoutFormtemplateInput[]
    upsert?: formresponseUpsertWithWhereUniqueWithoutFormtemplateInput | formresponseUpsertWithWhereUniqueWithoutFormtemplateInput[]
    createMany?: formresponseCreateManyFormtemplateInputEnvelope
    set?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    disconnect?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    delete?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    connect?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    update?: formresponseUpdateWithWhereUniqueWithoutFormtemplateInput | formresponseUpdateWithWhereUniqueWithoutFormtemplateInput[]
    updateMany?: formresponseUpdateManyWithWhereWithoutFormtemplateInput | formresponseUpdateManyWithWhereWithoutFormtemplateInput[]
    deleteMany?: formresponseScalarWhereInput | formresponseScalarWhereInput[]
  }

  export type clinicCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<clinicCreateWithoutInvoiceInput, clinicUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: clinicCreateOrConnectWithoutInvoiceInput
    connect?: clinicWhereUniqueInput
  }

  export type patientCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<patientCreateWithoutInvoiceInput, patientUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: patientCreateOrConnectWithoutInvoiceInput
    connect?: patientWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type clinicUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<clinicCreateWithoutInvoiceInput, clinicUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: clinicCreateOrConnectWithoutInvoiceInput
    upsert?: clinicUpsertWithoutInvoiceInput
    connect?: clinicWhereUniqueInput
    update?: XOR<XOR<clinicUpdateToOneWithWhereWithoutInvoiceInput, clinicUpdateWithoutInvoiceInput>, clinicUncheckedUpdateWithoutInvoiceInput>
  }

  export type patientUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<patientCreateWithoutInvoiceInput, patientUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: patientCreateOrConnectWithoutInvoiceInput
    upsert?: patientUpsertWithoutInvoiceInput
    connect?: patientWhereUniqueInput
    update?: XOR<XOR<patientUpdateToOneWithWhereWithoutInvoiceInput, patientUpdateWithoutInvoiceInput>, patientUncheckedUpdateWithoutInvoiceInput>
  }

  export type clinicCreateNestedOneWithoutMedicalrecordInput = {
    create?: XOR<clinicCreateWithoutMedicalrecordInput, clinicUncheckedCreateWithoutMedicalrecordInput>
    connectOrCreate?: clinicCreateOrConnectWithoutMedicalrecordInput
    connect?: clinicWhereUniqueInput
  }

  export type patientCreateNestedOneWithoutMedicalrecordInput = {
    create?: XOR<patientCreateWithoutMedicalrecordInput, patientUncheckedCreateWithoutMedicalrecordInput>
    connectOrCreate?: patientCreateOrConnectWithoutMedicalrecordInput
    connect?: patientWhereUniqueInput
  }

  export type formtemplateCreateNestedOneWithoutMedicalrecordInput = {
    create?: XOR<formtemplateCreateWithoutMedicalrecordInput, formtemplateUncheckedCreateWithoutMedicalrecordInput>
    connectOrCreate?: formtemplateCreateOrConnectWithoutMedicalrecordInput
    connect?: formtemplateWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type clinicUpdateOneRequiredWithoutMedicalrecordNestedInput = {
    create?: XOR<clinicCreateWithoutMedicalrecordInput, clinicUncheckedCreateWithoutMedicalrecordInput>
    connectOrCreate?: clinicCreateOrConnectWithoutMedicalrecordInput
    upsert?: clinicUpsertWithoutMedicalrecordInput
    connect?: clinicWhereUniqueInput
    update?: XOR<XOR<clinicUpdateToOneWithWhereWithoutMedicalrecordInput, clinicUpdateWithoutMedicalrecordInput>, clinicUncheckedUpdateWithoutMedicalrecordInput>
  }

  export type patientUpdateOneRequiredWithoutMedicalrecordNestedInput = {
    create?: XOR<patientCreateWithoutMedicalrecordInput, patientUncheckedCreateWithoutMedicalrecordInput>
    connectOrCreate?: patientCreateOrConnectWithoutMedicalrecordInput
    upsert?: patientUpsertWithoutMedicalrecordInput
    connect?: patientWhereUniqueInput
    update?: XOR<XOR<patientUpdateToOneWithWhereWithoutMedicalrecordInput, patientUpdateWithoutMedicalrecordInput>, patientUncheckedUpdateWithoutMedicalrecordInput>
  }

  export type formtemplateUpdateOneWithoutMedicalrecordNestedInput = {
    create?: XOR<formtemplateCreateWithoutMedicalrecordInput, formtemplateUncheckedCreateWithoutMedicalrecordInput>
    connectOrCreate?: formtemplateCreateOrConnectWithoutMedicalrecordInput
    upsert?: formtemplateUpsertWithoutMedicalrecordInput
    disconnect?: formtemplateWhereInput | boolean
    delete?: formtemplateWhereInput | boolean
    connect?: formtemplateWhereUniqueInput
    update?: XOR<XOR<formtemplateUpdateToOneWithWhereWithoutMedicalrecordInput, formtemplateUpdateWithoutMedicalrecordInput>, formtemplateUncheckedUpdateWithoutMedicalrecordInput>
  }

  export type clinicCreateNestedOneWithoutFormresponseInput = {
    create?: XOR<clinicCreateWithoutFormresponseInput, clinicUncheckedCreateWithoutFormresponseInput>
    connectOrCreate?: clinicCreateOrConnectWithoutFormresponseInput
    connect?: clinicWhereUniqueInput
  }

  export type formtemplateCreateNestedOneWithoutFormresponseInput = {
    create?: XOR<formtemplateCreateWithoutFormresponseInput, formtemplateUncheckedCreateWithoutFormresponseInput>
    connectOrCreate?: formtemplateCreateOrConnectWithoutFormresponseInput
    connect?: formtemplateWhereUniqueInput
  }

  export type patientCreateNestedOneWithoutFormresponseInput = {
    create?: XOR<patientCreateWithoutFormresponseInput, patientUncheckedCreateWithoutFormresponseInput>
    connectOrCreate?: patientCreateOrConnectWithoutFormresponseInput
    connect?: patientWhereUniqueInput
  }

  export type clinicUpdateOneRequiredWithoutFormresponseNestedInput = {
    create?: XOR<clinicCreateWithoutFormresponseInput, clinicUncheckedCreateWithoutFormresponseInput>
    connectOrCreate?: clinicCreateOrConnectWithoutFormresponseInput
    upsert?: clinicUpsertWithoutFormresponseInput
    connect?: clinicWhereUniqueInput
    update?: XOR<XOR<clinicUpdateToOneWithWhereWithoutFormresponseInput, clinicUpdateWithoutFormresponseInput>, clinicUncheckedUpdateWithoutFormresponseInput>
  }

  export type formtemplateUpdateOneRequiredWithoutFormresponseNestedInput = {
    create?: XOR<formtemplateCreateWithoutFormresponseInput, formtemplateUncheckedCreateWithoutFormresponseInput>
    connectOrCreate?: formtemplateCreateOrConnectWithoutFormresponseInput
    upsert?: formtemplateUpsertWithoutFormresponseInput
    connect?: formtemplateWhereUniqueInput
    update?: XOR<XOR<formtemplateUpdateToOneWithWhereWithoutFormresponseInput, formtemplateUpdateWithoutFormresponseInput>, formtemplateUncheckedUpdateWithoutFormresponseInput>
  }

  export type patientUpdateOneRequiredWithoutFormresponseNestedInput = {
    create?: XOR<patientCreateWithoutFormresponseInput, patientUncheckedCreateWithoutFormresponseInput>
    connectOrCreate?: patientCreateOrConnectWithoutFormresponseInput
    upsert?: patientUpsertWithoutFormresponseInput
    connect?: patientWhereUniqueInput
    update?: XOR<XOR<patientUpdateToOneWithWhereWithoutFormresponseInput, patientUpdateWithoutFormresponseInput>, patientUncheckedUpdateWithoutFormresponseInput>
  }

  export type clinicCreateNestedOneWithoutNotificationInput = {
    create?: XOR<clinicCreateWithoutNotificationInput, clinicUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: clinicCreateOrConnectWithoutNotificationInput
    connect?: clinicWhereUniqueInput
  }

  export type clinicUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<clinicCreateWithoutNotificationInput, clinicUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: clinicCreateOrConnectWithoutNotificationInput
    upsert?: clinicUpsertWithoutNotificationInput
    connect?: clinicWhereUniqueInput
    update?: XOR<XOR<clinicUpdateToOneWithWhereWithoutNotificationInput, clinicUpdateWithoutNotificationInput>, clinicUncheckedUpdateWithoutNotificationInput>
  }

  export type appointmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<appointmentCreateWithoutPatientInput, appointmentUncheckedCreateWithoutPatientInput> | appointmentCreateWithoutPatientInput[] | appointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutPatientInput | appointmentCreateOrConnectWithoutPatientInput[]
    createMany?: appointmentCreateManyPatientInputEnvelope
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
  }

  export type invoiceCreateNestedManyWithoutPatientInput = {
    create?: XOR<invoiceCreateWithoutPatientInput, invoiceUncheckedCreateWithoutPatientInput> | invoiceCreateWithoutPatientInput[] | invoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutPatientInput | invoiceCreateOrConnectWithoutPatientInput[]
    createMany?: invoiceCreateManyPatientInputEnvelope
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
  }

  export type medicalrecordCreateNestedManyWithoutPatientInput = {
    create?: XOR<medicalrecordCreateWithoutPatientInput, medicalrecordUncheckedCreateWithoutPatientInput> | medicalrecordCreateWithoutPatientInput[] | medicalrecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: medicalrecordCreateOrConnectWithoutPatientInput | medicalrecordCreateOrConnectWithoutPatientInput[]
    createMany?: medicalrecordCreateManyPatientInputEnvelope
    connect?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
  }

  export type formresponseCreateNestedManyWithoutPatientInput = {
    create?: XOR<formresponseCreateWithoutPatientInput, formresponseUncheckedCreateWithoutPatientInput> | formresponseCreateWithoutPatientInput[] | formresponseUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: formresponseCreateOrConnectWithoutPatientInput | formresponseCreateOrConnectWithoutPatientInput[]
    createMany?: formresponseCreateManyPatientInputEnvelope
    connect?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
  }

  export type clinicCreateNestedOneWithoutPatientInput = {
    create?: XOR<clinicCreateWithoutPatientInput, clinicUncheckedCreateWithoutPatientInput>
    connectOrCreate?: clinicCreateOrConnectWithoutPatientInput
    connect?: clinicWhereUniqueInput
  }

  export type appointmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<appointmentCreateWithoutPatientInput, appointmentUncheckedCreateWithoutPatientInput> | appointmentCreateWithoutPatientInput[] | appointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutPatientInput | appointmentCreateOrConnectWithoutPatientInput[]
    createMany?: appointmentCreateManyPatientInputEnvelope
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
  }

  export type invoiceUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<invoiceCreateWithoutPatientInput, invoiceUncheckedCreateWithoutPatientInput> | invoiceCreateWithoutPatientInput[] | invoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutPatientInput | invoiceCreateOrConnectWithoutPatientInput[]
    createMany?: invoiceCreateManyPatientInputEnvelope
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
  }

  export type medicalrecordUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<medicalrecordCreateWithoutPatientInput, medicalrecordUncheckedCreateWithoutPatientInput> | medicalrecordCreateWithoutPatientInput[] | medicalrecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: medicalrecordCreateOrConnectWithoutPatientInput | medicalrecordCreateOrConnectWithoutPatientInput[]
    createMany?: medicalrecordCreateManyPatientInputEnvelope
    connect?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
  }

  export type formresponseUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<formresponseCreateWithoutPatientInput, formresponseUncheckedCreateWithoutPatientInput> | formresponseCreateWithoutPatientInput[] | formresponseUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: formresponseCreateOrConnectWithoutPatientInput | formresponseCreateOrConnectWithoutPatientInput[]
    createMany?: formresponseCreateManyPatientInputEnvelope
    connect?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type appointmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<appointmentCreateWithoutPatientInput, appointmentUncheckedCreateWithoutPatientInput> | appointmentCreateWithoutPatientInput[] | appointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutPatientInput | appointmentCreateOrConnectWithoutPatientInput[]
    upsert?: appointmentUpsertWithWhereUniqueWithoutPatientInput | appointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: appointmentCreateManyPatientInputEnvelope
    set?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    disconnect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    delete?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    update?: appointmentUpdateWithWhereUniqueWithoutPatientInput | appointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: appointmentUpdateManyWithWhereWithoutPatientInput | appointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: appointmentScalarWhereInput | appointmentScalarWhereInput[]
  }

  export type invoiceUpdateManyWithoutPatientNestedInput = {
    create?: XOR<invoiceCreateWithoutPatientInput, invoiceUncheckedCreateWithoutPatientInput> | invoiceCreateWithoutPatientInput[] | invoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutPatientInput | invoiceCreateOrConnectWithoutPatientInput[]
    upsert?: invoiceUpsertWithWhereUniqueWithoutPatientInput | invoiceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: invoiceCreateManyPatientInputEnvelope
    set?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    disconnect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    delete?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    update?: invoiceUpdateWithWhereUniqueWithoutPatientInput | invoiceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: invoiceUpdateManyWithWhereWithoutPatientInput | invoiceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: invoiceScalarWhereInput | invoiceScalarWhereInput[]
  }

  export type medicalrecordUpdateManyWithoutPatientNestedInput = {
    create?: XOR<medicalrecordCreateWithoutPatientInput, medicalrecordUncheckedCreateWithoutPatientInput> | medicalrecordCreateWithoutPatientInput[] | medicalrecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: medicalrecordCreateOrConnectWithoutPatientInput | medicalrecordCreateOrConnectWithoutPatientInput[]
    upsert?: medicalrecordUpsertWithWhereUniqueWithoutPatientInput | medicalrecordUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: medicalrecordCreateManyPatientInputEnvelope
    set?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    disconnect?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    delete?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    connect?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    update?: medicalrecordUpdateWithWhereUniqueWithoutPatientInput | medicalrecordUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: medicalrecordUpdateManyWithWhereWithoutPatientInput | medicalrecordUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: medicalrecordScalarWhereInput | medicalrecordScalarWhereInput[]
  }

  export type formresponseUpdateManyWithoutPatientNestedInput = {
    create?: XOR<formresponseCreateWithoutPatientInput, formresponseUncheckedCreateWithoutPatientInput> | formresponseCreateWithoutPatientInput[] | formresponseUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: formresponseCreateOrConnectWithoutPatientInput | formresponseCreateOrConnectWithoutPatientInput[]
    upsert?: formresponseUpsertWithWhereUniqueWithoutPatientInput | formresponseUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: formresponseCreateManyPatientInputEnvelope
    set?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    disconnect?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    delete?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    connect?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    update?: formresponseUpdateWithWhereUniqueWithoutPatientInput | formresponseUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: formresponseUpdateManyWithWhereWithoutPatientInput | formresponseUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: formresponseScalarWhereInput | formresponseScalarWhereInput[]
  }

  export type clinicUpdateOneRequiredWithoutPatientNestedInput = {
    create?: XOR<clinicCreateWithoutPatientInput, clinicUncheckedCreateWithoutPatientInput>
    connectOrCreate?: clinicCreateOrConnectWithoutPatientInput
    upsert?: clinicUpsertWithoutPatientInput
    connect?: clinicWhereUniqueInput
    update?: XOR<XOR<clinicUpdateToOneWithWhereWithoutPatientInput, clinicUpdateWithoutPatientInput>, clinicUncheckedUpdateWithoutPatientInput>
  }

  export type appointmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<appointmentCreateWithoutPatientInput, appointmentUncheckedCreateWithoutPatientInput> | appointmentCreateWithoutPatientInput[] | appointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: appointmentCreateOrConnectWithoutPatientInput | appointmentCreateOrConnectWithoutPatientInput[]
    upsert?: appointmentUpsertWithWhereUniqueWithoutPatientInput | appointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: appointmentCreateManyPatientInputEnvelope
    set?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    disconnect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    delete?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    connect?: appointmentWhereUniqueInput | appointmentWhereUniqueInput[]
    update?: appointmentUpdateWithWhereUniqueWithoutPatientInput | appointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: appointmentUpdateManyWithWhereWithoutPatientInput | appointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: appointmentScalarWhereInput | appointmentScalarWhereInput[]
  }

  export type invoiceUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<invoiceCreateWithoutPatientInput, invoiceUncheckedCreateWithoutPatientInput> | invoiceCreateWithoutPatientInput[] | invoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: invoiceCreateOrConnectWithoutPatientInput | invoiceCreateOrConnectWithoutPatientInput[]
    upsert?: invoiceUpsertWithWhereUniqueWithoutPatientInput | invoiceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: invoiceCreateManyPatientInputEnvelope
    set?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    disconnect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    delete?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    connect?: invoiceWhereUniqueInput | invoiceWhereUniqueInput[]
    update?: invoiceUpdateWithWhereUniqueWithoutPatientInput | invoiceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: invoiceUpdateManyWithWhereWithoutPatientInput | invoiceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: invoiceScalarWhereInput | invoiceScalarWhereInput[]
  }

  export type medicalrecordUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<medicalrecordCreateWithoutPatientInput, medicalrecordUncheckedCreateWithoutPatientInput> | medicalrecordCreateWithoutPatientInput[] | medicalrecordUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: medicalrecordCreateOrConnectWithoutPatientInput | medicalrecordCreateOrConnectWithoutPatientInput[]
    upsert?: medicalrecordUpsertWithWhereUniqueWithoutPatientInput | medicalrecordUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: medicalrecordCreateManyPatientInputEnvelope
    set?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    disconnect?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    delete?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    connect?: medicalrecordWhereUniqueInput | medicalrecordWhereUniqueInput[]
    update?: medicalrecordUpdateWithWhereUniqueWithoutPatientInput | medicalrecordUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: medicalrecordUpdateManyWithWhereWithoutPatientInput | medicalrecordUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: medicalrecordScalarWhereInput | medicalrecordScalarWhereInput[]
  }

  export type formresponseUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<formresponseCreateWithoutPatientInput, formresponseUncheckedCreateWithoutPatientInput> | formresponseCreateWithoutPatientInput[] | formresponseUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: formresponseCreateOrConnectWithoutPatientInput | formresponseCreateOrConnectWithoutPatientInput[]
    upsert?: formresponseUpsertWithWhereUniqueWithoutPatientInput | formresponseUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: formresponseCreateManyPatientInputEnvelope
    set?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    disconnect?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    delete?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    connect?: formresponseWhereUniqueInput | formresponseWhereUniqueInput[]
    update?: formresponseUpdateWithWhereUniqueWithoutPatientInput | formresponseUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: formresponseUpdateManyWithWhereWithoutPatientInput | formresponseUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: formresponseScalarWhereInput | formresponseScalarWhereInput[]
  }

  export type auditlogCreateNestedManyWithoutUserInput = {
    create?: XOR<auditlogCreateWithoutUserInput, auditlogUncheckedCreateWithoutUserInput> | auditlogCreateWithoutUserInput[] | auditlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutUserInput | auditlogCreateOrConnectWithoutUserInput[]
    createMany?: auditlogCreateManyUserInputEnvelope
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
  }

  export type clinicstaffCreateNestedManyWithoutUserInput = {
    create?: XOR<clinicstaffCreateWithoutUserInput, clinicstaffUncheckedCreateWithoutUserInput> | clinicstaffCreateWithoutUserInput[] | clinicstaffUncheckedCreateWithoutUserInput[]
    connectOrCreate?: clinicstaffCreateOrConnectWithoutUserInput | clinicstaffCreateOrConnectWithoutUserInput[]
    createMany?: clinicstaffCreateManyUserInputEnvelope
    connect?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
  }

  export type auditlogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<auditlogCreateWithoutUserInput, auditlogUncheckedCreateWithoutUserInput> | auditlogCreateWithoutUserInput[] | auditlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutUserInput | auditlogCreateOrConnectWithoutUserInput[]
    createMany?: auditlogCreateManyUserInputEnvelope
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
  }

  export type clinicstaffUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<clinicstaffCreateWithoutUserInput, clinicstaffUncheckedCreateWithoutUserInput> | clinicstaffCreateWithoutUserInput[] | clinicstaffUncheckedCreateWithoutUserInput[]
    connectOrCreate?: clinicstaffCreateOrConnectWithoutUserInput | clinicstaffCreateOrConnectWithoutUserInput[]
    createMany?: clinicstaffCreateManyUserInputEnvelope
    connect?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
  }

  export type Enumuser_roleFieldUpdateOperationsInput = {
    set?: $Enums.user_role
  }

  export type auditlogUpdateManyWithoutUserNestedInput = {
    create?: XOR<auditlogCreateWithoutUserInput, auditlogUncheckedCreateWithoutUserInput> | auditlogCreateWithoutUserInput[] | auditlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutUserInput | auditlogCreateOrConnectWithoutUserInput[]
    upsert?: auditlogUpsertWithWhereUniqueWithoutUserInput | auditlogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: auditlogCreateManyUserInputEnvelope
    set?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    disconnect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    delete?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    update?: auditlogUpdateWithWhereUniqueWithoutUserInput | auditlogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: auditlogUpdateManyWithWhereWithoutUserInput | auditlogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: auditlogScalarWhereInput | auditlogScalarWhereInput[]
  }

  export type clinicstaffUpdateManyWithoutUserNestedInput = {
    create?: XOR<clinicstaffCreateWithoutUserInput, clinicstaffUncheckedCreateWithoutUserInput> | clinicstaffCreateWithoutUserInput[] | clinicstaffUncheckedCreateWithoutUserInput[]
    connectOrCreate?: clinicstaffCreateOrConnectWithoutUserInput | clinicstaffCreateOrConnectWithoutUserInput[]
    upsert?: clinicstaffUpsertWithWhereUniqueWithoutUserInput | clinicstaffUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: clinicstaffCreateManyUserInputEnvelope
    set?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
    disconnect?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
    delete?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
    connect?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
    update?: clinicstaffUpdateWithWhereUniqueWithoutUserInput | clinicstaffUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: clinicstaffUpdateManyWithWhereWithoutUserInput | clinicstaffUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: clinicstaffScalarWhereInput | clinicstaffScalarWhereInput[]
  }

  export type auditlogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<auditlogCreateWithoutUserInput, auditlogUncheckedCreateWithoutUserInput> | auditlogCreateWithoutUserInput[] | auditlogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutUserInput | auditlogCreateOrConnectWithoutUserInput[]
    upsert?: auditlogUpsertWithWhereUniqueWithoutUserInput | auditlogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: auditlogCreateManyUserInputEnvelope
    set?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    disconnect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    delete?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    update?: auditlogUpdateWithWhereUniqueWithoutUserInput | auditlogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: auditlogUpdateManyWithWhereWithoutUserInput | auditlogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: auditlogScalarWhereInput | auditlogScalarWhereInput[]
  }

  export type clinicstaffUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<clinicstaffCreateWithoutUserInput, clinicstaffUncheckedCreateWithoutUserInput> | clinicstaffCreateWithoutUserInput[] | clinicstaffUncheckedCreateWithoutUserInput[]
    connectOrCreate?: clinicstaffCreateOrConnectWithoutUserInput | clinicstaffCreateOrConnectWithoutUserInput[]
    upsert?: clinicstaffUpsertWithWhereUniqueWithoutUserInput | clinicstaffUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: clinicstaffCreateManyUserInputEnvelope
    set?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
    disconnect?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
    delete?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
    connect?: clinicstaffWhereUniqueInput | clinicstaffWhereUniqueInput[]
    update?: clinicstaffUpdateWithWhereUniqueWithoutUserInput | clinicstaffUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: clinicstaffUpdateManyWithWhereWithoutUserInput | clinicstaffUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: clinicstaffScalarWhereInput | clinicstaffScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumclinicstaff_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.clinicstaff_role | Enumclinicstaff_roleFieldRefInput<$PrismaModel>
    in?: $Enums.clinicstaff_role[]
    notIn?: $Enums.clinicstaff_role[]
    not?: NestedEnumclinicstaff_roleFilter<$PrismaModel> | $Enums.clinicstaff_role
  }

  export type NestedEnumclinicstaff_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.clinicstaff_role | Enumclinicstaff_roleFieldRefInput<$PrismaModel>
    in?: $Enums.clinicstaff_role[]
    notIn?: $Enums.clinicstaff_role[]
    not?: NestedEnumclinicstaff_roleWithAggregatesFilter<$PrismaModel> | $Enums.clinicstaff_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumclinicstaff_roleFilter<$PrismaModel>
    _max?: NestedEnumclinicstaff_roleFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumuser_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[]
    notIn?: $Enums.user_role[]
    not?: NestedEnumuser_roleFilter<$PrismaModel> | $Enums.user_role
  }

  export type NestedEnumuser_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[]
    notIn?: $Enums.user_role[]
    not?: NestedEnumuser_roleWithAggregatesFilter<$PrismaModel> | $Enums.user_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_roleFilter<$PrismaModel>
    _max?: NestedEnumuser_roleFilter<$PrismaModel>
  }

  export type clinicCreateWithoutAppointmentInput = {
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    auditlog?: auditlogCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffCreateNestedManyWithoutClinicInput
    department?: departmentCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateCreateNestedManyWithoutClinicInput
    invoice?: invoiceCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordCreateNestedManyWithoutClinicInput
    notification?: notificationCreateNestedManyWithoutClinicInput
    patient?: patientCreateNestedManyWithoutClinicInput
    formresponse?: formresponseCreateNestedManyWithoutClinicInput
  }

  export type clinicUncheckedCreateWithoutAppointmentInput = {
    id?: number
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    auditlog?: auditlogUncheckedCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffUncheckedCreateNestedManyWithoutClinicInput
    department?: departmentUncheckedCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateUncheckedCreateNestedManyWithoutClinicInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordUncheckedCreateNestedManyWithoutClinicInput
    notification?: notificationUncheckedCreateNestedManyWithoutClinicInput
    patient?: patientUncheckedCreateNestedManyWithoutClinicInput
    formresponse?: formresponseUncheckedCreateNestedManyWithoutClinicInput
  }

  export type clinicCreateOrConnectWithoutAppointmentInput = {
    where: clinicWhereUniqueInput
    create: XOR<clinicCreateWithoutAppointmentInput, clinicUncheckedCreateWithoutAppointmentInput>
  }

  export type patientCreateWithoutAppointmentInput = {
    mrn?: string | null
    name: string
    age?: number | null
    email?: string | null
    phone: string
    gender?: string | null
    address?: string | null
    medicalHistory?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status?: string
    createdYear?: number | null
    lastVisit?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: invoiceCreateNestedManyWithoutPatientInput
    medicalrecord?: medicalrecordCreateNestedManyWithoutPatientInput
    formresponse?: formresponseCreateNestedManyWithoutPatientInput
    clinic: clinicCreateNestedOneWithoutPatientInput
  }

  export type patientUncheckedCreateWithoutAppointmentInput = {
    id?: number
    clinicId: number
    mrn?: string | null
    name: string
    age?: number | null
    email?: string | null
    phone: string
    gender?: string | null
    address?: string | null
    medicalHistory?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status?: string
    createdYear?: number | null
    lastVisit?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: invoiceUncheckedCreateNestedManyWithoutPatientInput
    medicalrecord?: medicalrecordUncheckedCreateNestedManyWithoutPatientInput
    formresponse?: formresponseUncheckedCreateNestedManyWithoutPatientInput
  }

  export type patientCreateOrConnectWithoutAppointmentInput = {
    where: patientWhereUniqueInput
    create: XOR<patientCreateWithoutAppointmentInput, patientUncheckedCreateWithoutAppointmentInput>
  }

  export type clinicUpsertWithoutAppointmentInput = {
    update: XOR<clinicUpdateWithoutAppointmentInput, clinicUncheckedUpdateWithoutAppointmentInput>
    create: XOR<clinicCreateWithoutAppointmentInput, clinicUncheckedCreateWithoutAppointmentInput>
    where?: clinicWhereInput
  }

  export type clinicUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: clinicWhereInput
    data: XOR<clinicUpdateWithoutAppointmentInput, clinicUncheckedUpdateWithoutAppointmentInput>
  }

  export type clinicUpdateWithoutAppointmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditlog?: auditlogUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUpdateManyWithoutClinicNestedInput
    department?: departmentUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUpdateManyWithoutClinicNestedInput
    notification?: notificationUpdateManyWithoutClinicNestedInput
    patient?: patientUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUpdateManyWithoutClinicNestedInput
  }

  export type clinicUncheckedUpdateWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditlog?: auditlogUncheckedUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUncheckedUpdateManyWithoutClinicNestedInput
    department?: departmentUncheckedUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUncheckedUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUncheckedUpdateManyWithoutClinicNestedInput
    notification?: notificationUncheckedUpdateManyWithoutClinicNestedInput
    patient?: patientUncheckedUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type patientUpsertWithoutAppointmentInput = {
    update: XOR<patientUpdateWithoutAppointmentInput, patientUncheckedUpdateWithoutAppointmentInput>
    create: XOR<patientCreateWithoutAppointmentInput, patientUncheckedCreateWithoutAppointmentInput>
    where?: patientWhereInput
  }

  export type patientUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: patientWhereInput
    data: XOR<patientUpdateWithoutAppointmentInput, patientUncheckedUpdateWithoutAppointmentInput>
  }

  export type patientUpdateWithoutAppointmentInput = {
    mrn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: invoiceUpdateManyWithoutPatientNestedInput
    medicalrecord?: medicalrecordUpdateManyWithoutPatientNestedInput
    formresponse?: formresponseUpdateManyWithoutPatientNestedInput
    clinic?: clinicUpdateOneRequiredWithoutPatientNestedInput
  }

  export type patientUncheckedUpdateWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    mrn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: invoiceUncheckedUpdateManyWithoutPatientNestedInput
    medicalrecord?: medicalrecordUncheckedUpdateManyWithoutPatientNestedInput
    formresponse?: formresponseUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type clinicCreateWithoutAuditlogInput = {
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffCreateNestedManyWithoutClinicInput
    department?: departmentCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateCreateNestedManyWithoutClinicInput
    invoice?: invoiceCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordCreateNestedManyWithoutClinicInput
    notification?: notificationCreateNestedManyWithoutClinicInput
    patient?: patientCreateNestedManyWithoutClinicInput
    formresponse?: formresponseCreateNestedManyWithoutClinicInput
  }

  export type clinicUncheckedCreateWithoutAuditlogInput = {
    id?: number
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentUncheckedCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffUncheckedCreateNestedManyWithoutClinicInput
    department?: departmentUncheckedCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateUncheckedCreateNestedManyWithoutClinicInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordUncheckedCreateNestedManyWithoutClinicInput
    notification?: notificationUncheckedCreateNestedManyWithoutClinicInput
    patient?: patientUncheckedCreateNestedManyWithoutClinicInput
    formresponse?: formresponseUncheckedCreateNestedManyWithoutClinicInput
  }

  export type clinicCreateOrConnectWithoutAuditlogInput = {
    where: clinicWhereUniqueInput
    create: XOR<clinicCreateWithoutAuditlogInput, clinicUncheckedCreateWithoutAuditlogInput>
  }

  export type userCreateWithoutAuditlogInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    status?: string
    joined?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    role?: $Enums.user_role
    clinicstaff?: clinicstaffCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutAuditlogInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    status?: string
    joined?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    role?: $Enums.user_role
    clinicstaff?: clinicstaffUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutAuditlogInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAuditlogInput, userUncheckedCreateWithoutAuditlogInput>
  }

  export type clinicUpsertWithoutAuditlogInput = {
    update: XOR<clinicUpdateWithoutAuditlogInput, clinicUncheckedUpdateWithoutAuditlogInput>
    create: XOR<clinicCreateWithoutAuditlogInput, clinicUncheckedCreateWithoutAuditlogInput>
    where?: clinicWhereInput
  }

  export type clinicUpdateToOneWithWhereWithoutAuditlogInput = {
    where?: clinicWhereInput
    data: XOR<clinicUpdateWithoutAuditlogInput, clinicUncheckedUpdateWithoutAuditlogInput>
  }

  export type clinicUpdateWithoutAuditlogInput = {
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUpdateManyWithoutClinicNestedInput
    department?: departmentUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUpdateManyWithoutClinicNestedInput
    notification?: notificationUpdateManyWithoutClinicNestedInput
    patient?: patientUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUpdateManyWithoutClinicNestedInput
  }

  export type clinicUncheckedUpdateWithoutAuditlogInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUncheckedUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUncheckedUpdateManyWithoutClinicNestedInput
    department?: departmentUncheckedUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUncheckedUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUncheckedUpdateManyWithoutClinicNestedInput
    notification?: notificationUncheckedUpdateManyWithoutClinicNestedInput
    patient?: patientUncheckedUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type userUpsertWithoutAuditlogInput = {
    update: XOR<userUpdateWithoutAuditlogInput, userUncheckedUpdateWithoutAuditlogInput>
    create: XOR<userCreateWithoutAuditlogInput, userUncheckedCreateWithoutAuditlogInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutAuditlogInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutAuditlogInput, userUncheckedUpdateWithoutAuditlogInput>
  }

  export type userUpdateWithoutAuditlogInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    joined?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    clinicstaff?: clinicstaffUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutAuditlogInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    joined?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    clinicstaff?: clinicstaffUncheckedUpdateManyWithoutUserNestedInput
  }

  export type appointmentCreateWithoutClinicInput = {
    doctorId: number
    date: Date | string
    time: string
    status?: string
    source?: string
    referenceId?: string | null
    notes?: string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: patientCreateNestedOneWithoutAppointmentInput
  }

  export type appointmentUncheckedCreateWithoutClinicInput = {
    id?: number
    patientId: number
    doctorId: number
    date: Date | string
    time: string
    status?: string
    source?: string
    referenceId?: string | null
    notes?: string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type appointmentCreateOrConnectWithoutClinicInput = {
    where: appointmentWhereUniqueInput
    create: XOR<appointmentCreateWithoutClinicInput, appointmentUncheckedCreateWithoutClinicInput>
  }

  export type appointmentCreateManyClinicInputEnvelope = {
    data: appointmentCreateManyClinicInput | appointmentCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type auditlogCreateWithoutClinicInput = {
    action: string
    performedBy: string
    timestamp?: Date | string
    ipAddress?: string | null
    device?: string | null
    details?: string | null
    user?: userCreateNestedOneWithoutAuditlogInput
  }

  export type auditlogUncheckedCreateWithoutClinicInput = {
    id?: number
    action: string
    performedBy: string
    userId?: number | null
    timestamp?: Date | string
    ipAddress?: string | null
    device?: string | null
    details?: string | null
  }

  export type auditlogCreateOrConnectWithoutClinicInput = {
    where: auditlogWhereUniqueInput
    create: XOR<auditlogCreateWithoutClinicInput, auditlogUncheckedCreateWithoutClinicInput>
  }

  export type auditlogCreateManyClinicInputEnvelope = {
    data: auditlogCreateManyClinicInput | auditlogCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type clinicstaffCreateWithoutClinicInput = {
    role?: $Enums.clinicstaff_role
    createdAt?: Date | string
    department?: string | null
    specialty?: string | null
    user: userCreateNestedOneWithoutClinicstaffInput
  }

  export type clinicstaffUncheckedCreateWithoutClinicInput = {
    id?: number
    userId: number
    role?: $Enums.clinicstaff_role
    createdAt?: Date | string
    department?: string | null
    specialty?: string | null
  }

  export type clinicstaffCreateOrConnectWithoutClinicInput = {
    where: clinicstaffWhereUniqueInput
    create: XOR<clinicstaffCreateWithoutClinicInput, clinicstaffUncheckedCreateWithoutClinicInput>
  }

  export type clinicstaffCreateManyClinicInputEnvelope = {
    data: clinicstaffCreateManyClinicInput | clinicstaffCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type departmentCreateWithoutClinicInput = {
    name: string
    type?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type departmentUncheckedCreateWithoutClinicInput = {
    id?: number
    name: string
    type?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type departmentCreateOrConnectWithoutClinicInput = {
    where: departmentWhereUniqueInput
    create: XOR<departmentCreateWithoutClinicInput, departmentUncheckedCreateWithoutClinicInput>
  }

  export type departmentCreateManyClinicInputEnvelope = {
    data: departmentCreateManyClinicInput | departmentCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type formtemplateCreateWithoutClinicInput = {
    name: string
    specialty: string
    status?: string
    version?: number
    fields: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalrecord?: medicalrecordCreateNestedManyWithoutFormtemplateInput
    formresponse?: formresponseCreateNestedManyWithoutFormtemplateInput
  }

  export type formtemplateUncheckedCreateWithoutClinicInput = {
    id?: number
    name: string
    specialty: string
    status?: string
    version?: number
    fields: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalrecord?: medicalrecordUncheckedCreateNestedManyWithoutFormtemplateInput
    formresponse?: formresponseUncheckedCreateNestedManyWithoutFormtemplateInput
  }

  export type formtemplateCreateOrConnectWithoutClinicInput = {
    where: formtemplateWhereUniqueInput
    create: XOR<formtemplateCreateWithoutClinicInput, formtemplateUncheckedCreateWithoutClinicInput>
  }

  export type formtemplateCreateManyClinicInputEnvelope = {
    data: formtemplateCreateManyClinicInput | formtemplateCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type invoiceCreateWithoutClinicInput = {
    id: string
    doctorId?: number | null
    service: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: patientCreateNestedOneWithoutInvoiceInput
  }

  export type invoiceUncheckedCreateWithoutClinicInput = {
    id: string
    patientId: number
    doctorId?: number | null
    service: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type invoiceCreateOrConnectWithoutClinicInput = {
    where: invoiceWhereUniqueInput
    create: XOR<invoiceCreateWithoutClinicInput, invoiceUncheckedCreateWithoutClinicInput>
  }

  export type invoiceCreateManyClinicInputEnvelope = {
    data: invoiceCreateManyClinicInput | invoiceCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type medicalrecordCreateWithoutClinicInput = {
    doctorId: number
    visitDate?: Date | string
    type: string
    data: string
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: patientCreateNestedOneWithoutMedicalrecordInput
    formtemplate?: formtemplateCreateNestedOneWithoutMedicalrecordInput
  }

  export type medicalrecordUncheckedCreateWithoutClinicInput = {
    id?: number
    patientId: number
    doctorId: number
    templateId?: number | null
    visitDate?: Date | string
    type: string
    data: string
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type medicalrecordCreateOrConnectWithoutClinicInput = {
    where: medicalrecordWhereUniqueInput
    create: XOR<medicalrecordCreateWithoutClinicInput, medicalrecordUncheckedCreateWithoutClinicInput>
  }

  export type medicalrecordCreateManyClinicInputEnvelope = {
    data: medicalrecordCreateManyClinicInput | medicalrecordCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type notificationCreateWithoutClinicInput = {
    department: string
    message: string
    status?: string
    createdAt?: Date | string
  }

  export type notificationUncheckedCreateWithoutClinicInput = {
    id?: number
    department: string
    message: string
    status?: string
    createdAt?: Date | string
  }

  export type notificationCreateOrConnectWithoutClinicInput = {
    where: notificationWhereUniqueInput
    create: XOR<notificationCreateWithoutClinicInput, notificationUncheckedCreateWithoutClinicInput>
  }

  export type notificationCreateManyClinicInputEnvelope = {
    data: notificationCreateManyClinicInput | notificationCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type patientCreateWithoutClinicInput = {
    mrn?: string | null
    name: string
    age?: number | null
    email?: string | null
    phone: string
    gender?: string | null
    address?: string | null
    medicalHistory?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status?: string
    createdYear?: number | null
    lastVisit?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentCreateNestedManyWithoutPatientInput
    invoice?: invoiceCreateNestedManyWithoutPatientInput
    medicalrecord?: medicalrecordCreateNestedManyWithoutPatientInput
    formresponse?: formresponseCreateNestedManyWithoutPatientInput
  }

  export type patientUncheckedCreateWithoutClinicInput = {
    id?: number
    mrn?: string | null
    name: string
    age?: number | null
    email?: string | null
    phone: string
    gender?: string | null
    address?: string | null
    medicalHistory?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status?: string
    createdYear?: number | null
    lastVisit?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentUncheckedCreateNestedManyWithoutPatientInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutPatientInput
    medicalrecord?: medicalrecordUncheckedCreateNestedManyWithoutPatientInput
    formresponse?: formresponseUncheckedCreateNestedManyWithoutPatientInput
  }

  export type patientCreateOrConnectWithoutClinicInput = {
    where: patientWhereUniqueInput
    create: XOR<patientCreateWithoutClinicInput, patientUncheckedCreateWithoutClinicInput>
  }

  export type patientCreateManyClinicInputEnvelope = {
    data: patientCreateManyClinicInput | patientCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type formresponseCreateWithoutClinicInput = {
    doctorId: number
    answers: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    formtemplate: formtemplateCreateNestedOneWithoutFormresponseInput
    patient: patientCreateNestedOneWithoutFormresponseInput
  }

  export type formresponseUncheckedCreateWithoutClinicInput = {
    id?: number
    formId: number
    patientId: number
    doctorId: number
    answers: string
    submittedAt?: Date | string
    updatedAt?: Date | string
  }

  export type formresponseCreateOrConnectWithoutClinicInput = {
    where: formresponseWhereUniqueInput
    create: XOR<formresponseCreateWithoutClinicInput, formresponseUncheckedCreateWithoutClinicInput>
  }

  export type formresponseCreateManyClinicInputEnvelope = {
    data: formresponseCreateManyClinicInput | formresponseCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type appointmentUpsertWithWhereUniqueWithoutClinicInput = {
    where: appointmentWhereUniqueInput
    update: XOR<appointmentUpdateWithoutClinicInput, appointmentUncheckedUpdateWithoutClinicInput>
    create: XOR<appointmentCreateWithoutClinicInput, appointmentUncheckedCreateWithoutClinicInput>
  }

  export type appointmentUpdateWithWhereUniqueWithoutClinicInput = {
    where: appointmentWhereUniqueInput
    data: XOR<appointmentUpdateWithoutClinicInput, appointmentUncheckedUpdateWithoutClinicInput>
  }

  export type appointmentUpdateManyWithWhereWithoutClinicInput = {
    where: appointmentScalarWhereInput
    data: XOR<appointmentUpdateManyMutationInput, appointmentUncheckedUpdateManyWithoutClinicInput>
  }

  export type appointmentScalarWhereInput = {
    AND?: appointmentScalarWhereInput | appointmentScalarWhereInput[]
    OR?: appointmentScalarWhereInput[]
    NOT?: appointmentScalarWhereInput | appointmentScalarWhereInput[]
    id?: IntFilter<"appointment"> | number
    clinicId?: IntFilter<"appointment"> | number
    patientId?: IntFilter<"appointment"> | number
    doctorId?: IntFilter<"appointment"> | number
    date?: DateTimeFilter<"appointment"> | Date | string
    time?: StringFilter<"appointment"> | string
    status?: StringFilter<"appointment"> | string
    source?: StringFilter<"appointment"> | string
    referenceId?: StringNullableFilter<"appointment"> | string | null
    notes?: StringNullableFilter<"appointment"> | string | null
    fees?: DecimalNullableFilter<"appointment"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"appointment"> | Date | string
    updatedAt?: DateTimeFilter<"appointment"> | Date | string
  }

  export type auditlogUpsertWithWhereUniqueWithoutClinicInput = {
    where: auditlogWhereUniqueInput
    update: XOR<auditlogUpdateWithoutClinicInput, auditlogUncheckedUpdateWithoutClinicInput>
    create: XOR<auditlogCreateWithoutClinicInput, auditlogUncheckedCreateWithoutClinicInput>
  }

  export type auditlogUpdateWithWhereUniqueWithoutClinicInput = {
    where: auditlogWhereUniqueInput
    data: XOR<auditlogUpdateWithoutClinicInput, auditlogUncheckedUpdateWithoutClinicInput>
  }

  export type auditlogUpdateManyWithWhereWithoutClinicInput = {
    where: auditlogScalarWhereInput
    data: XOR<auditlogUpdateManyMutationInput, auditlogUncheckedUpdateManyWithoutClinicInput>
  }

  export type auditlogScalarWhereInput = {
    AND?: auditlogScalarWhereInput | auditlogScalarWhereInput[]
    OR?: auditlogScalarWhereInput[]
    NOT?: auditlogScalarWhereInput | auditlogScalarWhereInput[]
    id?: IntFilter<"auditlog"> | number
    action?: StringFilter<"auditlog"> | string
    performedBy?: StringFilter<"auditlog"> | string
    userId?: IntNullableFilter<"auditlog"> | number | null
    clinicId?: IntNullableFilter<"auditlog"> | number | null
    timestamp?: DateTimeFilter<"auditlog"> | Date | string
    ipAddress?: StringNullableFilter<"auditlog"> | string | null
    device?: StringNullableFilter<"auditlog"> | string | null
    details?: StringNullableFilter<"auditlog"> | string | null
  }

  export type clinicstaffUpsertWithWhereUniqueWithoutClinicInput = {
    where: clinicstaffWhereUniqueInput
    update: XOR<clinicstaffUpdateWithoutClinicInput, clinicstaffUncheckedUpdateWithoutClinicInput>
    create: XOR<clinicstaffCreateWithoutClinicInput, clinicstaffUncheckedCreateWithoutClinicInput>
  }

  export type clinicstaffUpdateWithWhereUniqueWithoutClinicInput = {
    where: clinicstaffWhereUniqueInput
    data: XOR<clinicstaffUpdateWithoutClinicInput, clinicstaffUncheckedUpdateWithoutClinicInput>
  }

  export type clinicstaffUpdateManyWithWhereWithoutClinicInput = {
    where: clinicstaffScalarWhereInput
    data: XOR<clinicstaffUpdateManyMutationInput, clinicstaffUncheckedUpdateManyWithoutClinicInput>
  }

  export type clinicstaffScalarWhereInput = {
    AND?: clinicstaffScalarWhereInput | clinicstaffScalarWhereInput[]
    OR?: clinicstaffScalarWhereInput[]
    NOT?: clinicstaffScalarWhereInput | clinicstaffScalarWhereInput[]
    id?: IntFilter<"clinicstaff"> | number
    userId?: IntFilter<"clinicstaff"> | number
    clinicId?: IntFilter<"clinicstaff"> | number
    role?: Enumclinicstaff_roleFilter<"clinicstaff"> | $Enums.clinicstaff_role
    createdAt?: DateTimeFilter<"clinicstaff"> | Date | string
    department?: StringNullableFilter<"clinicstaff"> | string | null
    specialty?: StringNullableFilter<"clinicstaff"> | string | null
  }

  export type departmentUpsertWithWhereUniqueWithoutClinicInput = {
    where: departmentWhereUniqueInput
    update: XOR<departmentUpdateWithoutClinicInput, departmentUncheckedUpdateWithoutClinicInput>
    create: XOR<departmentCreateWithoutClinicInput, departmentUncheckedCreateWithoutClinicInput>
  }

  export type departmentUpdateWithWhereUniqueWithoutClinicInput = {
    where: departmentWhereUniqueInput
    data: XOR<departmentUpdateWithoutClinicInput, departmentUncheckedUpdateWithoutClinicInput>
  }

  export type departmentUpdateManyWithWhereWithoutClinicInput = {
    where: departmentScalarWhereInput
    data: XOR<departmentUpdateManyMutationInput, departmentUncheckedUpdateManyWithoutClinicInput>
  }

  export type departmentScalarWhereInput = {
    AND?: departmentScalarWhereInput | departmentScalarWhereInput[]
    OR?: departmentScalarWhereInput[]
    NOT?: departmentScalarWhereInput | departmentScalarWhereInput[]
    id?: IntFilter<"department"> | number
    clinicId?: IntFilter<"department"> | number
    name?: StringFilter<"department"> | string
    type?: StringFilter<"department"> | string
    createdAt?: DateTimeFilter<"department"> | Date | string
    updatedAt?: DateTimeFilter<"department"> | Date | string
  }

  export type formtemplateUpsertWithWhereUniqueWithoutClinicInput = {
    where: formtemplateWhereUniqueInput
    update: XOR<formtemplateUpdateWithoutClinicInput, formtemplateUncheckedUpdateWithoutClinicInput>
    create: XOR<formtemplateCreateWithoutClinicInput, formtemplateUncheckedCreateWithoutClinicInput>
  }

  export type formtemplateUpdateWithWhereUniqueWithoutClinicInput = {
    where: formtemplateWhereUniqueInput
    data: XOR<formtemplateUpdateWithoutClinicInput, formtemplateUncheckedUpdateWithoutClinicInput>
  }

  export type formtemplateUpdateManyWithWhereWithoutClinicInput = {
    where: formtemplateScalarWhereInput
    data: XOR<formtemplateUpdateManyMutationInput, formtemplateUncheckedUpdateManyWithoutClinicInput>
  }

  export type formtemplateScalarWhereInput = {
    AND?: formtemplateScalarWhereInput | formtemplateScalarWhereInput[]
    OR?: formtemplateScalarWhereInput[]
    NOT?: formtemplateScalarWhereInput | formtemplateScalarWhereInput[]
    id?: IntFilter<"formtemplate"> | number
    clinicId?: IntNullableFilter<"formtemplate"> | number | null
    name?: StringFilter<"formtemplate"> | string
    specialty?: StringFilter<"formtemplate"> | string
    status?: StringFilter<"formtemplate"> | string
    version?: IntFilter<"formtemplate"> | number
    fields?: StringFilter<"formtemplate"> | string
    createdAt?: DateTimeFilter<"formtemplate"> | Date | string
    updatedAt?: DateTimeFilter<"formtemplate"> | Date | string
  }

  export type invoiceUpsertWithWhereUniqueWithoutClinicInput = {
    where: invoiceWhereUniqueInput
    update: XOR<invoiceUpdateWithoutClinicInput, invoiceUncheckedUpdateWithoutClinicInput>
    create: XOR<invoiceCreateWithoutClinicInput, invoiceUncheckedCreateWithoutClinicInput>
  }

  export type invoiceUpdateWithWhereUniqueWithoutClinicInput = {
    where: invoiceWhereUniqueInput
    data: XOR<invoiceUpdateWithoutClinicInput, invoiceUncheckedUpdateWithoutClinicInput>
  }

  export type invoiceUpdateManyWithWhereWithoutClinicInput = {
    where: invoiceScalarWhereInput
    data: XOR<invoiceUpdateManyMutationInput, invoiceUncheckedUpdateManyWithoutClinicInput>
  }

  export type invoiceScalarWhereInput = {
    AND?: invoiceScalarWhereInput | invoiceScalarWhereInput[]
    OR?: invoiceScalarWhereInput[]
    NOT?: invoiceScalarWhereInput | invoiceScalarWhereInput[]
    id?: StringFilter<"invoice"> | string
    clinicId?: IntFilter<"invoice"> | number
    patientId?: IntFilter<"invoice"> | number
    doctorId?: IntNullableFilter<"invoice"> | number | null
    service?: StringFilter<"invoice"> | string
    amount?: DecimalFilter<"invoice"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"invoice"> | string
    date?: DateTimeFilter<"invoice"> | Date | string
    createdAt?: DateTimeFilter<"invoice"> | Date | string
    updatedAt?: DateTimeFilter<"invoice"> | Date | string
  }

  export type medicalrecordUpsertWithWhereUniqueWithoutClinicInput = {
    where: medicalrecordWhereUniqueInput
    update: XOR<medicalrecordUpdateWithoutClinicInput, medicalrecordUncheckedUpdateWithoutClinicInput>
    create: XOR<medicalrecordCreateWithoutClinicInput, medicalrecordUncheckedCreateWithoutClinicInput>
  }

  export type medicalrecordUpdateWithWhereUniqueWithoutClinicInput = {
    where: medicalrecordWhereUniqueInput
    data: XOR<medicalrecordUpdateWithoutClinicInput, medicalrecordUncheckedUpdateWithoutClinicInput>
  }

  export type medicalrecordUpdateManyWithWhereWithoutClinicInput = {
    where: medicalrecordScalarWhereInput
    data: XOR<medicalrecordUpdateManyMutationInput, medicalrecordUncheckedUpdateManyWithoutClinicInput>
  }

  export type medicalrecordScalarWhereInput = {
    AND?: medicalrecordScalarWhereInput | medicalrecordScalarWhereInput[]
    OR?: medicalrecordScalarWhereInput[]
    NOT?: medicalrecordScalarWhereInput | medicalrecordScalarWhereInput[]
    id?: IntFilter<"medicalrecord"> | number
    clinicId?: IntFilter<"medicalrecord"> | number
    patientId?: IntFilter<"medicalrecord"> | number
    doctorId?: IntFilter<"medicalrecord"> | number
    templateId?: IntNullableFilter<"medicalrecord"> | number | null
    visitDate?: DateTimeFilter<"medicalrecord"> | Date | string
    type?: StringFilter<"medicalrecord"> | string
    data?: StringFilter<"medicalrecord"> | string
    isClosed?: BoolFilter<"medicalrecord"> | boolean
    createdAt?: DateTimeFilter<"medicalrecord"> | Date | string
    updatedAt?: DateTimeFilter<"medicalrecord"> | Date | string
  }

  export type notificationUpsertWithWhereUniqueWithoutClinicInput = {
    where: notificationWhereUniqueInput
    update: XOR<notificationUpdateWithoutClinicInput, notificationUncheckedUpdateWithoutClinicInput>
    create: XOR<notificationCreateWithoutClinicInput, notificationUncheckedCreateWithoutClinicInput>
  }

  export type notificationUpdateWithWhereUniqueWithoutClinicInput = {
    where: notificationWhereUniqueInput
    data: XOR<notificationUpdateWithoutClinicInput, notificationUncheckedUpdateWithoutClinicInput>
  }

  export type notificationUpdateManyWithWhereWithoutClinicInput = {
    where: notificationScalarWhereInput
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyWithoutClinicInput>
  }

  export type notificationScalarWhereInput = {
    AND?: notificationScalarWhereInput | notificationScalarWhereInput[]
    OR?: notificationScalarWhereInput[]
    NOT?: notificationScalarWhereInput | notificationScalarWhereInput[]
    id?: IntFilter<"notification"> | number
    clinicId?: IntFilter<"notification"> | number
    department?: StringFilter<"notification"> | string
    message?: StringFilter<"notification"> | string
    status?: StringFilter<"notification"> | string
    createdAt?: DateTimeFilter<"notification"> | Date | string
  }

  export type patientUpsertWithWhereUniqueWithoutClinicInput = {
    where: patientWhereUniqueInput
    update: XOR<patientUpdateWithoutClinicInput, patientUncheckedUpdateWithoutClinicInput>
    create: XOR<patientCreateWithoutClinicInput, patientUncheckedCreateWithoutClinicInput>
  }

  export type patientUpdateWithWhereUniqueWithoutClinicInput = {
    where: patientWhereUniqueInput
    data: XOR<patientUpdateWithoutClinicInput, patientUncheckedUpdateWithoutClinicInput>
  }

  export type patientUpdateManyWithWhereWithoutClinicInput = {
    where: patientScalarWhereInput
    data: XOR<patientUpdateManyMutationInput, patientUncheckedUpdateManyWithoutClinicInput>
  }

  export type patientScalarWhereInput = {
    AND?: patientScalarWhereInput | patientScalarWhereInput[]
    OR?: patientScalarWhereInput[]
    NOT?: patientScalarWhereInput | patientScalarWhereInput[]
    id?: IntFilter<"patient"> | number
    clinicId?: IntFilter<"patient"> | number
    mrn?: StringNullableFilter<"patient"> | string | null
    name?: StringFilter<"patient"> | string
    age?: IntNullableFilter<"patient"> | number | null
    email?: StringNullableFilter<"patient"> | string | null
    phone?: StringFilter<"patient"> | string
    gender?: StringNullableFilter<"patient"> | string | null
    address?: StringNullableFilter<"patient"> | string | null
    medicalHistory?: StringNullableFilter<"patient"> | string | null
    allergies?: StringNullableFilter<"patient"> | string | null
    emergencyContactName?: StringNullableFilter<"patient"> | string | null
    emergencyContactPhone?: StringNullableFilter<"patient"> | string | null
    status?: StringFilter<"patient"> | string
    createdYear?: IntNullableFilter<"patient"> | number | null
    lastVisit?: DateTimeNullableFilter<"patient"> | Date | string | null
    createdAt?: DateTimeFilter<"patient"> | Date | string
    updatedAt?: DateTimeFilter<"patient"> | Date | string
  }

  export type formresponseUpsertWithWhereUniqueWithoutClinicInput = {
    where: formresponseWhereUniqueInput
    update: XOR<formresponseUpdateWithoutClinicInput, formresponseUncheckedUpdateWithoutClinicInput>
    create: XOR<formresponseCreateWithoutClinicInput, formresponseUncheckedCreateWithoutClinicInput>
  }

  export type formresponseUpdateWithWhereUniqueWithoutClinicInput = {
    where: formresponseWhereUniqueInput
    data: XOR<formresponseUpdateWithoutClinicInput, formresponseUncheckedUpdateWithoutClinicInput>
  }

  export type formresponseUpdateManyWithWhereWithoutClinicInput = {
    where: formresponseScalarWhereInput
    data: XOR<formresponseUpdateManyMutationInput, formresponseUncheckedUpdateManyWithoutClinicInput>
  }

  export type formresponseScalarWhereInput = {
    AND?: formresponseScalarWhereInput | formresponseScalarWhereInput[]
    OR?: formresponseScalarWhereInput[]
    NOT?: formresponseScalarWhereInput | formresponseScalarWhereInput[]
    id?: IntFilter<"formresponse"> | number
    clinicId?: IntFilter<"formresponse"> | number
    formId?: IntFilter<"formresponse"> | number
    patientId?: IntFilter<"formresponse"> | number
    doctorId?: IntFilter<"formresponse"> | number
    answers?: StringFilter<"formresponse"> | string
    submittedAt?: DateTimeFilter<"formresponse"> | Date | string
    updatedAt?: DateTimeFilter<"formresponse"> | Date | string
  }

  export type clinicCreateWithoutClinicstaffInput = {
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentCreateNestedManyWithoutClinicInput
    auditlog?: auditlogCreateNestedManyWithoutClinicInput
    department?: departmentCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateCreateNestedManyWithoutClinicInput
    invoice?: invoiceCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordCreateNestedManyWithoutClinicInput
    notification?: notificationCreateNestedManyWithoutClinicInput
    patient?: patientCreateNestedManyWithoutClinicInput
    formresponse?: formresponseCreateNestedManyWithoutClinicInput
  }

  export type clinicUncheckedCreateWithoutClinicstaffInput = {
    id?: number
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentUncheckedCreateNestedManyWithoutClinicInput
    auditlog?: auditlogUncheckedCreateNestedManyWithoutClinicInput
    department?: departmentUncheckedCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateUncheckedCreateNestedManyWithoutClinicInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordUncheckedCreateNestedManyWithoutClinicInput
    notification?: notificationUncheckedCreateNestedManyWithoutClinicInput
    patient?: patientUncheckedCreateNestedManyWithoutClinicInput
    formresponse?: formresponseUncheckedCreateNestedManyWithoutClinicInput
  }

  export type clinicCreateOrConnectWithoutClinicstaffInput = {
    where: clinicWhereUniqueInput
    create: XOR<clinicCreateWithoutClinicstaffInput, clinicUncheckedCreateWithoutClinicstaffInput>
  }

  export type userCreateWithoutClinicstaffInput = {
    email: string
    password: string
    name: string
    phone?: string | null
    status?: string
    joined?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    role?: $Enums.user_role
    auditlog?: auditlogCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutClinicstaffInput = {
    id?: number
    email: string
    password: string
    name: string
    phone?: string | null
    status?: string
    joined?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    failedLoginAttempts?: number
    lockoutUntil?: Date | string | null
    role?: $Enums.user_role
    auditlog?: auditlogUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutClinicstaffInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutClinicstaffInput, userUncheckedCreateWithoutClinicstaffInput>
  }

  export type clinicUpsertWithoutClinicstaffInput = {
    update: XOR<clinicUpdateWithoutClinicstaffInput, clinicUncheckedUpdateWithoutClinicstaffInput>
    create: XOR<clinicCreateWithoutClinicstaffInput, clinicUncheckedCreateWithoutClinicstaffInput>
    where?: clinicWhereInput
  }

  export type clinicUpdateToOneWithWhereWithoutClinicstaffInput = {
    where?: clinicWhereInput
    data: XOR<clinicUpdateWithoutClinicstaffInput, clinicUncheckedUpdateWithoutClinicstaffInput>
  }

  export type clinicUpdateWithoutClinicstaffInput = {
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUpdateManyWithoutClinicNestedInput
    auditlog?: auditlogUpdateManyWithoutClinicNestedInput
    department?: departmentUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUpdateManyWithoutClinicNestedInput
    notification?: notificationUpdateManyWithoutClinicNestedInput
    patient?: patientUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUpdateManyWithoutClinicNestedInput
  }

  export type clinicUncheckedUpdateWithoutClinicstaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUncheckedUpdateManyWithoutClinicNestedInput
    auditlog?: auditlogUncheckedUpdateManyWithoutClinicNestedInput
    department?: departmentUncheckedUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUncheckedUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUncheckedUpdateManyWithoutClinicNestedInput
    notification?: notificationUncheckedUpdateManyWithoutClinicNestedInput
    patient?: patientUncheckedUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type userUpsertWithoutClinicstaffInput = {
    update: XOR<userUpdateWithoutClinicstaffInput, userUncheckedUpdateWithoutClinicstaffInput>
    create: XOR<userCreateWithoutClinicstaffInput, userUncheckedCreateWithoutClinicstaffInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutClinicstaffInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutClinicstaffInput, userUncheckedUpdateWithoutClinicstaffInput>
  }

  export type userUpdateWithoutClinicstaffInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    joined?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    auditlog?: auditlogUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutClinicstaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    joined?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    failedLoginAttempts?: IntFieldUpdateOperationsInput | number
    lockoutUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    auditlog?: auditlogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type clinicCreateWithoutDepartmentInput = {
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentCreateNestedManyWithoutClinicInput
    auditlog?: auditlogCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateCreateNestedManyWithoutClinicInput
    invoice?: invoiceCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordCreateNestedManyWithoutClinicInput
    notification?: notificationCreateNestedManyWithoutClinicInput
    patient?: patientCreateNestedManyWithoutClinicInput
    formresponse?: formresponseCreateNestedManyWithoutClinicInput
  }

  export type clinicUncheckedCreateWithoutDepartmentInput = {
    id?: number
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentUncheckedCreateNestedManyWithoutClinicInput
    auditlog?: auditlogUncheckedCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffUncheckedCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateUncheckedCreateNestedManyWithoutClinicInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordUncheckedCreateNestedManyWithoutClinicInput
    notification?: notificationUncheckedCreateNestedManyWithoutClinicInput
    patient?: patientUncheckedCreateNestedManyWithoutClinicInput
    formresponse?: formresponseUncheckedCreateNestedManyWithoutClinicInput
  }

  export type clinicCreateOrConnectWithoutDepartmentInput = {
    where: clinicWhereUniqueInput
    create: XOR<clinicCreateWithoutDepartmentInput, clinicUncheckedCreateWithoutDepartmentInput>
  }

  export type clinicUpsertWithoutDepartmentInput = {
    update: XOR<clinicUpdateWithoutDepartmentInput, clinicUncheckedUpdateWithoutDepartmentInput>
    create: XOR<clinicCreateWithoutDepartmentInput, clinicUncheckedCreateWithoutDepartmentInput>
    where?: clinicWhereInput
  }

  export type clinicUpdateToOneWithWhereWithoutDepartmentInput = {
    where?: clinicWhereInput
    data: XOR<clinicUpdateWithoutDepartmentInput, clinicUncheckedUpdateWithoutDepartmentInput>
  }

  export type clinicUpdateWithoutDepartmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUpdateManyWithoutClinicNestedInput
    auditlog?: auditlogUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUpdateManyWithoutClinicNestedInput
    notification?: notificationUpdateManyWithoutClinicNestedInput
    patient?: patientUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUpdateManyWithoutClinicNestedInput
  }

  export type clinicUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUncheckedUpdateManyWithoutClinicNestedInput
    auditlog?: auditlogUncheckedUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUncheckedUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUncheckedUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUncheckedUpdateManyWithoutClinicNestedInput
    notification?: notificationUncheckedUpdateManyWithoutClinicNestedInput
    patient?: patientUncheckedUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type clinicCreateWithoutFormtemplateInput = {
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentCreateNestedManyWithoutClinicInput
    auditlog?: auditlogCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffCreateNestedManyWithoutClinicInput
    department?: departmentCreateNestedManyWithoutClinicInput
    invoice?: invoiceCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordCreateNestedManyWithoutClinicInput
    notification?: notificationCreateNestedManyWithoutClinicInput
    patient?: patientCreateNestedManyWithoutClinicInput
    formresponse?: formresponseCreateNestedManyWithoutClinicInput
  }

  export type clinicUncheckedCreateWithoutFormtemplateInput = {
    id?: number
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentUncheckedCreateNestedManyWithoutClinicInput
    auditlog?: auditlogUncheckedCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffUncheckedCreateNestedManyWithoutClinicInput
    department?: departmentUncheckedCreateNestedManyWithoutClinicInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordUncheckedCreateNestedManyWithoutClinicInput
    notification?: notificationUncheckedCreateNestedManyWithoutClinicInput
    patient?: patientUncheckedCreateNestedManyWithoutClinicInput
    formresponse?: formresponseUncheckedCreateNestedManyWithoutClinicInput
  }

  export type clinicCreateOrConnectWithoutFormtemplateInput = {
    where: clinicWhereUniqueInput
    create: XOR<clinicCreateWithoutFormtemplateInput, clinicUncheckedCreateWithoutFormtemplateInput>
  }

  export type medicalrecordCreateWithoutFormtemplateInput = {
    doctorId: number
    visitDate?: Date | string
    type: string
    data: string
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: clinicCreateNestedOneWithoutMedicalrecordInput
    patient: patientCreateNestedOneWithoutMedicalrecordInput
  }

  export type medicalrecordUncheckedCreateWithoutFormtemplateInput = {
    id?: number
    clinicId: number
    patientId: number
    doctorId: number
    visitDate?: Date | string
    type: string
    data: string
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type medicalrecordCreateOrConnectWithoutFormtemplateInput = {
    where: medicalrecordWhereUniqueInput
    create: XOR<medicalrecordCreateWithoutFormtemplateInput, medicalrecordUncheckedCreateWithoutFormtemplateInput>
  }

  export type medicalrecordCreateManyFormtemplateInputEnvelope = {
    data: medicalrecordCreateManyFormtemplateInput | medicalrecordCreateManyFormtemplateInput[]
    skipDuplicates?: boolean
  }

  export type formresponseCreateWithoutFormtemplateInput = {
    doctorId: number
    answers: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    clinic: clinicCreateNestedOneWithoutFormresponseInput
    patient: patientCreateNestedOneWithoutFormresponseInput
  }

  export type formresponseUncheckedCreateWithoutFormtemplateInput = {
    id?: number
    clinicId: number
    patientId: number
    doctorId: number
    answers: string
    submittedAt?: Date | string
    updatedAt?: Date | string
  }

  export type formresponseCreateOrConnectWithoutFormtemplateInput = {
    where: formresponseWhereUniqueInput
    create: XOR<formresponseCreateWithoutFormtemplateInput, formresponseUncheckedCreateWithoutFormtemplateInput>
  }

  export type formresponseCreateManyFormtemplateInputEnvelope = {
    data: formresponseCreateManyFormtemplateInput | formresponseCreateManyFormtemplateInput[]
    skipDuplicates?: boolean
  }

  export type clinicUpsertWithoutFormtemplateInput = {
    update: XOR<clinicUpdateWithoutFormtemplateInput, clinicUncheckedUpdateWithoutFormtemplateInput>
    create: XOR<clinicCreateWithoutFormtemplateInput, clinicUncheckedCreateWithoutFormtemplateInput>
    where?: clinicWhereInput
  }

  export type clinicUpdateToOneWithWhereWithoutFormtemplateInput = {
    where?: clinicWhereInput
    data: XOR<clinicUpdateWithoutFormtemplateInput, clinicUncheckedUpdateWithoutFormtemplateInput>
  }

  export type clinicUpdateWithoutFormtemplateInput = {
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUpdateManyWithoutClinicNestedInput
    auditlog?: auditlogUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUpdateManyWithoutClinicNestedInput
    department?: departmentUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUpdateManyWithoutClinicNestedInput
    notification?: notificationUpdateManyWithoutClinicNestedInput
    patient?: patientUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUpdateManyWithoutClinicNestedInput
  }

  export type clinicUncheckedUpdateWithoutFormtemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUncheckedUpdateManyWithoutClinicNestedInput
    auditlog?: auditlogUncheckedUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUncheckedUpdateManyWithoutClinicNestedInput
    department?: departmentUncheckedUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUncheckedUpdateManyWithoutClinicNestedInput
    notification?: notificationUncheckedUpdateManyWithoutClinicNestedInput
    patient?: patientUncheckedUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type medicalrecordUpsertWithWhereUniqueWithoutFormtemplateInput = {
    where: medicalrecordWhereUniqueInput
    update: XOR<medicalrecordUpdateWithoutFormtemplateInput, medicalrecordUncheckedUpdateWithoutFormtemplateInput>
    create: XOR<medicalrecordCreateWithoutFormtemplateInput, medicalrecordUncheckedCreateWithoutFormtemplateInput>
  }

  export type medicalrecordUpdateWithWhereUniqueWithoutFormtemplateInput = {
    where: medicalrecordWhereUniqueInput
    data: XOR<medicalrecordUpdateWithoutFormtemplateInput, medicalrecordUncheckedUpdateWithoutFormtemplateInput>
  }

  export type medicalrecordUpdateManyWithWhereWithoutFormtemplateInput = {
    where: medicalrecordScalarWhereInput
    data: XOR<medicalrecordUpdateManyMutationInput, medicalrecordUncheckedUpdateManyWithoutFormtemplateInput>
  }

  export type formresponseUpsertWithWhereUniqueWithoutFormtemplateInput = {
    where: formresponseWhereUniqueInput
    update: XOR<formresponseUpdateWithoutFormtemplateInput, formresponseUncheckedUpdateWithoutFormtemplateInput>
    create: XOR<formresponseCreateWithoutFormtemplateInput, formresponseUncheckedCreateWithoutFormtemplateInput>
  }

  export type formresponseUpdateWithWhereUniqueWithoutFormtemplateInput = {
    where: formresponseWhereUniqueInput
    data: XOR<formresponseUpdateWithoutFormtemplateInput, formresponseUncheckedUpdateWithoutFormtemplateInput>
  }

  export type formresponseUpdateManyWithWhereWithoutFormtemplateInput = {
    where: formresponseScalarWhereInput
    data: XOR<formresponseUpdateManyMutationInput, formresponseUncheckedUpdateManyWithoutFormtemplateInput>
  }

  export type clinicCreateWithoutInvoiceInput = {
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentCreateNestedManyWithoutClinicInput
    auditlog?: auditlogCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffCreateNestedManyWithoutClinicInput
    department?: departmentCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordCreateNestedManyWithoutClinicInput
    notification?: notificationCreateNestedManyWithoutClinicInput
    patient?: patientCreateNestedManyWithoutClinicInput
    formresponse?: formresponseCreateNestedManyWithoutClinicInput
  }

  export type clinicUncheckedCreateWithoutInvoiceInput = {
    id?: number
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentUncheckedCreateNestedManyWithoutClinicInput
    auditlog?: auditlogUncheckedCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffUncheckedCreateNestedManyWithoutClinicInput
    department?: departmentUncheckedCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateUncheckedCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordUncheckedCreateNestedManyWithoutClinicInput
    notification?: notificationUncheckedCreateNestedManyWithoutClinicInput
    patient?: patientUncheckedCreateNestedManyWithoutClinicInput
    formresponse?: formresponseUncheckedCreateNestedManyWithoutClinicInput
  }

  export type clinicCreateOrConnectWithoutInvoiceInput = {
    where: clinicWhereUniqueInput
    create: XOR<clinicCreateWithoutInvoiceInput, clinicUncheckedCreateWithoutInvoiceInput>
  }

  export type patientCreateWithoutInvoiceInput = {
    mrn?: string | null
    name: string
    age?: number | null
    email?: string | null
    phone: string
    gender?: string | null
    address?: string | null
    medicalHistory?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status?: string
    createdYear?: number | null
    lastVisit?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentCreateNestedManyWithoutPatientInput
    medicalrecord?: medicalrecordCreateNestedManyWithoutPatientInput
    formresponse?: formresponseCreateNestedManyWithoutPatientInput
    clinic: clinicCreateNestedOneWithoutPatientInput
  }

  export type patientUncheckedCreateWithoutInvoiceInput = {
    id?: number
    clinicId: number
    mrn?: string | null
    name: string
    age?: number | null
    email?: string | null
    phone: string
    gender?: string | null
    address?: string | null
    medicalHistory?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status?: string
    createdYear?: number | null
    lastVisit?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentUncheckedCreateNestedManyWithoutPatientInput
    medicalrecord?: medicalrecordUncheckedCreateNestedManyWithoutPatientInput
    formresponse?: formresponseUncheckedCreateNestedManyWithoutPatientInput
  }

  export type patientCreateOrConnectWithoutInvoiceInput = {
    where: patientWhereUniqueInput
    create: XOR<patientCreateWithoutInvoiceInput, patientUncheckedCreateWithoutInvoiceInput>
  }

  export type clinicUpsertWithoutInvoiceInput = {
    update: XOR<clinicUpdateWithoutInvoiceInput, clinicUncheckedUpdateWithoutInvoiceInput>
    create: XOR<clinicCreateWithoutInvoiceInput, clinicUncheckedCreateWithoutInvoiceInput>
    where?: clinicWhereInput
  }

  export type clinicUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: clinicWhereInput
    data: XOR<clinicUpdateWithoutInvoiceInput, clinicUncheckedUpdateWithoutInvoiceInput>
  }

  export type clinicUpdateWithoutInvoiceInput = {
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUpdateManyWithoutClinicNestedInput
    auditlog?: auditlogUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUpdateManyWithoutClinicNestedInput
    department?: departmentUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUpdateManyWithoutClinicNestedInput
    notification?: notificationUpdateManyWithoutClinicNestedInput
    patient?: patientUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUpdateManyWithoutClinicNestedInput
  }

  export type clinicUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUncheckedUpdateManyWithoutClinicNestedInput
    auditlog?: auditlogUncheckedUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUncheckedUpdateManyWithoutClinicNestedInput
    department?: departmentUncheckedUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUncheckedUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUncheckedUpdateManyWithoutClinicNestedInput
    notification?: notificationUncheckedUpdateManyWithoutClinicNestedInput
    patient?: patientUncheckedUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type patientUpsertWithoutInvoiceInput = {
    update: XOR<patientUpdateWithoutInvoiceInput, patientUncheckedUpdateWithoutInvoiceInput>
    create: XOR<patientCreateWithoutInvoiceInput, patientUncheckedCreateWithoutInvoiceInput>
    where?: patientWhereInput
  }

  export type patientUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: patientWhereInput
    data: XOR<patientUpdateWithoutInvoiceInput, patientUncheckedUpdateWithoutInvoiceInput>
  }

  export type patientUpdateWithoutInvoiceInput = {
    mrn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUpdateManyWithoutPatientNestedInput
    medicalrecord?: medicalrecordUpdateManyWithoutPatientNestedInput
    formresponse?: formresponseUpdateManyWithoutPatientNestedInput
    clinic?: clinicUpdateOneRequiredWithoutPatientNestedInput
  }

  export type patientUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    mrn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUncheckedUpdateManyWithoutPatientNestedInput
    medicalrecord?: medicalrecordUncheckedUpdateManyWithoutPatientNestedInput
    formresponse?: formresponseUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type clinicCreateWithoutMedicalrecordInput = {
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentCreateNestedManyWithoutClinicInput
    auditlog?: auditlogCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffCreateNestedManyWithoutClinicInput
    department?: departmentCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateCreateNestedManyWithoutClinicInput
    invoice?: invoiceCreateNestedManyWithoutClinicInput
    notification?: notificationCreateNestedManyWithoutClinicInput
    patient?: patientCreateNestedManyWithoutClinicInput
    formresponse?: formresponseCreateNestedManyWithoutClinicInput
  }

  export type clinicUncheckedCreateWithoutMedicalrecordInput = {
    id?: number
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentUncheckedCreateNestedManyWithoutClinicInput
    auditlog?: auditlogUncheckedCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffUncheckedCreateNestedManyWithoutClinicInput
    department?: departmentUncheckedCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateUncheckedCreateNestedManyWithoutClinicInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutClinicInput
    notification?: notificationUncheckedCreateNestedManyWithoutClinicInput
    patient?: patientUncheckedCreateNestedManyWithoutClinicInput
    formresponse?: formresponseUncheckedCreateNestedManyWithoutClinicInput
  }

  export type clinicCreateOrConnectWithoutMedicalrecordInput = {
    where: clinicWhereUniqueInput
    create: XOR<clinicCreateWithoutMedicalrecordInput, clinicUncheckedCreateWithoutMedicalrecordInput>
  }

  export type patientCreateWithoutMedicalrecordInput = {
    mrn?: string | null
    name: string
    age?: number | null
    email?: string | null
    phone: string
    gender?: string | null
    address?: string | null
    medicalHistory?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status?: string
    createdYear?: number | null
    lastVisit?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentCreateNestedManyWithoutPatientInput
    invoice?: invoiceCreateNestedManyWithoutPatientInput
    formresponse?: formresponseCreateNestedManyWithoutPatientInput
    clinic: clinicCreateNestedOneWithoutPatientInput
  }

  export type patientUncheckedCreateWithoutMedicalrecordInput = {
    id?: number
    clinicId: number
    mrn?: string | null
    name: string
    age?: number | null
    email?: string | null
    phone: string
    gender?: string | null
    address?: string | null
    medicalHistory?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status?: string
    createdYear?: number | null
    lastVisit?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentUncheckedCreateNestedManyWithoutPatientInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutPatientInput
    formresponse?: formresponseUncheckedCreateNestedManyWithoutPatientInput
  }

  export type patientCreateOrConnectWithoutMedicalrecordInput = {
    where: patientWhereUniqueInput
    create: XOR<patientCreateWithoutMedicalrecordInput, patientUncheckedCreateWithoutMedicalrecordInput>
  }

  export type formtemplateCreateWithoutMedicalrecordInput = {
    name: string
    specialty: string
    status?: string
    version?: number
    fields: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic?: clinicCreateNestedOneWithoutFormtemplateInput
    formresponse?: formresponseCreateNestedManyWithoutFormtemplateInput
  }

  export type formtemplateUncheckedCreateWithoutMedicalrecordInput = {
    id?: number
    clinicId?: number | null
    name: string
    specialty: string
    status?: string
    version?: number
    fields: string
    createdAt?: Date | string
    updatedAt?: Date | string
    formresponse?: formresponseUncheckedCreateNestedManyWithoutFormtemplateInput
  }

  export type formtemplateCreateOrConnectWithoutMedicalrecordInput = {
    where: formtemplateWhereUniqueInput
    create: XOR<formtemplateCreateWithoutMedicalrecordInput, formtemplateUncheckedCreateWithoutMedicalrecordInput>
  }

  export type clinicUpsertWithoutMedicalrecordInput = {
    update: XOR<clinicUpdateWithoutMedicalrecordInput, clinicUncheckedUpdateWithoutMedicalrecordInput>
    create: XOR<clinicCreateWithoutMedicalrecordInput, clinicUncheckedCreateWithoutMedicalrecordInput>
    where?: clinicWhereInput
  }

  export type clinicUpdateToOneWithWhereWithoutMedicalrecordInput = {
    where?: clinicWhereInput
    data: XOR<clinicUpdateWithoutMedicalrecordInput, clinicUncheckedUpdateWithoutMedicalrecordInput>
  }

  export type clinicUpdateWithoutMedicalrecordInput = {
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUpdateManyWithoutClinicNestedInput
    auditlog?: auditlogUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUpdateManyWithoutClinicNestedInput
    department?: departmentUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUpdateManyWithoutClinicNestedInput
    notification?: notificationUpdateManyWithoutClinicNestedInput
    patient?: patientUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUpdateManyWithoutClinicNestedInput
  }

  export type clinicUncheckedUpdateWithoutMedicalrecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUncheckedUpdateManyWithoutClinicNestedInput
    auditlog?: auditlogUncheckedUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUncheckedUpdateManyWithoutClinicNestedInput
    department?: departmentUncheckedUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUncheckedUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutClinicNestedInput
    notification?: notificationUncheckedUpdateManyWithoutClinicNestedInput
    patient?: patientUncheckedUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type patientUpsertWithoutMedicalrecordInput = {
    update: XOR<patientUpdateWithoutMedicalrecordInput, patientUncheckedUpdateWithoutMedicalrecordInput>
    create: XOR<patientCreateWithoutMedicalrecordInput, patientUncheckedCreateWithoutMedicalrecordInput>
    where?: patientWhereInput
  }

  export type patientUpdateToOneWithWhereWithoutMedicalrecordInput = {
    where?: patientWhereInput
    data: XOR<patientUpdateWithoutMedicalrecordInput, patientUncheckedUpdateWithoutMedicalrecordInput>
  }

  export type patientUpdateWithoutMedicalrecordInput = {
    mrn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUpdateManyWithoutPatientNestedInput
    invoice?: invoiceUpdateManyWithoutPatientNestedInput
    formresponse?: formresponseUpdateManyWithoutPatientNestedInput
    clinic?: clinicUpdateOneRequiredWithoutPatientNestedInput
  }

  export type patientUncheckedUpdateWithoutMedicalrecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    mrn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutPatientNestedInput
    formresponse?: formresponseUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type formtemplateUpsertWithoutMedicalrecordInput = {
    update: XOR<formtemplateUpdateWithoutMedicalrecordInput, formtemplateUncheckedUpdateWithoutMedicalrecordInput>
    create: XOR<formtemplateCreateWithoutMedicalrecordInput, formtemplateUncheckedCreateWithoutMedicalrecordInput>
    where?: formtemplateWhereInput
  }

  export type formtemplateUpdateToOneWithWhereWithoutMedicalrecordInput = {
    where?: formtemplateWhereInput
    data: XOR<formtemplateUpdateWithoutMedicalrecordInput, formtemplateUncheckedUpdateWithoutMedicalrecordInput>
  }

  export type formtemplateUpdateWithoutMedicalrecordInput = {
    name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fields?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: clinicUpdateOneWithoutFormtemplateNestedInput
    formresponse?: formresponseUpdateManyWithoutFormtemplateNestedInput
  }

  export type formtemplateUncheckedUpdateWithoutMedicalrecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fields?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formresponse?: formresponseUncheckedUpdateManyWithoutFormtemplateNestedInput
  }

  export type clinicCreateWithoutFormresponseInput = {
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentCreateNestedManyWithoutClinicInput
    auditlog?: auditlogCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffCreateNestedManyWithoutClinicInput
    department?: departmentCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateCreateNestedManyWithoutClinicInput
    invoice?: invoiceCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordCreateNestedManyWithoutClinicInput
    notification?: notificationCreateNestedManyWithoutClinicInput
    patient?: patientCreateNestedManyWithoutClinicInput
  }

  export type clinicUncheckedCreateWithoutFormresponseInput = {
    id?: number
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentUncheckedCreateNestedManyWithoutClinicInput
    auditlog?: auditlogUncheckedCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffUncheckedCreateNestedManyWithoutClinicInput
    department?: departmentUncheckedCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateUncheckedCreateNestedManyWithoutClinicInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordUncheckedCreateNestedManyWithoutClinicInput
    notification?: notificationUncheckedCreateNestedManyWithoutClinicInput
    patient?: patientUncheckedCreateNestedManyWithoutClinicInput
  }

  export type clinicCreateOrConnectWithoutFormresponseInput = {
    where: clinicWhereUniqueInput
    create: XOR<clinicCreateWithoutFormresponseInput, clinicUncheckedCreateWithoutFormresponseInput>
  }

  export type formtemplateCreateWithoutFormresponseInput = {
    name: string
    specialty: string
    status?: string
    version?: number
    fields: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic?: clinicCreateNestedOneWithoutFormtemplateInput
    medicalrecord?: medicalrecordCreateNestedManyWithoutFormtemplateInput
  }

  export type formtemplateUncheckedCreateWithoutFormresponseInput = {
    id?: number
    clinicId?: number | null
    name: string
    specialty: string
    status?: string
    version?: number
    fields: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalrecord?: medicalrecordUncheckedCreateNestedManyWithoutFormtemplateInput
  }

  export type formtemplateCreateOrConnectWithoutFormresponseInput = {
    where: formtemplateWhereUniqueInput
    create: XOR<formtemplateCreateWithoutFormresponseInput, formtemplateUncheckedCreateWithoutFormresponseInput>
  }

  export type patientCreateWithoutFormresponseInput = {
    mrn?: string | null
    name: string
    age?: number | null
    email?: string | null
    phone: string
    gender?: string | null
    address?: string | null
    medicalHistory?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status?: string
    createdYear?: number | null
    lastVisit?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentCreateNestedManyWithoutPatientInput
    invoice?: invoiceCreateNestedManyWithoutPatientInput
    medicalrecord?: medicalrecordCreateNestedManyWithoutPatientInput
    clinic: clinicCreateNestedOneWithoutPatientInput
  }

  export type patientUncheckedCreateWithoutFormresponseInput = {
    id?: number
    clinicId: number
    mrn?: string | null
    name: string
    age?: number | null
    email?: string | null
    phone: string
    gender?: string | null
    address?: string | null
    medicalHistory?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status?: string
    createdYear?: number | null
    lastVisit?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentUncheckedCreateNestedManyWithoutPatientInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutPatientInput
    medicalrecord?: medicalrecordUncheckedCreateNestedManyWithoutPatientInput
  }

  export type patientCreateOrConnectWithoutFormresponseInput = {
    where: patientWhereUniqueInput
    create: XOR<patientCreateWithoutFormresponseInput, patientUncheckedCreateWithoutFormresponseInput>
  }

  export type clinicUpsertWithoutFormresponseInput = {
    update: XOR<clinicUpdateWithoutFormresponseInput, clinicUncheckedUpdateWithoutFormresponseInput>
    create: XOR<clinicCreateWithoutFormresponseInput, clinicUncheckedCreateWithoutFormresponseInput>
    where?: clinicWhereInput
  }

  export type clinicUpdateToOneWithWhereWithoutFormresponseInput = {
    where?: clinicWhereInput
    data: XOR<clinicUpdateWithoutFormresponseInput, clinicUncheckedUpdateWithoutFormresponseInput>
  }

  export type clinicUpdateWithoutFormresponseInput = {
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUpdateManyWithoutClinicNestedInput
    auditlog?: auditlogUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUpdateManyWithoutClinicNestedInput
    department?: departmentUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUpdateManyWithoutClinicNestedInput
    notification?: notificationUpdateManyWithoutClinicNestedInput
    patient?: patientUpdateManyWithoutClinicNestedInput
  }

  export type clinicUncheckedUpdateWithoutFormresponseInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUncheckedUpdateManyWithoutClinicNestedInput
    auditlog?: auditlogUncheckedUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUncheckedUpdateManyWithoutClinicNestedInput
    department?: departmentUncheckedUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUncheckedUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUncheckedUpdateManyWithoutClinicNestedInput
    notification?: notificationUncheckedUpdateManyWithoutClinicNestedInput
    patient?: patientUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type formtemplateUpsertWithoutFormresponseInput = {
    update: XOR<formtemplateUpdateWithoutFormresponseInput, formtemplateUncheckedUpdateWithoutFormresponseInput>
    create: XOR<formtemplateCreateWithoutFormresponseInput, formtemplateUncheckedCreateWithoutFormresponseInput>
    where?: formtemplateWhereInput
  }

  export type formtemplateUpdateToOneWithWhereWithoutFormresponseInput = {
    where?: formtemplateWhereInput
    data: XOR<formtemplateUpdateWithoutFormresponseInput, formtemplateUncheckedUpdateWithoutFormresponseInput>
  }

  export type formtemplateUpdateWithoutFormresponseInput = {
    name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fields?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: clinicUpdateOneWithoutFormtemplateNestedInput
    medicalrecord?: medicalrecordUpdateManyWithoutFormtemplateNestedInput
  }

  export type formtemplateUncheckedUpdateWithoutFormresponseInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fields?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalrecord?: medicalrecordUncheckedUpdateManyWithoutFormtemplateNestedInput
  }

  export type patientUpsertWithoutFormresponseInput = {
    update: XOR<patientUpdateWithoutFormresponseInput, patientUncheckedUpdateWithoutFormresponseInput>
    create: XOR<patientCreateWithoutFormresponseInput, patientUncheckedCreateWithoutFormresponseInput>
    where?: patientWhereInput
  }

  export type patientUpdateToOneWithWhereWithoutFormresponseInput = {
    where?: patientWhereInput
    data: XOR<patientUpdateWithoutFormresponseInput, patientUncheckedUpdateWithoutFormresponseInput>
  }

  export type patientUpdateWithoutFormresponseInput = {
    mrn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUpdateManyWithoutPatientNestedInput
    invoice?: invoiceUpdateManyWithoutPatientNestedInput
    medicalrecord?: medicalrecordUpdateManyWithoutPatientNestedInput
    clinic?: clinicUpdateOneRequiredWithoutPatientNestedInput
  }

  export type patientUncheckedUpdateWithoutFormresponseInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    mrn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutPatientNestedInput
    medicalrecord?: medicalrecordUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type clinicCreateWithoutNotificationInput = {
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentCreateNestedManyWithoutClinicInput
    auditlog?: auditlogCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffCreateNestedManyWithoutClinicInput
    department?: departmentCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateCreateNestedManyWithoutClinicInput
    invoice?: invoiceCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordCreateNestedManyWithoutClinicInput
    patient?: patientCreateNestedManyWithoutClinicInput
    formresponse?: formresponseCreateNestedManyWithoutClinicInput
  }

  export type clinicUncheckedCreateWithoutNotificationInput = {
    id?: number
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentUncheckedCreateNestedManyWithoutClinicInput
    auditlog?: auditlogUncheckedCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffUncheckedCreateNestedManyWithoutClinicInput
    department?: departmentUncheckedCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateUncheckedCreateNestedManyWithoutClinicInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordUncheckedCreateNestedManyWithoutClinicInput
    patient?: patientUncheckedCreateNestedManyWithoutClinicInput
    formresponse?: formresponseUncheckedCreateNestedManyWithoutClinicInput
  }

  export type clinicCreateOrConnectWithoutNotificationInput = {
    where: clinicWhereUniqueInput
    create: XOR<clinicCreateWithoutNotificationInput, clinicUncheckedCreateWithoutNotificationInput>
  }

  export type clinicUpsertWithoutNotificationInput = {
    update: XOR<clinicUpdateWithoutNotificationInput, clinicUncheckedUpdateWithoutNotificationInput>
    create: XOR<clinicCreateWithoutNotificationInput, clinicUncheckedCreateWithoutNotificationInput>
    where?: clinicWhereInput
  }

  export type clinicUpdateToOneWithWhereWithoutNotificationInput = {
    where?: clinicWhereInput
    data: XOR<clinicUpdateWithoutNotificationInput, clinicUncheckedUpdateWithoutNotificationInput>
  }

  export type clinicUpdateWithoutNotificationInput = {
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUpdateManyWithoutClinicNestedInput
    auditlog?: auditlogUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUpdateManyWithoutClinicNestedInput
    department?: departmentUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUpdateManyWithoutClinicNestedInput
    patient?: patientUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUpdateManyWithoutClinicNestedInput
  }

  export type clinicUncheckedUpdateWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUncheckedUpdateManyWithoutClinicNestedInput
    auditlog?: auditlogUncheckedUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUncheckedUpdateManyWithoutClinicNestedInput
    department?: departmentUncheckedUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUncheckedUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUncheckedUpdateManyWithoutClinicNestedInput
    patient?: patientUncheckedUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type appointmentCreateWithoutPatientInput = {
    doctorId: number
    date: Date | string
    time: string
    status?: string
    source?: string
    referenceId?: string | null
    notes?: string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: clinicCreateNestedOneWithoutAppointmentInput
  }

  export type appointmentUncheckedCreateWithoutPatientInput = {
    id?: number
    clinicId: number
    doctorId: number
    date: Date | string
    time: string
    status?: string
    source?: string
    referenceId?: string | null
    notes?: string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type appointmentCreateOrConnectWithoutPatientInput = {
    where: appointmentWhereUniqueInput
    create: XOR<appointmentCreateWithoutPatientInput, appointmentUncheckedCreateWithoutPatientInput>
  }

  export type appointmentCreateManyPatientInputEnvelope = {
    data: appointmentCreateManyPatientInput | appointmentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type invoiceCreateWithoutPatientInput = {
    id: string
    doctorId?: number | null
    service: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: clinicCreateNestedOneWithoutInvoiceInput
  }

  export type invoiceUncheckedCreateWithoutPatientInput = {
    id: string
    clinicId: number
    doctorId?: number | null
    service: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type invoiceCreateOrConnectWithoutPatientInput = {
    where: invoiceWhereUniqueInput
    create: XOR<invoiceCreateWithoutPatientInput, invoiceUncheckedCreateWithoutPatientInput>
  }

  export type invoiceCreateManyPatientInputEnvelope = {
    data: invoiceCreateManyPatientInput | invoiceCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type medicalrecordCreateWithoutPatientInput = {
    doctorId: number
    visitDate?: Date | string
    type: string
    data: string
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: clinicCreateNestedOneWithoutMedicalrecordInput
    formtemplate?: formtemplateCreateNestedOneWithoutMedicalrecordInput
  }

  export type medicalrecordUncheckedCreateWithoutPatientInput = {
    id?: number
    clinicId: number
    doctorId: number
    templateId?: number | null
    visitDate?: Date | string
    type: string
    data: string
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type medicalrecordCreateOrConnectWithoutPatientInput = {
    where: medicalrecordWhereUniqueInput
    create: XOR<medicalrecordCreateWithoutPatientInput, medicalrecordUncheckedCreateWithoutPatientInput>
  }

  export type medicalrecordCreateManyPatientInputEnvelope = {
    data: medicalrecordCreateManyPatientInput | medicalrecordCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type formresponseCreateWithoutPatientInput = {
    doctorId: number
    answers: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    clinic: clinicCreateNestedOneWithoutFormresponseInput
    formtemplate: formtemplateCreateNestedOneWithoutFormresponseInput
  }

  export type formresponseUncheckedCreateWithoutPatientInput = {
    id?: number
    clinicId: number
    formId: number
    doctorId: number
    answers: string
    submittedAt?: Date | string
    updatedAt?: Date | string
  }

  export type formresponseCreateOrConnectWithoutPatientInput = {
    where: formresponseWhereUniqueInput
    create: XOR<formresponseCreateWithoutPatientInput, formresponseUncheckedCreateWithoutPatientInput>
  }

  export type formresponseCreateManyPatientInputEnvelope = {
    data: formresponseCreateManyPatientInput | formresponseCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type clinicCreateWithoutPatientInput = {
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentCreateNestedManyWithoutClinicInput
    auditlog?: auditlogCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffCreateNestedManyWithoutClinicInput
    department?: departmentCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateCreateNestedManyWithoutClinicInput
    invoice?: invoiceCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordCreateNestedManyWithoutClinicInput
    notification?: notificationCreateNestedManyWithoutClinicInput
    formresponse?: formresponseCreateNestedManyWithoutClinicInput
  }

  export type clinicUncheckedCreateWithoutPatientInput = {
    id?: number
    name: string
    subdomain: string
    location: string
    contact: string
    email: string
    logo?: string | null
    status?: string
    modules?: string | null
    bookingConfig?: string | null
    createdDate?: Date | string
    updatedAt?: Date | string
    appointment?: appointmentUncheckedCreateNestedManyWithoutClinicInput
    auditlog?: auditlogUncheckedCreateNestedManyWithoutClinicInput
    clinicstaff?: clinicstaffUncheckedCreateNestedManyWithoutClinicInput
    department?: departmentUncheckedCreateNestedManyWithoutClinicInput
    formtemplate?: formtemplateUncheckedCreateNestedManyWithoutClinicInput
    invoice?: invoiceUncheckedCreateNestedManyWithoutClinicInput
    medicalrecord?: medicalrecordUncheckedCreateNestedManyWithoutClinicInput
    notification?: notificationUncheckedCreateNestedManyWithoutClinicInput
    formresponse?: formresponseUncheckedCreateNestedManyWithoutClinicInput
  }

  export type clinicCreateOrConnectWithoutPatientInput = {
    where: clinicWhereUniqueInput
    create: XOR<clinicCreateWithoutPatientInput, clinicUncheckedCreateWithoutPatientInput>
  }

  export type appointmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: appointmentWhereUniqueInput
    update: XOR<appointmentUpdateWithoutPatientInput, appointmentUncheckedUpdateWithoutPatientInput>
    create: XOR<appointmentCreateWithoutPatientInput, appointmentUncheckedCreateWithoutPatientInput>
  }

  export type appointmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: appointmentWhereUniqueInput
    data: XOR<appointmentUpdateWithoutPatientInput, appointmentUncheckedUpdateWithoutPatientInput>
  }

  export type appointmentUpdateManyWithWhereWithoutPatientInput = {
    where: appointmentScalarWhereInput
    data: XOR<appointmentUpdateManyMutationInput, appointmentUncheckedUpdateManyWithoutPatientInput>
  }

  export type invoiceUpsertWithWhereUniqueWithoutPatientInput = {
    where: invoiceWhereUniqueInput
    update: XOR<invoiceUpdateWithoutPatientInput, invoiceUncheckedUpdateWithoutPatientInput>
    create: XOR<invoiceCreateWithoutPatientInput, invoiceUncheckedCreateWithoutPatientInput>
  }

  export type invoiceUpdateWithWhereUniqueWithoutPatientInput = {
    where: invoiceWhereUniqueInput
    data: XOR<invoiceUpdateWithoutPatientInput, invoiceUncheckedUpdateWithoutPatientInput>
  }

  export type invoiceUpdateManyWithWhereWithoutPatientInput = {
    where: invoiceScalarWhereInput
    data: XOR<invoiceUpdateManyMutationInput, invoiceUncheckedUpdateManyWithoutPatientInput>
  }

  export type medicalrecordUpsertWithWhereUniqueWithoutPatientInput = {
    where: medicalrecordWhereUniqueInput
    update: XOR<medicalrecordUpdateWithoutPatientInput, medicalrecordUncheckedUpdateWithoutPatientInput>
    create: XOR<medicalrecordCreateWithoutPatientInput, medicalrecordUncheckedCreateWithoutPatientInput>
  }

  export type medicalrecordUpdateWithWhereUniqueWithoutPatientInput = {
    where: medicalrecordWhereUniqueInput
    data: XOR<medicalrecordUpdateWithoutPatientInput, medicalrecordUncheckedUpdateWithoutPatientInput>
  }

  export type medicalrecordUpdateManyWithWhereWithoutPatientInput = {
    where: medicalrecordScalarWhereInput
    data: XOR<medicalrecordUpdateManyMutationInput, medicalrecordUncheckedUpdateManyWithoutPatientInput>
  }

  export type formresponseUpsertWithWhereUniqueWithoutPatientInput = {
    where: formresponseWhereUniqueInput
    update: XOR<formresponseUpdateWithoutPatientInput, formresponseUncheckedUpdateWithoutPatientInput>
    create: XOR<formresponseCreateWithoutPatientInput, formresponseUncheckedCreateWithoutPatientInput>
  }

  export type formresponseUpdateWithWhereUniqueWithoutPatientInput = {
    where: formresponseWhereUniqueInput
    data: XOR<formresponseUpdateWithoutPatientInput, formresponseUncheckedUpdateWithoutPatientInput>
  }

  export type formresponseUpdateManyWithWhereWithoutPatientInput = {
    where: formresponseScalarWhereInput
    data: XOR<formresponseUpdateManyMutationInput, formresponseUncheckedUpdateManyWithoutPatientInput>
  }

  export type clinicUpsertWithoutPatientInput = {
    update: XOR<clinicUpdateWithoutPatientInput, clinicUncheckedUpdateWithoutPatientInput>
    create: XOR<clinicCreateWithoutPatientInput, clinicUncheckedCreateWithoutPatientInput>
    where?: clinicWhereInput
  }

  export type clinicUpdateToOneWithWhereWithoutPatientInput = {
    where?: clinicWhereInput
    data: XOR<clinicUpdateWithoutPatientInput, clinicUncheckedUpdateWithoutPatientInput>
  }

  export type clinicUpdateWithoutPatientInput = {
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUpdateManyWithoutClinicNestedInput
    auditlog?: auditlogUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUpdateManyWithoutClinicNestedInput
    department?: departmentUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUpdateManyWithoutClinicNestedInput
    notification?: notificationUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUpdateManyWithoutClinicNestedInput
  }

  export type clinicUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    modules?: NullableStringFieldUpdateOperationsInput | string | null
    bookingConfig?: NullableStringFieldUpdateOperationsInput | string | null
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUncheckedUpdateManyWithoutClinicNestedInput
    auditlog?: auditlogUncheckedUpdateManyWithoutClinicNestedInput
    clinicstaff?: clinicstaffUncheckedUpdateManyWithoutClinicNestedInput
    department?: departmentUncheckedUpdateManyWithoutClinicNestedInput
    formtemplate?: formtemplateUncheckedUpdateManyWithoutClinicNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutClinicNestedInput
    medicalrecord?: medicalrecordUncheckedUpdateManyWithoutClinicNestedInput
    notification?: notificationUncheckedUpdateManyWithoutClinicNestedInput
    formresponse?: formresponseUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type auditlogCreateWithoutUserInput = {
    action: string
    performedBy: string
    timestamp?: Date | string
    ipAddress?: string | null
    device?: string | null
    details?: string | null
    clinic?: clinicCreateNestedOneWithoutAuditlogInput
  }

  export type auditlogUncheckedCreateWithoutUserInput = {
    id?: number
    action: string
    performedBy: string
    clinicId?: number | null
    timestamp?: Date | string
    ipAddress?: string | null
    device?: string | null
    details?: string | null
  }

  export type auditlogCreateOrConnectWithoutUserInput = {
    where: auditlogWhereUniqueInput
    create: XOR<auditlogCreateWithoutUserInput, auditlogUncheckedCreateWithoutUserInput>
  }

  export type auditlogCreateManyUserInputEnvelope = {
    data: auditlogCreateManyUserInput | auditlogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type clinicstaffCreateWithoutUserInput = {
    role?: $Enums.clinicstaff_role
    createdAt?: Date | string
    department?: string | null
    specialty?: string | null
    clinic: clinicCreateNestedOneWithoutClinicstaffInput
  }

  export type clinicstaffUncheckedCreateWithoutUserInput = {
    id?: number
    clinicId: number
    role?: $Enums.clinicstaff_role
    createdAt?: Date | string
    department?: string | null
    specialty?: string | null
  }

  export type clinicstaffCreateOrConnectWithoutUserInput = {
    where: clinicstaffWhereUniqueInput
    create: XOR<clinicstaffCreateWithoutUserInput, clinicstaffUncheckedCreateWithoutUserInput>
  }

  export type clinicstaffCreateManyUserInputEnvelope = {
    data: clinicstaffCreateManyUserInput | clinicstaffCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type auditlogUpsertWithWhereUniqueWithoutUserInput = {
    where: auditlogWhereUniqueInput
    update: XOR<auditlogUpdateWithoutUserInput, auditlogUncheckedUpdateWithoutUserInput>
    create: XOR<auditlogCreateWithoutUserInput, auditlogUncheckedCreateWithoutUserInput>
  }

  export type auditlogUpdateWithWhereUniqueWithoutUserInput = {
    where: auditlogWhereUniqueInput
    data: XOR<auditlogUpdateWithoutUserInput, auditlogUncheckedUpdateWithoutUserInput>
  }

  export type auditlogUpdateManyWithWhereWithoutUserInput = {
    where: auditlogScalarWhereInput
    data: XOR<auditlogUpdateManyMutationInput, auditlogUncheckedUpdateManyWithoutUserInput>
  }

  export type clinicstaffUpsertWithWhereUniqueWithoutUserInput = {
    where: clinicstaffWhereUniqueInput
    update: XOR<clinicstaffUpdateWithoutUserInput, clinicstaffUncheckedUpdateWithoutUserInput>
    create: XOR<clinicstaffCreateWithoutUserInput, clinicstaffUncheckedCreateWithoutUserInput>
  }

  export type clinicstaffUpdateWithWhereUniqueWithoutUserInput = {
    where: clinicstaffWhereUniqueInput
    data: XOR<clinicstaffUpdateWithoutUserInput, clinicstaffUncheckedUpdateWithoutUserInput>
  }

  export type clinicstaffUpdateManyWithWhereWithoutUserInput = {
    where: clinicstaffScalarWhereInput
    data: XOR<clinicstaffUpdateManyMutationInput, clinicstaffUncheckedUpdateManyWithoutUserInput>
  }

  export type appointmentCreateManyClinicInput = {
    id?: number
    patientId: number
    doctorId: number
    date: Date | string
    time: string
    status?: string
    source?: string
    referenceId?: string | null
    notes?: string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type auditlogCreateManyClinicInput = {
    id?: number
    action: string
    performedBy: string
    userId?: number | null
    timestamp?: Date | string
    ipAddress?: string | null
    device?: string | null
    details?: string | null
  }

  export type clinicstaffCreateManyClinicInput = {
    id?: number
    userId: number
    role?: $Enums.clinicstaff_role
    createdAt?: Date | string
    department?: string | null
    specialty?: string | null
  }

  export type departmentCreateManyClinicInput = {
    id?: number
    name: string
    type?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type formtemplateCreateManyClinicInput = {
    id?: number
    name: string
    specialty: string
    status?: string
    version?: number
    fields: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type invoiceCreateManyClinicInput = {
    id: string
    patientId: number
    doctorId?: number | null
    service: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type medicalrecordCreateManyClinicInput = {
    id?: number
    patientId: number
    doctorId: number
    templateId?: number | null
    visitDate?: Date | string
    type: string
    data: string
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type notificationCreateManyClinicInput = {
    id?: number
    department: string
    message: string
    status?: string
    createdAt?: Date | string
  }

  export type patientCreateManyClinicInput = {
    id?: number
    mrn?: string | null
    name: string
    age?: number | null
    email?: string | null
    phone: string
    gender?: string | null
    address?: string | null
    medicalHistory?: string | null
    allergies?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    status?: string
    createdYear?: number | null
    lastVisit?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type formresponseCreateManyClinicInput = {
    id?: number
    formId: number
    patientId: number
    doctorId: number
    answers: string
    submittedAt?: Date | string
    updatedAt?: Date | string
  }

  export type appointmentUpdateWithoutClinicInput = {
    doctorId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: patientUpdateOneRequiredWithoutAppointmentNestedInput
  }

  export type appointmentUncheckedUpdateWithoutClinicInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type appointmentUncheckedUpdateManyWithoutClinicInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditlogUpdateWithoutClinicInput = {
    action?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneWithoutAuditlogNestedInput
  }

  export type auditlogUncheckedUpdateWithoutClinicInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditlogUncheckedUpdateManyWithoutClinicInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clinicstaffUpdateWithoutClinicInput = {
    role?: Enumclinicstaff_roleFieldUpdateOperationsInput | $Enums.clinicstaff_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneRequiredWithoutClinicstaffNestedInput
  }

  export type clinicstaffUncheckedUpdateWithoutClinicInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: Enumclinicstaff_roleFieldUpdateOperationsInput | $Enums.clinicstaff_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clinicstaffUncheckedUpdateManyWithoutClinicInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    role?: Enumclinicstaff_roleFieldUpdateOperationsInput | $Enums.clinicstaff_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type departmentUpdateWithoutClinicInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type departmentUncheckedUpdateWithoutClinicInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type departmentUncheckedUpdateManyWithoutClinicInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formtemplateUpdateWithoutClinicInput = {
    name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fields?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalrecord?: medicalrecordUpdateManyWithoutFormtemplateNestedInput
    formresponse?: formresponseUpdateManyWithoutFormtemplateNestedInput
  }

  export type formtemplateUncheckedUpdateWithoutClinicInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fields?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalrecord?: medicalrecordUncheckedUpdateManyWithoutFormtemplateNestedInput
    formresponse?: formresponseUncheckedUpdateManyWithoutFormtemplateNestedInput
  }

  export type formtemplateUncheckedUpdateManyWithoutClinicInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fields?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invoiceUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    service?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: patientUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    service?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invoiceUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    service?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type medicalrecordUpdateWithoutClinicInput = {
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: patientUpdateOneRequiredWithoutMedicalrecordNestedInput
    formtemplate?: formtemplateUpdateOneWithoutMedicalrecordNestedInput
  }

  export type medicalrecordUncheckedUpdateWithoutClinicInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type medicalrecordUncheckedUpdateManyWithoutClinicInput = {
    id?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationUpdateWithoutClinicInput = {
    department?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationUncheckedUpdateWithoutClinicInput = {
    id?: IntFieldUpdateOperationsInput | number
    department?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationUncheckedUpdateManyWithoutClinicInput = {
    id?: IntFieldUpdateOperationsInput | number
    department?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type patientUpdateWithoutClinicInput = {
    mrn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUpdateManyWithoutPatientNestedInput
    invoice?: invoiceUpdateManyWithoutPatientNestedInput
    medicalrecord?: medicalrecordUpdateManyWithoutPatientNestedInput
    formresponse?: formresponseUpdateManyWithoutPatientNestedInput
  }

  export type patientUncheckedUpdateWithoutClinicInput = {
    id?: IntFieldUpdateOperationsInput | number
    mrn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: appointmentUncheckedUpdateManyWithoutPatientNestedInput
    invoice?: invoiceUncheckedUpdateManyWithoutPatientNestedInput
    medicalrecord?: medicalrecordUncheckedUpdateManyWithoutPatientNestedInput
    formresponse?: formresponseUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type patientUncheckedUpdateManyWithoutClinicInput = {
    id?: IntFieldUpdateOperationsInput | number
    mrn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    medicalHistory?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdYear?: NullableIntFieldUpdateOperationsInput | number | null
    lastVisit?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formresponseUpdateWithoutClinicInput = {
    doctorId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    formtemplate?: formtemplateUpdateOneRequiredWithoutFormresponseNestedInput
    patient?: patientUpdateOneRequiredWithoutFormresponseNestedInput
  }

  export type formresponseUncheckedUpdateWithoutClinicInput = {
    id?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formresponseUncheckedUpdateManyWithoutClinicInput = {
    id?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type medicalrecordCreateManyFormtemplateInput = {
    id?: number
    clinicId: number
    patientId: number
    doctorId: number
    visitDate?: Date | string
    type: string
    data: string
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type formresponseCreateManyFormtemplateInput = {
    id?: number
    clinicId: number
    patientId: number
    doctorId: number
    answers: string
    submittedAt?: Date | string
    updatedAt?: Date | string
  }

  export type medicalrecordUpdateWithoutFormtemplateInput = {
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: clinicUpdateOneRequiredWithoutMedicalrecordNestedInput
    patient?: patientUpdateOneRequiredWithoutMedicalrecordNestedInput
  }

  export type medicalrecordUncheckedUpdateWithoutFormtemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type medicalrecordUncheckedUpdateManyWithoutFormtemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formresponseUpdateWithoutFormtemplateInput = {
    doctorId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: clinicUpdateOneRequiredWithoutFormresponseNestedInput
    patient?: patientUpdateOneRequiredWithoutFormresponseNestedInput
  }

  export type formresponseUncheckedUpdateWithoutFormtemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formresponseUncheckedUpdateManyWithoutFormtemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    patientId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type appointmentCreateManyPatientInput = {
    id?: number
    clinicId: number
    doctorId: number
    date: Date | string
    time: string
    status?: string
    source?: string
    referenceId?: string | null
    notes?: string | null
    fees?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type invoiceCreateManyPatientInput = {
    id: string
    clinicId: number
    doctorId?: number | null
    service: string
    amount: Decimal | DecimalJsLike | number | string
    status?: string
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type medicalrecordCreateManyPatientInput = {
    id?: number
    clinicId: number
    doctorId: number
    templateId?: number | null
    visitDate?: Date | string
    type: string
    data: string
    isClosed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type formresponseCreateManyPatientInput = {
    id?: number
    clinicId: number
    formId: number
    doctorId: number
    answers: string
    submittedAt?: Date | string
    updatedAt?: Date | string
  }

  export type appointmentUpdateWithoutPatientInput = {
    doctorId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: clinicUpdateOneRequiredWithoutAppointmentNestedInput
  }

  export type appointmentUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type appointmentUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    fees?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invoiceUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    service?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: clinicUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type invoiceUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    service?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invoiceUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: IntFieldUpdateOperationsInput | number
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    service?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type medicalrecordUpdateWithoutPatientInput = {
    doctorId?: IntFieldUpdateOperationsInput | number
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: clinicUpdateOneRequiredWithoutMedicalrecordNestedInput
    formtemplate?: formtemplateUpdateOneWithoutMedicalrecordNestedInput
  }

  export type medicalrecordUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type medicalrecordUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    isClosed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formresponseUpdateWithoutPatientInput = {
    doctorId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: clinicUpdateOneRequiredWithoutFormresponseNestedInput
    formtemplate?: formtemplateUpdateOneRequiredWithoutFormresponseNestedInput
  }

  export type formresponseUncheckedUpdateWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formresponseUncheckedUpdateManyWithoutPatientInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    formId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    answers?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type auditlogCreateManyUserInput = {
    id?: number
    action: string
    performedBy: string
    clinicId?: number | null
    timestamp?: Date | string
    ipAddress?: string | null
    device?: string | null
    details?: string | null
  }

  export type clinicstaffCreateManyUserInput = {
    id?: number
    clinicId: number
    role?: $Enums.clinicstaff_role
    createdAt?: Date | string
    department?: string | null
    specialty?: string | null
  }

  export type auditlogUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: clinicUpdateOneWithoutAuditlogNestedInput
  }

  export type auditlogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditlogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    performedBy?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clinicstaffUpdateWithoutUserInput = {
    role?: Enumclinicstaff_roleFieldUpdateOperationsInput | $Enums.clinicstaff_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
    clinic?: clinicUpdateOneRequiredWithoutClinicstaffNestedInput
  }

  export type clinicstaffUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    role?: Enumclinicstaff_roleFieldUpdateOperationsInput | $Enums.clinicstaff_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clinicstaffUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    clinicId?: IntFieldUpdateOperationsInput | number
    role?: Enumclinicstaff_roleFieldUpdateOperationsInput | $Enums.clinicstaff_role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    specialty?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ClinicCountOutputTypeDefaultArgs instead
     */
    export type ClinicCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClinicCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FormtemplateCountOutputTypeDefaultArgs instead
     */
    export type FormtemplateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FormtemplateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientCountOutputTypeDefaultArgs instead
     */
    export type PatientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use appointmentDefaultArgs instead
     */
    export type appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = appointmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use auditlogDefaultArgs instead
     */
    export type auditlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = auditlogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use clinicDefaultArgs instead
     */
    export type clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = clinicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use clinicstaffDefaultArgs instead
     */
    export type clinicstaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = clinicstaffDefaultArgs<ExtArgs>
    /**
     * @deprecated Use departmentDefaultArgs instead
     */
    export type departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = departmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use formtemplateDefaultArgs instead
     */
    export type formtemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = formtemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use invoiceDefaultArgs instead
     */
    export type invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = invoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use medicalrecordDefaultArgs instead
     */
    export type medicalrecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = medicalrecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use formresponseDefaultArgs instead
     */
    export type formresponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = formresponseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use notificationDefaultArgs instead
     */
    export type notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = notificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use patientDefaultArgs instead
     */
    export type patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = patientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userDefaultArgs instead
     */
    export type userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = userDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}